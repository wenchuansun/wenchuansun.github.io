<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>GIT 本地仓库基本使用 | Nino's blog</title><meta name="keywords" content="GIT"><meta name="author" content="Nino"><meta name="copyright" content="Nino"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="长文警告！！多图警告！！一篇文章，使用 GIT 从此无烦恼！！">
<meta property="og:type" content="article">
<meta property="og:title" content="GIT 本地仓库基本使用">
<meta property="og:url" content="http://106.14.133.244/2021/10/21/tools-2/index.html">
<meta property="og:site_name" content="Nino&#39;s blog">
<meta property="og:description" content="长文警告！！多图警告！！一篇文章，使用 GIT 从此无烦恼！！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://106.14.133.244/img/blogCover/5.jpg">
<meta property="article:published_time" content="2021-10-21T12:56:25.000Z">
<meta property="article:modified_time" content="2024-01-12T08:37:08.659Z">
<meta property="article:author" content="Nino">
<meta property="article:tag" content="GIT">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://106.14.133.244/img/blogCover/5.jpg"><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="http://106.14.133.244/2021/10/21/tools-2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GIT 本地仓库基本使用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-12 16:37:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="../../css/mycss.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Nino's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">GIT 本地仓库基本使用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-21T12:56:25.000Z" title="发表于 2021-10-21 20:56:25">2021-10-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-12T08:37:08.659Z" title="更新于 2024-01-12 16:37:08">2024-01-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/">常用工具</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="GIT 本地仓库基本使用"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="将项目初始化为-GIT-仓库"><a href="#将项目初始化为-GIT-仓库" class="headerlink" title="将项目初始化为 GIT 仓库"></a>将项目初始化为 GIT 仓库</h1><p>GIT 是一种项目版本管理工具，其本身可以相当于我们项目开发过程中的一种辅助性工具，为了使用这种工具我们首先需要将项目通过 GIT 提供的命令进行初始化。</p>
<p>要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>执行这条命令后，在项目的当前目录下会出现一个名为 .git 的目录，所有 GIT 需要的数据和资源都存放在这个目录中。后续对 GIT 的各种操作，其实主要就是读写这个目录下的内容。</p>
<hr>
<h1 id="GIT-初体验"><a href="#GIT-初体验" class="headerlink" title="GIT 初体验"></a>GIT 初体验</h1><p>在将我们的项目初始化为一个 GIT 仓库后，我们就可以通过 GIT 对项目中的文件进行版本管理了。现在在我们的项目中创建第一个文件 first ：<br>通过 GIT 提供的查看仓库状态的命令 <code>git status</code> 可以查看创建这个文件后的仓库的状态：<br><img src="1.png"></p>
<p>可以发现 GIT 提示我们有一个<strong>未追踪</strong>的文件 first。这个所谓未追踪的意思就是我们刚刚创建的文件还没有被纳入到 GIT 的版本管理中，在 GIT 仓库中创建一个新的文件，新文件的状态是<strong>未追踪的</strong>；同时，GIT 将这个文件放在一种称为<strong>工作区</strong>的区域中。</p>
<p>为了将我们创建的文件纳入到 GIT 中进行管理，首先需要执行命令 <code>git add &lt;file name&gt;</code>。通过这个命令，GIT 会将指定的文件从<strong>工作区</strong>转换到一种称为<strong>暂存区</strong>的区域中，而这个命令也会将属于<strong>未追踪状态</strong>的文件转换为<strong>已追踪状态</strong>。操作如下：<br><img src="2.png"></p>
<p>通过 <code>git add</code> 命令，我们创建的 first 文件从<strong>工作区</strong>转移到了<strong>暂存区</strong>，同时其文件状态也从<strong>未追踪</strong>转换成<strong>已追踪</strong>。但此时提示我们有改变在等待提交，意思就是在我们的<strong>暂存区</strong>中放了新修改的内容，正在等待提交。</p>
<p>通过命令 <code>git commit -m &quot;some comments&quot;</code>，可以将<strong>暂存区</strong>中的文件正式提交到 <strong>GIT 仓库</strong>中，这个区域也是正式的记录下我们项目的版本的地方，我们只需要将其理解成一个快照即可。操作如下：<br><img src="3.png"></p>
<p>可以看到在提交之后，GIT 提示了我们 working tree clean，即所有的修改都加入到了新的快照中。</p>
<h2 id="场景一：修改已经提交过的文件"><a href="#场景一：修改已经提交过的文件" class="headerlink" title="场景一：修改已经提交过的文件"></a>场景一：修改已经提交过的文件</h2><p>假设我们现在需要对上述已经提交过的 first 文件进行修改，会发生什么呢，假设我们在其中第二行加上一句话 “the first modification!!!”。操作如下：<br><img src="4.png"></p>
<p>对于<strong>已追踪</strong>的文件 first ，在对其进行修改后，GIT 给出提示这个文件已经被修改了，这是文件从 <strong>GIT 仓库</strong>中又转移到了<strong>工作区</strong>，根据上述的实验可以知道，在<strong>工作区</strong>中的文件想要加入到 <strong>GIT 仓库</strong>中，首先需要通过 <code>git add</code> 命令将其转移到<strong>暂存区</strong>，再通过 <code>git commit</code> 命令将其提交到 <strong>GIT 仓库</strong>中。</p>
<p>假设这次修改我们发现是没有必要的，想要撤销这次的修改，只需要执行指令 <code>git restore &lt;file name&gt;</code> 即可。演示如下：<br><img src="5.png"></p>
<p>可以看到这次修改被丢弃了，刚刚加入到 first 中的那一行也被丢弃了。</p>
<blockquote>
<p>[注]：对已经在 GIT 仓库中的文件进行修改，也会将文件从 <strong>GIT 仓库</strong>中转移到<strong>工作区</strong>，同时这个已追踪文件的文件状态会变成<strong>已修改</strong>（modifIed）。</p>
</blockquote>
<h2 id="场景二：修改暂存区中的文件"><a href="#场景二：修改暂存区中的文件" class="headerlink" title="场景二：修改暂存区中的文件"></a>场景二：修改暂存区中的文件</h2><p>在工作的时候，有一部工作已经完成，这时候就可以将工作区的文件通过 <code>git add </code> 命令加入到<strong>暂存区</strong>暂存起来，然后等工作都完成后一起提交到 <strong>GIT 仓库</strong>。假设在后续的开发中，发现已经暂存的文件需要进行修改，这时候会发生什么呢？</p>
<p>以下示例我们创建一个新的文件 second ，加入到<strong>暂存区</strong>，然后对其进行修改，查看 GIT 状态如下：<br><img src="6.png"></p>
<p>可见，修改<strong>暂存区</strong>中的内容，会将<strong>已追踪</strong>的文件设置为<strong>已修改</strong>状态，然后通过 <code>git status</code> 看到有两个 second 的记录，如图所示，这两个 second 的记录不是同一个记录。假设此时我们用 <code>git commit</code> 来提交记录，则在 <strong>GIT 仓库</strong>中记录的是<strong>暂存区</strong>中包含一行的 second 文件记录。假设我们要撤销<strong>已修改</strong>状态的 second，同样只需要用上节的 <code>git restore</code> 命令，但是想要撤销上一次加入到<strong>暂存区</strong>中的 second，则需要加入选项 <code>--staged</code>，操作如下：<br><img src="7.png"></p>
<h2 id="场景三：移除-GIT-仓库中的文件"><a href="#场景三：移除-GIT-仓库中的文件" class="headerlink" title="场景三：移除 GIT 仓库中的文件"></a>场景三：移除 GIT 仓库中的文件</h2><p>假设我们不小心把某些没必要的文件也提交到了 GIT 仓库中，这时候应该怎么移除掉这种记录呢？当前的状态如下，仅有一个 first 文件，接下来移除 GIT 仓库对其的记录：<br><img src="8.png"></p>
<p>为了移除 first 文件，运行 <code>git rm</code> 命令，该命令会将 GIT 仓库中的 first 标识为<strong>已删除</strong>状态，并且转移到<strong>暂存区</strong>，而且也将工作目录中的 first 删除掉（<code>git rm</code> 相当于 rm 后再 <code>git add</code>）。<br><img src="9.png"></p>
<p>假设我们只想要移除掉 GIT 仓库中对文件的目录，而不想删除掉工作目录中的文件，应该怎么办呢？？只需要执行命令 <code>git rm --cached</code> 即可。<br>该命令会将 GIT 仓库中 first 记录移除，也就是将 first 标记为<strong>已删除</strong>状态，但是不会删掉工作目录中的 first 文件，所以还会多出一个未追踪的 first 。如下所示：<br><img src="10.png"></p>
<h2 id="场景四：移动某个文件"><a href="#场景四：移动某个文件" class="headerlink" title="场景四：移动某个文件"></a>场景四：移动某个文件</h2><p>不像其他的 VCS 系统，Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作，不过 Git 非常聪明，它会推断出究竟发生了什么。使用 <code>git mv</code> 命令就可以移动某个文件了，操作如下：<br><img src="11.png"></p>
<p>可见使用 <code>git mv</code> 命令，first 文件被删除了，然后创建了 <code>first_name</code>，并且已经将其放入到了<strong>暂存区</strong>。所以 git mv 命令相当于如下三条命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv first first_rename</span><br><span class="line">git rm first</span><br><span class="line">git add first_rename</span><br></pre></td></tr></table></figure>

<h2 id="查看工作区、暂存区和-GIT-仓库的不同"><a href="#查看工作区、暂存区和-GIT-仓库的不同" class="headerlink" title="查看工作区、暂存区和 GIT 仓库的不同"></a>查看工作区、暂存区和 GIT 仓库的不同</h2><p>使用命令 <code>git status</code> 只能看到当前的项目文件级别的变更记录，如果想看到文件内容的不同，则需要 <code>git diff</code> 命令。</p>
<ul>
<li><code>git diff</code>：查看<strong>工作区</strong>相对于<strong>暂存区</strong>的变化</li>
<li><code>git diff --cached</code>：查看 <strong>暂存区</strong>相当于 <strong>GIT 仓库</strong>的变化</li>
</ul>
<p>假设在 GIT 仓库中已经有了一个 first 文件，其中仅有一行文本信息。当前整个项目文件夹的状态如下：<br><img src="12.png"></p>
<p>修改 first 文件，加入一行文本，查看状态如下：<br><img src="13.png"></p>
<p>可以看到，当使用 <code>git diff</code> 命令时，会将 first 文件中的信息打印出来，并且标示出<strong>工作区</strong>中当前 first 文件和暂存区中的区别；而使用 <code>git diff --cached</code> 没有打印出任何信息，这证明<strong>暂存区</strong>中的 first 文件和 <strong>GIT 仓库</strong>中的 first 文件是完全一样的。</p>
<p>通过 <code>git add </code> 命令将 first 文件保存到<strong>暂存区</strong>，然后查看不同：<br><img src="14.png"></p>
<p>这一次，工作区和暂存区相同了，而<strong>暂存区</strong>相对于 <strong>GIT 仓库</strong>有了变化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 GIT 中有几个比较重要的概念，首先是文件所在的区域有三个，包括<strong>工作区</strong>、<strong>暂存区</strong>、<strong>GIT 仓库</strong>。然后是文件状态，<strong>未追踪</strong>（一般是新文件）、<strong>已追踪</strong>（显示或者隐式执行过 <code>git add</code> 的文件）、<strong>已修改</strong>（修改已追踪文件得到的状态）。通过下图可以很显然的展示出文件的变化过程：<br><img src="15.png"></p>
<hr>
<h1 id="GIT-仓库的版本回退"><a href="#GIT-仓库的版本回退" class="headerlink" title="GIT 仓库的版本回退"></a>GIT 仓库的版本回退</h1><blockquote>
<p>这一节主要讲 <code>git reset</code> 命令来进行版本回退、<code>git revert</code> 来撤销某次提交记录 </p>
</blockquote>
<p>GIT 作为版本管理工具，在每次提交的时候都会形成一个快照，那么怎么查看历史的提交记录呢？？对于历史的提交我们又可以做什么样的操作呢？？我们从一个例子说起。</p>
<p>假设有一个文件 profile 用来存放个人信息，为了更加方便的探索 GIT 提交记录，我们每次输入一行信息就提交一次，现在，我们分三次分别提交了姓名、邮箱和性别三条记录。profile 文件目前的状态如下：<br><img src="16.png"></p>
<p>通过 <code>git log</code> 命令，我们可以看到当前仓库的提交记录信息，总共有三次提交，对应了 profile 文件中的三行信息。<br>其实，GIT 会将每次提交用链表一样的结构保存起来，其中有个 <strong>HEAD 指针</strong>，总是指向当前分支的的当前记录结点。所以上述工程的提交记录树应该如下：<br><img src="17.png"></p>
<h2 id="场景一：最近一次提交记录的修改"><a href="#场景一：最近一次提交记录的修改" class="headerlink" title="场景一：最近一次提交记录的修改"></a>场景一：最近一次提交记录的修改</h2><p>假设我们发现最近的一次提交中写的 I’m a boy. 显得很不正式，需要进行修改，于是我们将 profile 的最后一行修改，如下：<br><img src="18.png"></p>
<p>profile 文件变成了<strong>已修改</strong>状态，如果我们用普通的 <code>git add</code> 和 <code>git commit -m</code> 命令的话，会生成一个新的提交记录，但这不是我们希望的，我们希望修改最近的一次提交记录即可。此时只需要运行 <code>git add</code> 和 <code>git commit --amend</code>，则 GIT 会弹出编辑 commit 信息的窗口，提示你是否需要修改 commit 信息，在保存退出后则将最近一次的提交记录所修改。其实这个命令的原理也就是将<strong>暂存区</strong>中的文件覆盖 <strong>GIT 仓库</strong>中最近的一次提交，这个操作可以让我们在提交后发现 commit 信息写错了的情况下修改 commit 信息（不修改文件，直接 <code>git commit --amend</code>，再修改 commit 信息即可）。<br><img src="19.png"></p>
<p>可以看到，对 profile 进行修改提交后，还是只有三条提交记录。<br><img src="20.png"></p>
<blockquote>
<p>[注]：假设在上面的操作后，我们发现修改后的也不对，需要回退到修改前的状态，可是，由于新的修改已经把之前的记录覆盖了，那么应该怎么做呢？<br>这时候可以先输入 <code>git reflog</code>，这个命令可以查看之前对于 HEAD 指针的操作记录，从而定位到某次提交的 sha-1 值，然后通过 <code>git reset</code> 命令则可以将 HEAD 指针指到修改前的提交记录上。</p>
</blockquote>
<p><img src="21.png"></p>
<p><img src="22.png"></p>
<p>可以看到我们重置了 HEAD 指针到修改前的提交记录。</p>
<h2 id="场景二：版本回退"><a href="#场景二：版本回退" class="headerlink" title="场景二：版本回退"></a>场景二：版本回退</h2><p>在上一小节中，我们已经体验过了使用 <code>git reset</code> 命令进行版本回退，其实 <strong>reset</strong> 就是重置的意思，所谓的版本回退就是将 HEAD 指针回退某一次提交记录。回到本节最开始的时候 profile 的状态：<br><img src="23.png"></p>
<p><code>git reset</code> 命令有三个重要的选项 </p>
<ul>
<li><code>--mixed</code>：默认情况，将<strong>暂存区</strong>和 <strong>GIT 仓库</strong>中的提交记录回退到某一个版本，不改变工作区内容。</li>
<li><code>--soft</code>：仅仅将 <strong>GIT 仓库</strong>中的提交记录回退到某一个版本，不改变工作区和暂存区的内容。</li>
<li><code>--hard</code>：谨慎使用，将<strong>工作区</strong>、<strong>暂存区</strong>和 <strong>GIT 仓库</strong>都回退到某一个版本，工作区中未提交的修改会丢失。<strong>由于该选项会丢失工作区中的内容，所以在使用前一定要很谨慎</strong>！！！</li>
</ul>
<p>假设我们给 profile 文件加入了地址信息：<br><img src="24.png"></p>
<p>此时我们还没有提交地址这条记录，但是我们不想要性别这条记录了，希望回退一个版本，这时候需要用到命令 <code>git reset</code>。<br>假如使用 <code>git reset --hard </code> 命令，则将我们工作区中关于地址的记录给弄丢了，这显然不是我们愿意看到的，所以可以使用 <code>--soft</code> 或者 <code>--mixed</code> 选项，如下：<br><img src="25.png"></p>
<p>这时候，我们仅需要在工作区将 profile 中关于性别那一行删除，然后再继续后续提交即可。<br><img src="26.png"></p>
<p>上面使用了命令<code>git reset --mixed HEAD^</code>，其中<code>HEAD^</code>表示将 HEAD 指针向上移动一个版本，如果是上上个版本则用 <code>HEAD^^</code>，依次类推。若要回退的版本很多，则可以使用 <code>HEAD~n</code> 来代替，其中 n 是指回退 n 个版本。</p>
<h2 id="场景三：撤销某次提交"><a href="#场景三：撤销某次提交" class="headerlink" title="场景三：撤销某次提交"></a>场景三：撤销某次提交</h2><p>在很多时候，我们并不需要把整个项目都往前回滚到一个时间点，而仅仅需要将以前某次的提交给它撤销了，这时候就要用到 <code>git revert</code> 命令，这个命令就相当于接着当前所有提交记录的一次提交，比如说上述我们希望把性别那次提交给撤销了，我们上小节是直接回滚到上一个版本来进行的，如果在性别那次提交后还有很多的提交记录，那么上述方法会丢弃所有这些记录。但是用 <code>git revert</code> 则可以对指定的某次提交进行撤销而不会发生上述情况，假设我们要撤销上面 profile 的最后一次提交：<br><img src="27.png"></p>
<p>可见，在 <code>git revert</code> 命令后，多了一个提交记录，这个提交记录就是将第三次提交撤销的提交记录。<br><img src="28.png"></p>
<hr>
<h1 id="GIT-分支管理"><a href="#GIT-分支管理" class="headerlink" title="GIT 分支管理"></a>GIT 分支管理</h1><p>有人把 Git 的分支模型称为“必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。Git 有何特别之处呢？Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。</p>
<h2 id="提交操作发生了什么？"><a href="#提交操作发生了什么？" class="headerlink" title="提交操作发生了什么？"></a>提交操作发生了什么？</h2><p><font color=red>首先要有一个概念，GIT 保存的不是各个文件之间的差异和变化量，而是通过压缩方式保存了一系列文件快照。其中每个文件的快照是一个称为 <strong>blob</strong> 的对象，而在提交后，这次提交的文件快照都用一个称为 <strong>tree</strong> 的对象（一个 <strong>tree</strong> 对象对应一个文件目录）索引，对应的提交也会用一个称为 <strong>commit</strong> 的对象来保存这次提交（包括指向 <strong>tree</strong> 对象的指针，本次提交的作者等相关附属信息，零个或多个指向该提交对象的父对象指针）。</font></p>
<p>假设在我们的工作目录中有三个文件，准备将他们暂存后提交。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add README test.rb LICENSE</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;initial commit of my project&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>暂存操 <code>git add</code> 作会根据每个文件的内容计算校验和（sha-1算法），然后将这些校验和作为文件快照的名字保存到暂存区中（GIT 使用 blob 类型的对象存储这些快照）。当使用 <code>git commit</code> 新建一个提交对象前，GIT 会计算每一个子目录（本例子中就是根目录）的校验和，然后将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。现在，GIT 仓库中有五个对象：</p>
<ul>
<li>三个表示文件快照内容的 blob 对象</li>
<li>一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象</li>
<li>一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 commit 对象</li>
</ul>
<p>概念上看，仓库中各个对象保存的数据和关系看起来如图：<br><img src="29.png"></p>
<p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的 <strong>parent</strong> 对象）。两次提交后，仓库历史会变成如下图所示：<br><img src="30.png"></p>
<h2 id="分支的本质"><a href="#分支的本质" class="headerlink" title="分支的本质"></a>分支的本质</h2><p>GIT 中分支，其实本质上仅仅是个指向 commit 对象的可变指针。在初始化一个项目后进行第一次提交的时候，GIT 会使用 master 作为默认分支的名字，在若干次提交后，其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。<br><img src="31.png"></p>
<p><font color=red>那么创建一个分支的时候会发生什么呢？</font>其实很简单，创建一个新的分支指针。比如新建一个 testing 分支，可以使用 <code>git branch</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch testing</span></span><br></pre></td></tr></table></figure>
<p>这会在<strong>当前 commit 对象上</strong>新建一个分支指针。<br><img src="32.png"></p>
<p><font color=red>GIT 如何知道你在当前哪个分支上工作呢？</font>其实也是通过一个指针，上述的 HEAD 指针，这是一个指向你正在工作中的本地分支的指针，该指针指向的分支指针则表示当前所在的分支。使用 <code>git branch</code> 可以查看分支信息，其中当前分支的前面会有一个 <code>*</code> 号。<br><img src="33.png"></p>
<p>在上述的例子中，仅仅是新建了分支还没有切换分支，所以其关系如下：<br><img src="34.png"></p>
<p>要切换到其他分支，可以使用 <code>git checkout</code> 命令。假设我们要切换到 testing 分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout testing</span></span><br></pre></td></tr></table></figure>

<p><img src="35.png"></p>
<p>这样在不同分支上的提交则将产生分叉，HEAD 指针随着分支一起向前移动。</p>
<h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>假设我们的 GIT 仓库状态如下图所示，在主分支基础上创建了两个分支，然后分别进行了开发。<br><img src="36.png"></p>
<p>如果，hotfix 分支目前已经完成了开发，这时候就需要将其合并到主分支，然后进行发布。使用 <code>git merge &lt;branch&gt;</code> 命令合并，该命令将 branch 合并到当前上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master		<span class="comment"># 先切换到 master 分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge hotfix		<span class="comment"># 将 hotfix 分支合并到当前的 master 分支</span></span></span><br><span class="line">	Updating f42c576..3a0874c</span><br><span class="line">	Fast forward</span><br><span class="line">	README | 1 -</span><br><span class="line">	1 files changed, 0 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure>
<p>注意到，合并时出现了 “Fast forward” 的提示。这是因为 master 分支所在的提交对象是要并入的 hotfix 分支的直接上游，GIT 只需要把 master 分支指针直接右移。换句话说，<strong>如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</strong> 现在最新的修改已经在当前 master 分支所指向的提交对象中了。<br><img src="37.png"></p>
<p>这时候，hotfix 分支已经完成了自己的使命，可以删掉了。<br>首先我们可以使用 <code>git branch --merged</code> 来查看哪些分支已经被并入到了当前分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --merged</span></span><br><span class="line">	hotfix</span><br><span class="line">	*master</span><br></pre></td></tr></table></figure>
<p>一般来说，列表中没有 <code>*</code> 的分支都可以使用 <code>git branch -d</code> 将其删除，因为其所作的修改已经并入到了当前的分支中了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d hotfix</span></span><br><span class="line">    Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure>
<p>同样，也可以用 <code>git branch --no-merged</code> 来查看未合并的工作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --no-merged</span></span><br><span class="line">	iss53</span><br></pre></td></tr></table></figure>
<p>它会显示还未合并进来的分支。由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用 <code>git branch -d</code> 删除该分支会提示错误，因为那样做会丢失数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d iss53</span></span><br><span class="line">    error: The branch &#x27;iss53&#x27; is not an ancestor of your current HEAD.</span><br><span class="line">    If you are sure you want to delete it, run &#x27;git branch -D iss53&#x27;.</span><br></pre></td></tr></table></figure>
<p>假设现在 iss53 也完成了开发任务，需要合并到主分支上：<br><img src="38.png"></p>
<p>实际操作同前面合并 hotfix 分支差不多，只需回到 master 分支，运行 git merge 命令指定要合并进来的分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br><span class="line">    Merge made by recursive.</span><br><span class="line">    README | 1 +</span><br><span class="line">    1 files changed, 1 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure>
<p>请注意，这次合并操作的底层实现，并不同于之前 hotfix 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 master 分支所指向的提交对象（C4）并不是 iss53 分支的直接祖先，GIT 不得不进行一些额外处理。就此例而言，GIT会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。如下图所示：<br><img src="39.png"></p>
<p>这次，GIT 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6），如下图。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p>
<p>值得一提的是 GIT 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 GIT 的合并操作比其他系统都要简单不少。<br><img src="40.png"></p>
<h2 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h2><p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，GIT 就无法干净地把两者合到一起，这种问题只能由人来裁决。以上述合并 iss53 分支为例，如果你在处理分支 iss53 的时候，将得到类似下面的结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br><span class="line">    Auto-merging index.html</span><br><span class="line">    CONFLICT (content): Merge conflict in index.html</span><br><span class="line">    Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<p>GIT 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 <code>git status</code> 查阅：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">    index.html: needs merge</span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes not staged for commit:</span><br><span class="line">    # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">    # (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">    #</span><br><span class="line">    # unmerged: index.html</span><br><span class="line">    #</span><br></pre></td></tr></table></figure>
<p>任何包含未解决冲突的文件都会以<strong>未合并（unmerged）</strong> 的状态列出。GIT 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    =======</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">    please contact us at support@github.com</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure>
<p>可以看到 =======  隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">    please contact us at email.support@github.com</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为<strong>已解决状态</strong>，实际上就是来一次快照保存到暂存区域。因为一旦暂存，就表示冲突已经解决。再运行一次 <code>git status</code> 来确认所有冲突都已解决：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes to be committed:</span><br><span class="line">    # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    #</span><br><span class="line">    # modified: index.html</span><br><span class="line">    #</span><br></pre></td></tr></table></figure>
<p>如果觉得满意了，则可以直接提交。</p>
<h2 id="采用-rebase-来合并分支"><a href="#采用-rebase-来合并分支" class="headerlink" title="采用 rebase 来合并分支"></a>采用 rebase 来合并分支</h2><p>把一个分支中的修改整合到另一个分支的办法有两种：<strong>merge</strong> 和 <strong>rebase</strong>。</p>
<p>假设当前的分支状态如下：<br><img src="41.png"></p>
<p>最容易合并分支的方法是 merge 命令，它会把两个分支最新的快照（C3 和 C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5）。如图：<br><img src="42.png"></p>
<p>而采用 <strong>rebase</strong> 的方式也可以进行分支合并，其实际上就是把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍。<font color=red><strong>有了 rebase 命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍</strong>。</font><br>在这个例子里，运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout experiment</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase master</span></span><br><span class="line">    First, rewinding head to replay your work on top of it...</span><br><span class="line">    Applying: added staged command</span><br></pre></td></tr></table></figure>
<p><strong>它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行 rebase 的分支 experiment）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 master）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 experiment 的提交历史，使它成为 master 分支的直接下游。</strong><br><img src="43.png"></p>
<p>然后再回到 master，进行一次 fast forward 合并。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge experiment</span> </span><br></pre></td></tr></table></figure>
<p><img src="44.png"></p>
<p>现在的 C3’ 对应的快照，其实和普通的三方合并，即上个例子中的 C5 对应的快照内容一模一样了。虽然最后整合得到的结果没有任何区别，但衍合能产生一个<strong>更为整洁</strong>的提交历史。如果视察一个 rebase 过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。</p>
<p>一般我们使用 rebase 的目的，是想要得到一个能在远程分支上干净应用的补丁 — 比如某些项目你不是维护者，但想帮点忙的话，最好用 rebase：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的 origin/master 进行一次 rebase 操作然后再提交，这样维护者就不需要做任何整合工作（实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。</p>
<p>请注意，合并结果中最后一次提交所指向的快照，无论是通过 rebase，还是 merge 合并，都会得到相同的快照内容，只不过提交历史不同罢了。rebase 是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p>
<hr>
<h1 id="命令汇总"><a href="#命令汇总" class="headerlink" title="命令汇总"></a>命令汇总</h1><p><code>git init</code>：初始化一个仓库<br><code>git add &lt;files&gt;</code>：将文件暂存，文件会被标记为<strong>已追踪</strong>状态<br><code>git commit -m &quot;comments&quot;</code>：提交暂存区中的记录<br><code>git restore &lt;file&gt;</code>：回撤<strong>工作区</strong>相对于 <strong>GIT 仓库</strong> 的修改<br><code>git restore --staged &lt;file&gt;</code>：回撤<strong>工作区</strong>相对于<strong>暂存区</strong>的修改<br><code>git diff</code>：查看<strong>工作区</strong>相对于<strong>暂存区</strong>的变化<br><code>git diff --cached</code>：查看 <strong>暂存区</strong>相当于 <strong>GIT 仓库</strong>的变化<br><code>git rm &lt;files&gt;</code>：删除某个文件及其记录（在工作目录中也删除了）<br><code>git rm --cached &lt;files&gt;</code>：删除某个文件在 <strong>GIT 仓库</strong>中的记录（不会删除工作目录中的文件）<br><code>git mv &lt;file_name&gt; &lt;file_rename&gt;</code>：移动（重命名）某个文件<br><code>git log</code>：查看 GIT 仓库的提交记录<br><code>git reflog</code>：查看 HEAD 指针的操作记录<br><code>git reset [--mixed|--soft|--hard] [HEAD|sha-1]</code>：版本回退，将 HEAD 指针重置到某个版本处<br><code>git revert &lt;commit&gt;</code>：撤销某次提交<br><code>git branch &lt;branch_name&gt;</code>：在当前的 <strong>commit</strong> 对象处创建一个分支指针<br><code>git branch</code>：查看分支信息<br><code>git branch -d &lt;branch_name&gt;</code>：删除某个分支<br><code>git branch --merged</code>：查看<strong>已经合并</strong>到当前分支中的分支<br><code>git branch --no-merged</code>：查看<strong>未合并</strong>到当前分支中的分支<br><code>git checkout &lt;branch_name&gt;</code>：切换到某个分支<br><code>git checkout -b &lt;branch_name&gt;</code>：创建并且切换到某个分支<br><code>git merge &lt;branch_name&gt;</code>：将 branch_name 合并到当前分支<br><code>git rebase &lt;branch_name&gt;</code>：将当前分支上的改动整合到 branch_name 所指向的分支上去，并基于 branch_name 所指向分支创建新的提交记录，将当前分支指向到该提交记录</p>
<hr>
<blockquote>
<p>参考资料：《Pro Git》</p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GIT/">GIT</a></div><div class="post_share"><div class="social-share" data-image="/img/blogCover/5.jpg" data-sites="twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/10/21/tools-3/"><img class="prev-cover" src="/img/blogCover/6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">如何用 GIT 暂存未提交的改动 （stashing 功能）</div></div></a></div><div class="next-post pull-right"><a href="/2021/10/21/tools-1/"><img class="next-cover" src="/img/blogCover/4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CMake 入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/10/21/tools-3/" title="如何用 GIT 暂存未提交的改动 （stashing 功能）"><img class="cover" src="/img/blogCover/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-21</div><div class="title">如何用 GIT 暂存未提交的改动 （stashing 功能）</div></div></a></div><div><a href="/2021/10/21/tools-5/" title="GIT 底层原理"><img class="cover" src="/img/blogCover/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-21</div><div class="title">GIT 底层原理</div></div></a></div><div><a href="/2021/10/21/tools-6/" title="GIT 如何恢复在没合并之前就删除的分支（detached HEAD）"><img class="cover" src="/img/blogCover/9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-21</div><div class="title">GIT 如何恢复在没合并之前就删除的分支（detached HEAD）</div></div></a></div><div><a href="/2021/10/21/tools-7/" title="GIT 中如何打标签（git tag）"><img class="cover" src="/img/blogCover/10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-21</div><div class="title">GIT 中如何打标签（git tag）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Nino</div><div class="author-info__description">Master, teaching makes you.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wenchuansun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wenchuansun" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://leetcode-cn.com/u/tempestate_" target="_blank" title="leetcode"><i class="fas fa-laptop"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%86%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BA-GIT-%E4%BB%93%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">将项目初始化为 GIT 仓库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GIT-%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-number">2.</span> <span class="toc-text">GIT 初体验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9A%E4%BF%AE%E6%94%B9%E5%B7%B2%E7%BB%8F%E6%8F%90%E4%BA%A4%E8%BF%87%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">场景一：修改已经提交过的文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C%EF%BC%9A%E4%BF%AE%E6%94%B9%E6%9A%82%E5%AD%98%E5%8C%BA%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">场景二：修改暂存区中的文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%89%EF%BC%9A%E7%A7%BB%E9%99%A4-GIT-%E4%BB%93%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">场景三：移除 GIT 仓库中的文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%9B%9B%EF%BC%9A%E7%A7%BB%E5%8A%A8%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.</span> <span class="toc-text">场景四：移动某个文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E6%9A%82%E5%AD%98%E5%8C%BA%E5%92%8C-GIT-%E4%BB%93%E5%BA%93%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">2.5.</span> <span class="toc-text">查看工作区、暂存区和 GIT 仓库的不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GIT-%E4%BB%93%E5%BA%93%E7%9A%84%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80"><span class="toc-number">3.</span> <span class="toc-text">GIT 仓库的版本回退</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9A%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">3.1.</span> <span class="toc-text">场景一：最近一次提交记录的修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C%EF%BC%9A%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80"><span class="toc-number">3.2.</span> <span class="toc-text">场景二：版本回退</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%89%EF%BC%9A%E6%92%A4%E9%94%80%E6%9F%90%E6%AC%A1%E6%8F%90%E4%BA%A4"><span class="toc-number">3.3.</span> <span class="toc-text">场景三：撤销某次提交</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GIT-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">GIT 分支管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E6%93%8D%E4%BD%9C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">提交操作发生了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">4.2.</span> <span class="toc-text">分支的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6"><span class="toc-number">4.3.</span> <span class="toc-text">分支合并</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E5%86%B2%E7%AA%81%E6%97%B6%E7%9A%84%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6"><span class="toc-number">4.4.</span> <span class="toc-text">遇到冲突时的分支合并</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%87%E7%94%A8-rebase-%E6%9D%A5%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF"><span class="toc-number">4.5.</span> <span class="toc-text">采用 rebase 来合并分支</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB"><span class="toc-number">5.</span> <span class="toc-text">命令汇总</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/llvm-5/" title="学会调试 LLVM opt 中的 PassManager 和 AnalysisManager"><img src="/img/blogCover/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学会调试 LLVM opt 中的 PassManager 和 AnalysisManager"/></a><div class="content"><a class="title" href="/2022/04/16/llvm-5/" title="学会调试 LLVM opt 中的 PassManager 和 AnalysisManager">学会调试 LLVM opt 中的 PassManager 和 AnalysisManager</a><time datetime="2022-04-16T06:19:45.000Z" title="发表于 2022-04-16 14:19:45">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/llvm-4/" title="怎么基于 Pass New Manager 利用 PassPlugin 写 LLVM Pass（out-of-tree Pass Development）"><img src="/img/blogCover/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="怎么基于 Pass New Manager 利用 PassPlugin 写 LLVM Pass（out-of-tree Pass Development）"/></a><div class="content"><a class="title" href="/2022/04/16/llvm-4/" title="怎么基于 Pass New Manager 利用 PassPlugin 写 LLVM Pass（out-of-tree Pass Development）">怎么基于 Pass New Manager 利用 PassPlugin 写 LLVM Pass（out-of-tree Pass Development）</a><time datetime="2022-04-16T06:18:11.000Z" title="发表于 2022-04-16 14:18:11">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/llvm-3/" title="怎样在 opt 中利用 new PassManager 中写 Pass"><img src="/img/blogCover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="怎样在 opt 中利用 new PassManager 中写 Pass"/></a><div class="content"><a class="title" href="/2022/04/16/llvm-3/" title="怎样在 opt 中利用 new PassManager 中写 Pass">怎样在 opt 中利用 new PassManager 中写 Pass</a><time datetime="2022-04-16T06:16:18.000Z" title="发表于 2022-04-16 14:16:18">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/underlyingPrinciple-9/" title="深入理解对象内存模型（二）"><img src="/img/blogCover/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解对象内存模型（二）"/></a><div class="content"><a class="title" href="/2022/03/31/underlyingPrinciple-9/" title="深入理解对象内存模型（二）">深入理解对象内存模型（二）</a><time datetime="2022-03-31T12:05:47.000Z" title="发表于 2022-03-31 20:05:47">2022-03-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Nino</div><div class="footer_custom_text">Hi, welcome to my pretty blog!</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><!--<img src="https://static.dy208.cn/o_1dfilp8ruo521thr1hvf18ji17soa.png">--><a href="http://www.beian.miit.gov.cn/" target="_blank"> | 湘ICP备2022001549号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script>(function(d, w, c) {
    w.ChatraID = 'yEBQMsndkiJxuHuQb';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>