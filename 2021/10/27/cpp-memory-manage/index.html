<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++ 内存管理 ------ new 操作符、operator new 函数、placement new 函数 | Nino's blog</title><meta name="keywords" content="C++"><meta name="author" content="Nino"><meta name="copyright" content="Nino"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="你真的用清楚了 new 和 delete 吗？ C++ 怎么实现一个自己的内存池呢？">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 内存管理 ------ new 操作符、operator new 函数、placement new 函数">
<meta property="og:url" content="http://106.14.133.244/2021/10/27/cpp-memory-manage/index.html">
<meta property="og:site_name" content="Nino&#39;s blog">
<meta property="og:description" content="你真的用清楚了 new 和 delete 吗？ C++ 怎么实现一个自己的内存池呢？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://106.14.133.244/img/blogCover/13.jpg">
<meta property="article:published_time" content="2021-10-27T14:12:49.000Z">
<meta property="article:modified_time" content="2023-10-25T09:51:48.000Z">
<meta property="article:author" content="Nino">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://106.14.133.244/img/blogCover/13.jpg"><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="http://106.14.133.244/2021/10/27/cpp-memory-manage/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ 内存管理 ------ new 操作符、operator new 函数、placement new 函数',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-25 17:51:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="../../css/mycss.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Nino's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">C++ 内存管理 ------ new 操作符、operator new 函数、placement new 函数</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-27T14:12:49.000Z" title="发表于 2021-10-27 22:12:49">2021-10-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-25T09:51:48.000Z" title="更新于 2023-10-25 17:51:48">2023-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++ 内存管理 ------ new 操作符、operator new 函数、placement new 函数"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 C 语言中，我们使用的最多的与内存分配释放相关的函数是 malloc 和 free。而在 C++ 中，我们通常不直接使用 malloc 和 free 函数来操作内存，而是通过 C++ 中内置的操作符 new 和 delete 来进行内存的分配和释放。但是，你真的理解 new 和 delete 背后的实现原理吗？你又是否经常听到 new operator 和 operator new 这样的词，但是无法理清思绪而分不清其区别呢？接下来这篇文章就详细的讲解 C++ 内存管理中常用到的几个 primitive 级别的概念：new 操作符、operator new 函数、placement new 函数。</p>
<hr>
<h1 id="new-operator-的工作机理"><a href="#new-operator-的工作机理" class="headerlink" title="new operator 的工作机理"></a>new operator 的工作机理</h1><p>所谓 new operator ，翻译成中文就是 new 操作符，操作符在 C++ 中以关键字形式实现的一种语法特性，所以，new 和 delete 只不过是 C++ 中的关键字罢了。C++ 是如何处理这些关键字的呢？在我们 new 一个对象的时候，编译器是如何帮我们处理的呢？delete 操作符呢？在这里，我们先说出结论：</p>
<p><strong>new 一个对象。</strong>这里一般是包括三个步骤：</p>
<ul>
<li>首先，调用 operator new 函数（没错，就是 operator new 函数，暂时只需要将其理解为一个特殊名字的普通函数就行）分配一个类对象大小的内存，然后返回该内存的指针，指针类型是 void * 。</li>
<li>然后，将返回的指针转换成类类型。</li>
<li>最后，通过类类型的指针在分配的内存上调用指定的类构造函数，初始化对象，并返回指向该对象的指针。</li>
</ul>
<p><strong>delete 一个对象。</strong>这里一般是包括三个步骤：</p>
<ul>
<li>首先，通过指向该对象的指针调用对象的析构函数。</li>
<li>然后，将指向该对象的指针转换成 void * 类型。</li>
<li>最后，调用 operator delete 函数来释放由 operator new 分配的空间。</li>
</ul>
<p>我们可以通过以下示例来演示上述的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="built_in">A</span>():<span class="built_in">a</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">	~<span class="built_in">A</span>()&#123; a = <span class="number">2</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A *a = <span class="keyword">new</span> A;</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过 clang 编译器将这两行代码转变为 llvm IR，观察其具体的过程：</p>
<p><img src="1.png"></p>
<p>可以很显然的看出，在 IR 层次，对 new 操作符和 delete 操作符都如上述所描述三个步骤一致。</p>
<blockquote>
<p>我们还可以使用 new 动态分配 const 对象，如下：<br><code>const int *p = new const int(1024);</code><br>这种方式就会分配并初始化一个 const int，类似于其他的任何 const 对象，一个动态分配的 const 对象也必须进行初始化。</p>
</blockquote>
<hr>
<h1 id="operator-new-函数的重载"><a href="#operator-new-函数的重载" class="headerlink" title="operator new 函数的重载"></a>operator new 函数的重载</h1><p>在上述对 new 操作的讨论中，我们知道了实际上在 new‘ 一个对象时其实是有三个步骤的，而其中第一个步骤就是调用 operator new 函数来向操作系统申请分配内存的，我们发现并没有在任何地方看到这个函数的声明和定义，那为什么可以直接用呢？其实这个函数是标准库为我们添加的，已经内置在标准库的实现当中。既然 operator new 是一个函数，那肯定可以重载了，确实，C++ 在内存管理这块，给用户提供了很大的便利，因为申请的内存的动作是被包装在 operator new 函数中，所以只需要重载 operator new 函数，我们用户就可以实现自己的内存管理。</p>
<p>注意，<strong>用户可以自定义全局的 operator new 和 operator delete 函数，也可以将它们定义为某个类的成员函数。</strong>在实际使用中，我们是很少自定义全局的 operator new 函数的，即使这个行为是被允许的，因为一旦重载了全局的 operator new 函数，应用程序的内存分配任务都会受到影响，这并不是我们期望看到的。</p>
<p>当编译器发现一条 new 表达式或 delete 表达式后，将在程序中查找可供调用的 operator 函数。如果被分配（释放）的对象是类类型的，则编译器首先在类及其基类的作用域中查找。也就说，编译器会优先使用用户定义在类中的 operator new 和 operator delete 的重载，其次是用户定义的全局的重载，如果都没有找到，再使用标准库定义的版本。</p>
<p>下面的代码简单的使用我们对于 operator new 函数的重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A ctor!\n&quot;</span>; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A dtor!\n&quot;</span>; &#125;</span><br><span class="line">	<span class="comment">// 重载类 A 中的 operator new 函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> s)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A::operator new!\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">malloc</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 重载类 A 中的 operator delete 函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;A::operator delete!\n&quot;</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A *p = <span class="keyword">new</span> A;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************** output ***********************</span></span><br><span class="line"><span class="comment">	A::operator new!</span></span><br><span class="line"><span class="comment">	A ctor!</span></span><br><span class="line"><span class="comment">	A dtor!</span></span><br><span class="line"><span class="comment">	A::operator delete!</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br></pre></td></tr></table></figure>
<p>可见在 main 函数中 new 一个 A 的对象的时候，调用了 A 中重载的 operator new 和 operator delete 函数。</p>
<p>编译器已经为我们定义了 operator new 和 operator delete 的 4 个重载版本：<br><code>void * operator new (size_t);</code><br><code>void * operator new[] (size_t);</code><br><code>void operator delete (void *) noexcept;</code><br><code>void operator delete[] (void *) noexcept;</code></p>
<p>如果在代码中使用了这四个中的任意一个，则可以通过 clang 导出语法树查看到这四个函数的声明：</p>
<p><img src="2.png"></p>
<p>对于这四个函数及其重载，有如下需要注意的点：</p>
<ul>
<li>类似于析构函数，operator delete 函数也不允许抛出异常。所以在重载的时候，必须使用 noexcept 异常说明符指定其不抛出异常。</li>
<li>重载的 operator new 和 operator delete 函数必须位于<strong>全局作用域</strong>和<strong>类作用域</strong>中。</li>
<li>将上述函数定义为类的成员时，它们是<strong>隐式静态的</strong>，因为 operator new 在对象构造之前调用，而 operator delete 在对象析构之后调用。</li>
<li>对于 operator new 和 operator new[] 来说，其返回类型必须是 void * ，第一个参数必须是 size_t ，且该形参不能含有默认实参。也就说是它们还可以指定额外的形参，此时 new 操作符必须使用<strong>定位 new</strong> 形式，也就是 placement new 形式，这个我们在后续讲解。</li>
<li>对于 operator delete 和 operator delete[] 来说，其返回类型必须是 void，第一个形参类型必须是 void * 。</li>
</ul>
<hr>
<h1 id="placement-new-表达式"><a href="#placement-new-表达式" class="headerlink" title="placement new 表达式"></a>placement new 表达式</h1><p>如果应用程序直接调用 operator new 函数，则仅仅进行了内存分配，但是没有调用类的构造函数来初始化对象，那么我们可以显式的调用构造函数进行初始化，实际上在很多编译器上这是不被允许的，那我们应该怎么调用类的构造函数初始化对象呢？这时候，placement new 表达式就派上用场了！placement new 的用法如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A ctor!\n&quot;</span>; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A dtor!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *p = <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(A));	<span class="comment">// 调用全局的 operator new 申请空间</span></span><br><span class="line">	A *pA = <span class="built_in"><span class="keyword">new</span></span>(p) A;					<span class="comment">// placement new 操作符</span></span><br><span class="line">	<span class="keyword">delete</span> pA;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你一定很好奇，placement new 是怎么实现的，其实这也很简单。正如之前所述，operator new 函数是可以重载的，但是有一种形式是不能被用户重载的：<br><code>void * operator new(size_t, void *)</code></p>
<p>这是因为在标准库已经为我们实现了这个重载，其函数实现也非常简单，就是仅仅返回传入的指针，这样就相当于完成了 new 操作符的第一步。这里我们截图了其在标准库中的实现：</p>
<p><img src="3.png"></p>
<p>其实我们发现所谓的 placement new 也不过是 operator new 函数重载的一种形式，除了直接调用它，还可以通过定位 new 操作符的方式来间接调用它。由于在其实现中仅仅返回传入的指针，所以相当于对传入的指针调用所指定的类的构造函数。<strong>其实我们可以看出这个是十分危险的动作，因为我们可以传入任意的指针，然后在其指向的空间上通过类构造函数进行内存改写</strong>！</p>
<blockquote>
<p>既然有特殊的方式来简介的调用类的构造函数对内存进行初始化，那么有没有什么办法调用类的析构函数呢？其实类的析构函数可以直接调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A *p = <span class="keyword">new</span> A;</span><br><span class="line">p-&gt;~<span class="built_in">A</span>();	<span class="comment">// 直接调用 A 的析构函数</span></span><br></pre></td></tr></table></figure>

<p>但注意这样是不安全的，因为仅仅调用了 A 的析构函数，但是没有释放 p 指向的内存空间。</p>
</blockquote>
<hr>
<h1 id="示例：为类写一个内存池"><a href="#示例：为类写一个内存池" class="headerlink" title="示例：为类写一个内存池"></a>示例：为类写一个内存池</h1><p>讲了这么多 primitive 的用法和原理，那到底他们有什么用呢？我们通过为我们的类实现一个小的内存池来实现理解其作用，我们知道每一次向操作系统分配空间的时候，除了需要调用 malloc 函数带来的时间开销，最重要的还有一个称为 cookie 的额外空间开销。假如我们的类很小，又需要多次的申请空间的操作，这样每次申请空间都会有额外的 cookie 开销，多次的申请带来的额外空间开销占比可能是非常大的。那么我们可不可以一次性多申请空间呢，用的时候直接拿呢？这样是不是就可以避免多次申请带来的 cookie 开销呢？下面就是一个实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Screen</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y, <span class="keyword">int</span> _z) : <span class="built_in">rep</span>(&#123;_x, _y, _z&#125;) &#123; std::cout &lt;&lt; <span class="string">&quot;Screen&#x27;s Ctor!!!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Screen</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Screen&#x27;s Dtor!!!\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.width; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getheight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.height; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 内存池空闲块链表的头指针</span></span><br><span class="line">    <span class="keyword">static</span> Screen *freeStore;</span><br><span class="line">    <span class="comment">// 内存池的总大小，以类的大小为单位</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> screenChunk;</span><br><span class="line">    <span class="comment">// 当前已经从内存池中分配出去的空间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> isBusy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ScreenRep</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        <span class="keyword">int</span> width;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 采用 union 的方式来减少对象所占用的内存</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ScreenRep rep;</span><br><span class="line">        Screen *next;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Screen *Screen::freeStore = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Screen::screenChunk = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Screen::isBusy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *Screen::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 处理继承体系中的 size 不同情况</span></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in"><span class="keyword">sizeof</span></span>(Screen))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It is the derived obj!!!!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    Screen *p = freeStore;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 内存池中的空间都分配完了，此处不作扩展所以直接报一个 assert，但是实际设计中这是不对的</span></span><br><span class="line">        <span class="built_in">assert</span>(isBusy != screenChunk &amp;&amp; <span class="string">&quot;memory pool is full!&quot;</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Get class Screen memory pool, the size is &quot;</span> &lt;&lt; screenChunk &lt;&lt; std::endl</span><br><span class="line">                  &lt;&lt; std::endl;</span><br><span class="line">        Screen *newBlocks = <span class="keyword">static_cast</span>&lt;Screen *&gt;(::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(screenChunk *size));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将分配好的空间块链接起来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; screenChunk - <span class="number">1</span>; ++i)</span><br><span class="line">            newBlocks[i].next = &amp;newBlocks[i + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 将最后一块的 next 置为空，这样当内存池都分配完了后</span></span><br><span class="line">        newBlocks[screenChunk - <span class="number">1</span>].next = <span class="literal">nullptr</span>;</span><br><span class="line">        p = newBlocks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录第一空的闲置块</span></span><br><span class="line">        freeStore = &amp;newBlocks[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        freeStore = freeStore-&gt;next;</span><br><span class="line"></span><br><span class="line">    ++isBusy;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obtain a chunk from memory pool, the remaining size is &quot;</span> &lt;&lt; screenChunk - isBusy &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> Screen::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *deadObj, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deadObj == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/// 处理继承体系中的 size 不同情况</span></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in"><span class="keyword">sizeof</span></span>(Screen))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It is the derived obj!!!!\n&quot;</span>;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(deadObj)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Screen *readyToFree = <span class="keyword">static_cast</span>&lt;Screen *&gt;(deadObj);</span><br><span class="line">    readyToFree-&gt;next = freeStore;</span><br><span class="line">    freeStore = readyToFree;</span><br><span class="line">    --isBusy;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;give back a chunk to memory pool, the remaining size is &quot;</span> &lt;&lt; screenChunk - isBusy &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScreenDerived</span> :</span> <span class="keyword">public</span> Screen</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScreenDerived</span>() : <span class="built_in">Screen</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &#123; std::cout &lt;&lt; <span class="string">&quot;ScreenDerived&#x27;s Ctor!!!\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">ScreenDerived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;ScreenDerived&#x27;s Dtor!!!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Screen *p1 = <span class="keyword">new</span> <span class="built_in">Screen</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    Screen *p2 = <span class="keyword">new</span> <span class="built_in">Screen</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    Screen *p3 = <span class="keyword">new</span> ScreenDerived;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n*************************************\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line">    <span class="keyword">delete</span> p3;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************* output *********************************</span></span><br><span class="line"><span class="comment">Get class Screen memory pool, the size is 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">obtain a chunk from memory pool, the remaining size is 9</span></span><br><span class="line"><span class="comment">Screen&#x27;s Ctor!!!</span></span><br><span class="line"><span class="comment">obtain a chunk from memory pool, the remaining size is 8</span></span><br><span class="line"><span class="comment">Screen&#x27;s Ctor!!!</span></span><br><span class="line"><span class="comment">It is the derived obj!!!!</span></span><br><span class="line"><span class="comment">Screen&#x27;s Ctor!!!</span></span><br><span class="line"><span class="comment">ScreenDerived&#x27;s Ctor!!!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Screen&#x27;s Dtor!!!</span></span><br><span class="line"><span class="comment">give back a chunk to memory pool, the remaining size is 9</span></span><br><span class="line"><span class="comment">Screen&#x27;s Dtor!!!</span></span><br><span class="line"><span class="comment">give back a chunk to memory pool, the remaining size is 10</span></span><br><span class="line"><span class="comment">ScreenDerived&#x27;s Dtor!!!</span></span><br><span class="line"><span class="comment">Screen&#x27;s Dtor!!!</span></span><br><span class="line"><span class="comment">It is the derived obj!!!!</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br></pre></td></tr></table></figure>

<p>以上的代码则展示了一个不成型的内存池，但是我们也主要是为了揭示上述 primitive 的用法，可以看到在第一次申请 Screen 对象的空间时，在其 operator new 函数中，会一次性申请 10*sizeof(Screen) 个字节的空间，然后由这个类自己来管理这块内存。同时这两个函数的重载也会被继承到子类中，在类的继承体系中，其子类所占空间大小是有可能大于父类的，所以在父类中实现的内存池不能直接用于其不同大小的子类对象，所以我们需要在其中用<strong>对象的大小</strong>来过滤掉子类对 operator new 函数和 operator delete 函数的调用。所以也可以注意到在 operator new 中有了第二个参数，这个参数就是为了保存刚刚析构的对象的大小的，只有通过这种方式才能过滤掉子类对来自父类的 operator delete 函数的调用。</p>
<blockquote>
<p>提出一个思考问题，如果我们将上述代码中 Screen 的析构函数不声明为虚函数，会发生什么情况呢？</p>
<p>提示：p3 指针是一个指向 ScreenDerived 空间的 Screen 类型指针，如果 Screen 的析构函数不是虚函数，则在 delete p3 的时候，编译器直接会用静态联编的方式让 p3 去调用 Screen 的析构函数，而且将 Screen 类型的大小作为 operator delete 的第二个参数。如果 Screen 的析构函数是虚函数，则在 delete p3 的时候，编译器会采用动态联编的方式，等到运行的时候再判定让 p3 调用 ScreenDerived 的析构函数，而且将 ScreenDerived 类型的大小作为 operator delete 的第二个参数。</p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/blogCover/13.jpg" data-sites="twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/06/cpp-exception-impl/"><img class="prev-cover" src="/img/blogCover/14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ 中异常机制的实现机制详解（转载）</div></div></a></div><div class="next-post pull-right"><a href="/2021/10/23/tools-git-remote/"><img class="next-cover" src="/img/blogCover/11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GIT 远程仓库管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/10/21/cpp-array-func-pointer/" title="C++ 中数组指针和函数指针"><img class="cover" src="/img/blogCover/24.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-21</div><div class="title">C++ 中数组指针和函数指针</div></div></a></div><div><a href="/2021/10/21/cpp-class-type-cast/" title="C++ 类类型转换"><img class="cover" src="/img/blogCover/26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-21</div><div class="title">C++ 类类型转换</div></div></a></div><div><a href="/2021/10/21/cpp-compiler-generated-func/" title="C++ 编译器自动生成的函数详解"><img class="cover" src="/img/blogCover/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-21</div><div class="title">C++ 编译器自动生成的函数详解</div></div></a></div><div><a href="/2021/10/21/cpp-default-para/" title="C++ 函数重复声明对默认实参的影响"><img class="cover" src="/img/blogCover/23.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-21</div><div class="title">C++ 函数重复声明对默认实参的影响</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Nino</div><div class="author-info__description">Master, teaching makes you.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wenchuansun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wenchuansun" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://leetcode-cn.com/u/tempestate_" target="_blank" title="leetcode"><i class="fas fa-laptop"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#new-operator-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">new operator 的工作机理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#operator-new-%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">3.</span> <span class="toc-text">operator new 函数的重载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#placement-new-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">placement new 表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%B8%BA%E7%B1%BB%E5%86%99%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-number">5.</span> <span class="toc-text">示例：为类写一个内存池</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/llvm-debug-pipeline/" title="学会调试 LLVM opt 中的 PassManager 和 AnalysisManager"><img src="/img/blogCover/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学会调试 LLVM opt 中的 PassManager 和 AnalysisManager"/></a><div class="content"><a class="title" href="/2022/04/16/llvm-debug-pipeline/" title="学会调试 LLVM opt 中的 PassManager 和 AnalysisManager">学会调试 LLVM opt 中的 PassManager 和 AnalysisManager</a><time datetime="2022-04-16T06:19:45.000Z" title="发表于 2022-04-16 14:19:45">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/llvm-pass-plugin/" title="怎么基于 Pass New Manager 利用 PassPlugin 写 LLVM Pass（out-of-tree Pass Development）"><img src="/img/blogCover/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="怎么基于 Pass New Manager 利用 PassPlugin 写 LLVM Pass（out-of-tree Pass Development）"/></a><div class="content"><a class="title" href="/2022/04/16/llvm-pass-plugin/" title="怎么基于 Pass New Manager 利用 PassPlugin 写 LLVM Pass（out-of-tree Pass Development）">怎么基于 Pass New Manager 利用 PassPlugin 写 LLVM Pass（out-of-tree Pass Development）</a><time datetime="2022-04-16T06:18:11.000Z" title="发表于 2022-04-16 14:18:11">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/llvm-new-pass-manager/" title="怎样在 opt 中利用 new PassManager 中写 Pass"><img src="/img/blogCover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="怎样在 opt 中利用 new PassManager 中写 Pass"/></a><div class="content"><a class="title" href="/2022/04/16/llvm-new-pass-manager/" title="怎样在 opt 中利用 new PassManager 中写 Pass">怎样在 opt 中利用 new PassManager 中写 Pass</a><time datetime="2022-04-16T06:16:18.000Z" title="发表于 2022-04-16 14:16:18">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/underlyingPrinciple-cpp-class-memory-model-2/" title="深入理解对象内存模型（二）"><img src="/img/blogCover/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解对象内存模型（二）"/></a><div class="content"><a class="title" href="/2022/03/31/underlyingPrinciple-cpp-class-memory-model-2/" title="深入理解对象内存模型（二）">深入理解对象内存模型（二）</a><time datetime="2022-03-31T12:05:47.000Z" title="发表于 2022-03-31 20:05:47">2022-03-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Nino</div><div class="footer_custom_text">Hi, welcome to my pretty blog!</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><!--<img src="https://static.dy208.cn/o_1dfilp8ruo521thr1hvf18ji17soa.png">--><a href="http://www.beian.miit.gov.cn/" target="_blank"> | 湘ICP备2022001549号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script>(function(d, w, c) {
    w.ChatraID = 'yEBQMsndkiJxuHuQb';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>