<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>effective C++ 笔记 | Nino's blog</title><meta name="keywords" content="C++"><meta name="author" content="Nino"><meta name="copyright" content="Nino"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录 effective C++ 中一些有意思的 C++ 编码 trick 和 编码经验。">
<meta property="og:type" content="article">
<meta property="og:title" content="effective C++ 笔记">
<meta property="og:url" content="http://106.14.133.244/2022/03/31/cpp-19/index.html">
<meta property="og:site_name" content="Nino&#39;s blog">
<meta property="og:description" content="记录 effective C++ 中一些有意思的 C++ 编码 trick 和 编码经验。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://106.14.133.244/img/blogCover/20.jpg">
<meta property="article:published_time" content="2022-03-31T10:54:45.000Z">
<meta property="article:modified_time" content="2024-01-12T08:37:08.637Z">
<meta property="article:author" content="Nino">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://106.14.133.244/img/blogCover/20.jpg"><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="http://106.14.133.244/2022/03/31/cpp-19/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'effective C++ 笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-12 16:37:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="../../css/mycss.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Nino's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">effective C++ 笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-31T10:54:45.000Z" title="发表于 2022-03-31 18:54:45">2022-03-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-12T08:37:08.637Z" title="更新于 2024-01-12 16:37:08">2024-01-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="effective C++ 笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h3 id="条款-02：尽量以-const，enum，inline-替换-define"><a href="#条款-02：尽量以-const，enum，inline-替换-define" class="headerlink" title="条款 02：尽量以 const，enum，inline 替换 #define"></a>条款 02：尽量以 const，enum，inline 替换 #define</h3><p><strong>1、指向常量的指针，同时也要限定指针本身为常量</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> authorName = <span class="string">&quot;Scott Meyers&quot;</span>; <span class="comment">// 在指定指针常量的时候，同时限定指针本身和其指向的空间都为常量</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> std::string <span class="title">authorName1</span><span class="params">(<span class="string">&quot;Scott Meyers&quot;</span>)</span></span>; <span class="comment">// 用string来代替指针</span></span><br></pre></td></tr></table></figure>

<p><strong>2、类的 static const int 成员需要注意的点</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">float</span> NumScores = <span class="number">10.1</span>; 	<span class="comment">// 编译报错，只允许&quot;in-class&quot;的整数常量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>;  <span class="comment">// 常量声明式</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];           <span class="comment">// 编译器必须在编译的时候就知道NumTurns的大小，所以其必须是一个常量或者常量表达式 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;     <span class="comment">// 变量声明式，由于其在声明的时候已经给定了初值，所以定义的时候不可以再设初值（该定义式一般写在cpp文件中，因为其需要分配内存的，需要在整个程序中唯一）</span></span><br></pre></td></tr></table></figure>

<p>注意：一般来说这种在类里面给出了初值的 static const int 成员，只要不取其地址或者编译强制要求其定义式，是可以不提供定义式的，因为这个行为在编译前端就可以完全确定，可以进行变量的数值替换。而不取其内存的话，是不需要一个定义式为其分配内存的，这应该算是一种编译技术吧。</p>
<p><strong>3、the enum hack （一个枚举类型的数值可以权当 int 使用）的使用场景</strong></p>
<ul>
<li>对于一些旧式的编译器，它们不允许 static 成员在其声明式上获得初值.。</li>
<li>这种 in-class 初值设定也只允许对<strong>整数常量</strong>进行。</li>
</ul>
<p>那如果在类的声明里面需要一个常量值怎么办呢？这种常量值需要在编译期就确定，比如说栈里面数组的 size 值，因为这个会影响到编译器的代码生成，其在生成代码的时候就必须知道要分配多少栈帧，所以这个常量值必须在编译前端就能获取到。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer1</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> NumTurns = <span class="number">5</span> &#125;;	<span class="comment">// the enum hack --- 令NumTurns成为5的一个记号名称</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns]; 	<span class="comment">// 编译器必须在编译的时候就知道NumTurns的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="条款-03：尽可能使用-const"><a href="#条款-03：尽可能使用-const" class="headerlink" title="条款 03：尽可能使用 const"></a>条款 03：尽可能使用 const</h3><p><strong>1、STL 迭代器中的 const</strong></p>
<p>将迭代器本身声明为 const 就像声明指针为 const 一样（即声明一个 T* const 指针），表示这个<strong>迭代器不能指向其他东西</strong>；期望<strong>迭代器所指向的东西带有常量属性</strong>则使用 const_iterator。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();	<span class="comment">// iter是常量迭代器，只能指向vec的第一个元素	</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.<span class="built_in">cbegin</span>();	<span class="comment">// cIter是指向常量的迭代器，表示不能通过该迭代器修改其指向的元素</span></span><br></pre></td></tr></table></figure>

<p><strong>2、通过 const 避免一些不期望的与内置类型不兼容的操作</strong></p>
<p>在内置类型的运算中，表达式 <code>(a*b)=c</code> 是不能通过编译的语法检查的，那我们自定义的类型中也要保证这个语法特性，防止用户在使用到这种不期望的语法时编译器会给出错误提示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs, <span class="keyword">const</span> Rational &amp;rhs);</span><br><span class="line"><span class="comment">// 如果乘法运算符重载函数的返回值没有用const修饰的话，那么(a*b)=c 这样的语法使用就不会报出编译错误了。</span></span><br></pre></td></tr></table></figure>

<p><strong>3、bitwise constness 和 logical constness</strong></p>
<p><strong>原则：</strong><font color=red>我们要遵循 C++ 中 bitwise constness 的规则，但要写出 logical constness 的代码。</font></p>
<p>首先解释这两个概念的含义：</p>
<ul>
<li>bitwise constness：成员函数只有在不更改对象的任何成员变量时才可以说是 const，这也是 <strong>C++ 中对常量性</strong>的定义。假设你将一个成员函数声明为 const，那这个对象中的任何成员都不能通过这个成员函数改变，但是如果这些成员变量中有指针呢？即使将成员函数声明为了 const，但指针的指向的空间仍然是可以被这个声明为 const 的成员函数改变的！</li>
<li>logical constness：一个 const 成员函数可以修改他所处理的对象内的某些 bits，但只有在客户端侦测不出来的情况下改变。</li>
</ul>
<p>假设我们要设计一个文本块类，其中文本用一个 char * 的类型保存着，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CTextBlock</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name) &#123;</span><br><span class="line">        pText = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(pText, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> position) <span class="keyword">const</span> &#123; <span class="keyword">return</span> pText[position]; &#125;</span><br><span class="line">    <span class="comment">// const 的成员函数返回了指向non-const的指针</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *pText;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> CTextBlock <span class="title">mathBlock</span><span class="params">(<span class="string">&quot;Mathematics&quot;</span>)</span></span>;</span><br><span class="line">    mathBlock[<span class="number">1</span>]=<span class="string">&#x27;L&#x27;</span>;   <span class="comment">// 会将M修改为L，虽然我们的类满足了bitwise constness的规则，但是这显然不是我们希望发生的，因为mathBlock已经被声明成了const，我们不希望代表其名称的域被修改</span></span><br><span class="line">    <span class="comment">//所以解决方案是将运算符[]的const重载函数返回值类型修改为const char&amp;，这就是logical constness需要关注的事。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样还有一种 case，假如上述的 CTextBlock class 有可能高速缓存文本区块的长度以便应付查询：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CTextBlock</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name) &#123;</span><br><span class="line">        pText = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(pText, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> position) <span class="keyword">const</span> &#123; <span class="keyword">return</span> pText[position]; &#125;</span><br><span class="line">    <span class="comment">// 返回值类型加了const修饰，所以不能更改</span></span><br><span class="line">    <span class="function">std::<span class="keyword">size_t</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!lengthIsValid) &#123;</span><br><span class="line">            textLength = <span class="built_in">strlen</span>(pText);	<span class="comment">// const成员函数按道理是不能修改成员的，但由于成员被声明为mutable，所以使得这种操作成为了可能，这也是logical constness应该考虑的事！</span></span><br><span class="line">            lengthIsValid = <span class="literal">true</span>;		</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> textLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *pText;</span><br><span class="line">    <span class="keyword">mutable</span> std::<span class="keyword">size_t</span> textLength;	<span class="comment">// mutable使得变量总是可以被更改，即使在一个const对象内</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>4、消除 const 和 non-const 成员函数的代码冗余</strong></p>
<p>若一个类的 const 成员函数和其对应的 non-const 成员函数中的代码是大致相似的，我们可以通过让非 const 成员函数调用 const 成员函数来减少代码冗余。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> position) <span class="keyword">const</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ... </span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> position) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> &amp;&gt;(</span><br><span class="line">             <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock &amp;&gt;(*<span class="keyword">this</span>)</span><br><span class="line">             [position]);	</span><br><span class="line">        <span class="comment">// 先用static_cast转换将其转换成</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="条款-04：确定对象在使用前已经被初始化"><a href="#条款-04：确定对象在使用前已经被初始化" class="headerlink" title="条款 04：确定对象在使用前已经被初始化"></a>条款 04：确定对象在使用前已经被初始化</h3><p><strong>1、局部变量的初始化</strong></p>
<p>函数中的局部变量内存都是在栈里面被分配的，所以在使用前如果不初始化，则行为是未定义的，因为我们不知道栈里面由以前释放的栈帧中的值是什么。</p>
<p>对于类的构造函数，其初始化动作并不是发生在函数体，而是发生在<strong>成员初始化列表</strong>中，其初始化的顺序和成员变量在类中声明的顺序一致。</p>
<p><strong>2、不同编译单元内 non-local static 对象的初始化</strong></p>
<ul>
<li>static 对象：包括全局对象，定义于命名空间中的对象，在 class 内、函数内和文件作用域内被声明为 static 的对象。</li>
<li>local static 对象：函数内的 static 对象。</li>
<li>non-local static 对象：除了函数内的 static 对象之外的其他 static 对象。</li>
</ul>
<p><font color=red>编译单元间 non-local static 对象的初始化顺序是<strong>未定义的</strong>，这将导致一个问题：如果一个编译单元内的某个 non-local static 对象的初始化动作使用了另外一个编译单元内某个 non-local static 对象，则它所用到的这个对象可能未被初始化</font></p>
<p>那么应该怎么解决上述的问题呢？<strong>将 non-local static 对象转变成包装在函数中的 local static 对象！！</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_A.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line">    <span class="function">std::<span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">FileSystem &amp;<span class="title">tfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file_B.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="function">Directory &amp;<span class="title">Directory</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="keyword">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Diretory tempDir; 	<span class="comment">// 假设我们在 A 文件中把 fs 声明成全局变量，而 B 文件中 tempDir 也是全局变量，但是 tempDir 的构造函数需要用到 fs，那在创建 tempDir 这个全局变量的时候， fs 还不一定已经初始化过了，这将造成未定义的行为。但是将 fs 包装在函数中用 static 修饰，在 tempDir 调用默认构造函数的时候就一定可以保证先初始化 fs，因为其需要调用函数 tfs。</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="条款-05：了解-C-默认编写并调用了哪些函数"><a href="#条款-05：了解-C-默认编写并调用了哪些函数" class="headerlink" title="条款 05：了解 C++ 默认编写并调用了哪些函数"></a>条款 05：了解 C++ 默认编写并调用了哪些函数</h3><p>编译器可以暗自为 class 创建<strong>默认构造函数</strong>、<strong>拷贝构造函数</strong>、<strong>拷贝赋值操作符</strong>、<strong>移动赋值操作符</strong>、<strong>移动构造函数</strong>和<strong>析构函数</strong>。但是 C++ 一定会为每一个类生成这些函数吗？不！仅仅在<strong>需要用到且确实可以用到</strong>的时候才会生成。</p>
<ul>
<li>如果用户自定义了构造函数，则不会再生成默认构造函数。</li>
<li>如果你打算在一个 “内含 reference 成员” 的 class 内支持赋值操作，则必须自定义赋值操作符，因为默认版本就是对每个对象进行赋值，这违反了 reference 不能重新赋值的约定。</li>
<li>对于“内含 const 成员”的 class，编译器的反应也一样，与上一条同理。</li>
<li>如果某个 base class 将以上赋值操作符声明为 private，编译器也会拒绝为其 derived class 自动生成赋值操作符，因为其 derived class 无权调用 base class 的赋值操作符。</li>
</ul>
<hr>
<h3 id="条款-06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款-06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款 06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款 06：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>如果希望我们创建的对象是独一无二，不可复制的，只需要将拷贝构造函数和拷贝赋值操作符声明为 private 即可。这种方式存在一个缺点，因为类中的成员函数还可以调用被声明为 private 的拷贝构造函数和拷贝赋值操作符，所以在编译的时候并不会报错，而是<strong>在链接的时候报无法找到定义的链接错误</strong>，因为确实，我们仅仅声明了它们，而没有实现它们的定义。</p>
<p>为了将链接期的错误转移到编译期，也可使用如下的代码作为基类来传递不可赋值性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>() &#123; &#125;</span><br><span class="line">    ~<span class="built_in">Uncopyable</span>() &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="keyword">const</span> Uncopyable&amp;);				<span class="comment">// 阻止拷贝</span></span><br><span class="line">    Uncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span> :</span> <span class="keyword">private</span> Uncopyable &#123;</span><br><span class="line">    <span class="comment">// 由于继承了基类的不可拷贝性，所以其不再可以发生拷贝和赋值操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[注]：在 C++11 中，完全可以用 delete 关键字取代上述的操作！</p>
</blockquote>
<hr>
<h3 id="条款-07：为多态基类声明-virtual-析构函数"><a href="#条款-07：为多态基类声明-virtual-析构函数" class="headerlink" title="条款 07：为多态基类声明 virtual 析构函数"></a>条款 07：为多态基类声明 virtual 析构函数</h3><p><strong>1、virtual 关键字对析构函数的影响</strong></p>
<ul>
<li><p>如果析构函数没有被声明为了 virtual 函数，则其派生的类有可能发生内存泄漏。</p>
</li>
<li><p>那所有的类的析构函数都需要声明为析构函数吗？不是，一种经验的做法是，<strong>只有当 class 内含有至少一个 virtual 函数，才为它声明 virtual 析构函数</strong> 。如果 class 的目的不是为了作为 base class 使用，或者不是为了具备多态性，也不该声明 virtual 函数。</p>
</li>
<li><p>在我们设计类的时候，如果我们的类没有任何的虚函数，例如 STL，这表明我们可能不希望我们的类被任何类继承（因为被继承后在 delete 的时候有可能不小心造成内存泄漏），应该把类用 <strong>final</strong> 关键字修饰。</p>
</li>
</ul>
<p><strong>2、纯虚函数也可以定义！</strong></p>
<p>假设我们需要一个 abstract class，但是又没有合适的虚函数可以用，那我们可以将其析构函数声明为纯虚函数，以此让该类达到抽象类的功能。但是，这也使得我们必须给出析构函数的定义，因为其 derived class 会简介的调用基类的析构函数，如果没有定义，则链接器会报链接错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AWOV</span>() = <span class="number">0</span>;	<span class="comment">// 声明 pure virtual 析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AWOV::~<span class="built_in">AWOV</span>() &#123; &#125;			<span class="comment">// 纯虚析构函数的定义，如果缺少的话，在析构其继承类的对象时会有链接错误</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="条款-08：别让异常逃离析构函数"><a href="#条款-08：别让异常逃离析构函数" class="headerlink" title="条款 08：别让异常逃离析构函数"></a>条款 08：别让异常逃离析构函数</h3><p>如果异常可以逃离析构函数，可能会导致不明确行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;					<span class="comment">// 该函数可能会抛出异常    </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span></span><br><span class="line">	~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">  		db.<span class="built_in">close</span>();					<span class="comment">// 调用了可能发生异常的函数，该析构函数可能抛出异常      </span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案一：在析构函数中抓住异常，并且终止程序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span></span><br><span class="line">	~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">            <span class="comment">// 可以在终止程序前记录下失败的信息反馈给用户</span></span><br><span class="line">            std::<span class="built_in">abort</span>();</span><br><span class="line">        &#125;			   </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案二：吞掉异常，但可能导致程序后续执行出现问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span></span><br><span class="line">	~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">            <span class="comment">// 记录下失败的信息反馈给用户</span></span><br><span class="line">        &#125;				   </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案三：提供可能抛出异常的函数的接口给用户，让用户可以选择性的自己处理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;				<span class="comment">// 提供给用户的接口</span></span><br><span class="line">        db.<span class="built_in">close</span>();				</span><br><span class="line">        closed = <span class="literal">true</span>;			<span class="comment">// 关闭成功，在析构中不再执行该函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed) &#123;			<span class="comment">// 如果用户没有使用关闭接口，则析构函数再调用</span></span><br><span class="line">            <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">        	<span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">            	<span class="comment">// 记录下失败的信息反馈给用户</span></span><br><span class="line">        	&#125;	</span><br><span class="line">        &#125;			   </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="keyword">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="条款-09：绝不在构造和析构的过程中调用-virtual-函数"><a href="#条款-09：绝不在构造和析构的过程中调用-virtual-函数" class="headerlink" title="条款 09：绝不在构造和析构的过程中调用 virtual 函数"></a>条款 09：绝不在构造和析构的过程中调用 virtual 函数</h3><ul>
<li>在构造函数中，virtual 绝不会下降到 derived class 阶层，因为 base class 的构造动作发生在 derived class 之前，此时还没有完全生成 derived class。<strong>如果可以分析汇编代码的话，可以发现 base class 的构造函数会将该类的第一个内存区域（也就是虚表指针的值）初始化成当前 base class 的虚表地址，所以在其构造函数中调用的函数永远是 base class 中所实现的虚函数。</strong></li>
<li>对于析构函数，一旦 derived class 析构函数开始执行，则对象中的 derived class 成员变量变为未知值，所以在执行其 base class 的析构函数内，不可能调用到 derived  class 中重写的虚函数。<strong>分析汇编代码其实可以看出，在 base class 析构函数的开始处，会先把当前对象的虚表指针的值修改为指向 base class 的虚表，所以在 base class 析构函数中无论怎么样，都只能调用其本身的虚函数。</strong></li>
</ul>
<hr>
<h3 id="条款-10：令-operator-返回一个-reference-to-this"><a href="#条款-10：令-operator-返回一个-reference-to-this" class="headerlink" title="条款 10：令 operator= 返回一个 reference to *this"></a>条款 10：令 operator= 返回一个 reference to *this</h3><p>对于内置类型，经常会有如此连锁形式的赋值：<code>x = y = z;</code></p>
<p>为了实现“连锁赋值”，赋值操作符必须返回一个 reference 指向操作符的左侧实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp; rhs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="条款-11：在-operator-中处理自赋值"><a href="#条款-11：在-operator-中处理自赋值" class="headerlink" title="条款 11：在 operator= 中处理自赋值"></a>条款 11：在 operator= 中处理自赋值</h3><p>一种不安全的 operator= 的实现方式，可能造成 use after free！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap *bp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget &amp;Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  <span class="comment">// 一份看似合理的赋值运算符的实现</span></span><br><span class="line">    <span class="keyword">delete</span> bp;                                  <span class="comment">// 如果是自己给自己赋值呢？类似 wi = wi ？     </span></span><br><span class="line">    bp = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.bp);                   <span class="comment">// 显然会发生 UAF !</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、自我赋值安全的实现方式</strong></p>
<p>以下方式虽然可以实现自我赋值的安全，但无法实现异常安全。如果在 new 操作符中发生异常（可能分配内存失败，也可能 Bitmap 的 copy 构造函数抛出异常），widget 会持有一个指针指向一块被删除的 Bitmap，这样的指针是有害的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap *bp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget &amp;Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;             <span class="comment">// 如果是自我赋值，就不做任何事</span></span><br><span class="line">    <span class="keyword">delete</span> bp;                                         </span><br><span class="line">    bp = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.bp);                   </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、异常安全的实现方式</strong></p>
<p>以下方式不仅仅可以实现异常安全，也可以实现自我赋值安全。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap *bp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget &amp;Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  </span><br><span class="line">    Bitmap *pOrig = bp;</span><br><span class="line">    bp = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.bp);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;                       <span class="comment">// 将删除操作延迟到new操作符之后</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、copy and swap 技术</strong>（天然就是自我赋值安全和异常安全的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget &amp; rhs)</span></span>;			<span class="comment">// swap函数，交换*this和rhs的数据</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap *bp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget &amp;Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  </span><br><span class="line">	Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="条款-12：复制对象时勿忘其每一个成分"><a href="#条款-12：复制对象时勿忘其每一个成分" class="headerlink" title="条款 12：复制对象时勿忘其每一个成分"></a>条款 12：复制对象时勿忘其每一个成分</h3><p>Copying 函数应该确保复制“对象内的所有成员变量”及“所有 base class 成分”。这听起来容易，但在工程中常犯的一种错误就是，用户完美的自定义了拷贝构造函数和拷贝赋值运算符，但在日后的开发维护中，<strong>可能在类中添加新的成员变量，但是却忘记同时更新拷贝构造函数和拷贝赋值运算符了，导致在发生拷贝的时候仅仅进行了局部拷贝（也就是新加入的成员变量没有被拷贝过去）</strong>。而任何时候只要你承担起“为 derived class 撰写 copying 函数”的重责大任，必须很小心地也复制其 base class 成分。那些成分往往是 private，所以你无法直接访问它们，你应该让 derived class 的 copying 函数调用相应的 base class 函数。</p>
<hr>
<h3 id="条款-13：以对象管理资源"><a href="#条款-13：以对象管理资源" class="headerlink" title="条款 13：以对象管理资源"></a>条款 13：以对象管理资源</h3><p>这一条款最主要的阐述为什么要用对象来管理资源，也是 RAII 的概念，也就是 C++11 中为什么会出现智能指针的原因。</p>
<p>这一条款指出了<strong>智能指针并不能管理动态分配的数组，因为其内部采用的是 delete 而不是 delete [] 动作</strong>。而在 C++11 的智能指针中，其实也是有相应的办法解决这个问题的，就是可以自定义一个删除器，将其传入到智能指针中。</p>
<hr>
<h3 id="条款-14：在资源管理类中小心-coping-行为"><a href="#条款-14：在资源管理类中小心-coping-行为" class="headerlink" title="条款 14：在资源管理类中小心 coping 行为"></a>条款 14：在资源管理类中小心 coping 行为</h3><p>对于智能指针来说，RAII 思想主要还是体现在堆分配的内存空间上，然而有些资源其并不是内存资源，所以可能需要<strong>用户来建立</strong>资源管理类。</p>
<p>比如说，假设我们在线程安全设计中有两个处理类型为 Mutex 的互斥器对象，共有两个函数 lock 和 unlock 可以用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(Mutex *pm)</span></span>; 	<span class="comment">// 上锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(Mutex *pm)</span></span>;	<span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<p>为了确保不会忘记将一个锁住的 Mutex 解锁，可能会希望建立一个 class 来管理锁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span> : mutexPtr(pm) &#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutexPtr);	<span class="comment">// 获得资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Lock</span>() &#123; <span class="built_in">unlock</span>(mutexPtr);&#125;	<span class="comment">// 释放资源</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户代码</span></span><br><span class="line">Mutex m;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述是 Lock 对象正确的使用，但是如果 Lock 对象被复制，会发生什么？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Lock <span class="title">ml1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line"><span class="function">Lock <span class="title">ml2</span><span class="params">(ml1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这显然会有问题，在 ml1 析构的时候已经调用了 unlock 函数解锁，则 ml2 析构的时候会导致 unlock 函数对同一个 Mutex 进行解锁，这显然会导致问题（类似于 Double Free）。</p>
<p>如何解决这个问题：</p>
<ul>
<li>禁止复制。</li>
<li>对底层资源祭出 “引用计数法”。<br>对于上述的 Lock 类，我们可以改写如下：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span> : mutexPtr(pm, unlock) &#123;</span>	<span class="comment">// 以某个 Mutex 初始化 shared_ptr, 并且用 unlock 作为删除器</span></span><br><span class="line">          <span class="built_in">lock</span>(mutexPtr.<span class="built_in">get</span>());</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      std::shared_ptr&lt;Mutex&gt; mutexPtr;</span><br><span class="line">  &#125;；</span><br></pre></td></tr></table></figure></li>
<li>复制底层资源（深度拷贝）。</li>
<li>转移底部资源的所有权。</li>
</ul>
<hr>
<h3 id="条款-15：在资源管理类中提供对原始资源的访问"><a href="#条款-15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15：在资源管理类中提供对原始资源的访问"></a>条款 15：在资源管理类中提供对原始资源的访问</h3><p>APIs 往往要求访问原始资源，所以每一个 RAII class 应该提供一个 “取得其所管理之资源” 的办法。</p>
<p>对原始资源的访问可以通过显示转换或隐式转换来完成。一般而言显式转换比较安全，但隐式转换对客户比较方便。</p>
<hr>
<h3 id="条款-16：成对使用-new-和-delete-时要采用相同形式"><a href="#条款-16：成对使用-new-和-delete-时要采用相同形式" class="headerlink" title="条款 16：成对使用 new 和 delete 时要采用相同形式"></a>条款 16：成对使用 new 和 delete 时要采用相同形式</h3><p>如果你在 new 表达式中使用 []，必须在相应的 delete 表达式中也使用 []。如果你在 new 表达式中不使用 []，一定不要在相应的 delete 表达式中使用 []。</p>
<hr>
<h3 id="条款-17：-以独立语句将-newed-对象置入智能指针"><a href="#条款-17：-以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款 17： 以独立语句将 newed 对象置入智能指针"></a>条款 17： 以独立语句将 newed 对象置入智能指针</h3><p>假设有如下两个函数接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; pw, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用户代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(<span class="keyword">new</span> Widget， <span class="built_in">priority</span>());	<span class="comment">// 编译出错，因为 shared_ptr 是 explicit 的</span></span><br><span class="line"><span class="built_in">processWidget</span>(std::shared_ptr&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());	<span class="comment">// 编译通过，但是仍然有问题</span></span><br></pre></td></tr></table></figure>

<p>对于上述的第二种用法，仍然可能存在<strong>资源泄露</strong>！！！</p>
<p>在编译器生成代码的时候，首先要生成对实参处理的生成代码，所以在调用 processWidget 函数之前，编译器应该先做三件事：</p>
<ul>
<li>调用 priority 函数；</li>
<li>执行 “new Widget”；</li>
<li>调用 std::shared_ptr 构造函数。</li>
</ul>
<p>但是 C++ 的编译器会按照什么样的次序完成这些事情呢？可能如下：</p>
<ol>
<li>执行 “new Widget”；</li>
<li>调用 priority 函数；</li>
<li>调用 std::shared_ptr 构造函数。</li>
</ol>
<p>这就有问题了，因为 priority 可能抛出异常，这样则会导致资源泄露。</p>
<p><strong>正确的处理方式：以独立语句将 newed 对象置入智能指针</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="条款-18：让接口容易被正确使用，不易被误用"><a href="#条款-18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款 18：让接口容易被正确使用，不易被误用"></a>条款 18：让接口容易被正确使用，不易被误用</h3><p><strong>如何阻止误用</strong>：建立新的类型，限制类型上的操作，束缚对象值，消除客户的资源管理责任。</p>
<p><code>cross-DLL problem</code>：对象在动态链接程序库（DLL）中被创建，却在另一个 DLL 内被 delete 销毁。<strong>解决方案</strong>：采用智能指针替换，因为智能指针的缺省的删除器是来自其所诞生的那个 DLL。</p>
<hr>
<h3 id="条款-19：设计-class-犹如设计-type"><a href="#条款-19：设计-class-犹如设计-type" class="headerlink" title="条款 19：设计 class 犹如设计 type"></a>条款 19：设计 class 犹如设计 type</h3><p>通常要考虑如下问题：</p>
<ul>
<li>新 type 的对象应该如何被创建和销毁</li>
<li>对象的初始化和对象的赋值该有什么样的差别？</li>
<li>新 type 的对象如果被 <em>passed by value</em> ，意味着什么？</li>
<li>什么是新 type 的合法值？</li>
<li>你的新 type 需要配合某个继承图系吗？</li>
<li>你的新 type 需要什么样的转换？</li>
<li>什么样的操作符和函数对此新 type 而言是合理的？</li>
<li>什么样的标准函数应该驳回？</li>
<li>谁该取用新 type 的成员？</li>
<li>什么是新 type 的 “未声明接口”？</li>
<li>你的新 type 有多么的一般化？</li>
<li>你真的需要一个新 type 吗？</li>
</ul>
<hr>
<h3 id="条款-20：宁以-pass-by-reference-to-const-替换-pass-by-value"><a href="#条款-20：宁以-pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="条款 20：宁以 pass-by-reference-to-const 替换 pass-by-value"></a>条款 20：宁以 pass-by-reference-to-const 替换 pass-by-value</h3><ul>
<li>尽量以 pass-by-reference-to-const 替换 pass-by-value。前者通常比较高效，并可避免对象切割问题。</li>
<li>以上规则不适用于内置类型，以及 STL 的迭代器和函数对象。</li>
</ul>
<hr>
<h3 id="条款-21：必须返回对象时，别妄想返回其-reference"><a href="#条款-21：必须返回对象时，别妄想返回其-reference" class="headerlink" title="条款 21：必须返回对象时，别妄想返回其 reference"></a>条款 21：必须返回对象时，别妄想返回其 reference</h3><p>绝不要返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象且有可能同时需要多个这样的对象。</p>
<hr>
<h3 id="条款-22：将成员变量声明为-private"><a href="#条款-22：将成员变量声明为-private" class="headerlink" title="条款 22：将成员变量声明为 private"></a>条款 22：将成员变量声明为 private</h3><p>这可以赋予客户访问数据的一致性、可细微划分访问控制、允许约束条件获得保证、实现封装性等。</p>
<hr>
<h3 id="条款-23：宁以-non-member、non-friend-替换-member-函数"><a href="#条款-23：宁以-non-member、non-friend-替换-member-函数" class="headerlink" title="条款 23：宁以 non-member、non-friend 替换 member 函数"></a>条款 23：宁以 non-member、non-friend 替换 member 函数</h3><p>这种做法可以增加封装性（因为非成员函数没法访问 class 的私有成员）、包裹弹性、机能扩充性（用户没法直接修改类，但可以使用类的接口）。</p>
<hr>
<h3 id="条款-24：若所有参数皆需类型转换，请为此采用-non-member-函数"><a href="#条款-24：若所有参数皆需类型转换，请为此采用-non-member-函数" class="headerlink" title="条款 24：若所有参数皆需类型转换，请为此采用 non-member 函数"></a>条款 24：若所有参数皆需类型转换，请为此采用 non-member 函数</h3><p>以前在读 C++ Primer 的时候就遇到过类似二元重载运算符，如 operator* 或 operator+ 等都建议写成 non-member 函数，今天终于找到了理由。</p>
<p>因为当仅仅当参数被列于参数列的时候，这个参数才可以发生隐式转换；如果参数的地位相当于被调用的成员函数所隶属的那个对象 — 也就是 this 对象那个隐含参数，就不能发生隐式转换。所以为了支持带隐式转换的二元运算符（交换律），必须采用 non-member 的方式。</p>
<hr>
<h3 id="条款-25：考虑写出一个不抛异常的-swap-函数"><a href="#条款-25：考虑写出一个不抛异常的-swap-函数" class="headerlink" title="条款 25：考虑写出一个不抛异常的 swap 函数"></a>条款 25：考虑写出一个不抛异常的 swap 函数</h3><p>标准库中的 swap 算法实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认版本的 swap 的函数在面对某些 class 实现的时候，会表现得效率低下，常见于 <strong>pimpl</strong>（pointer to implementation） 手法的设计中。例如，以这种手法设计 Widget class：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span>			<span class="comment">// 针对 Widget 数据而设计的 class，可能有许多数据</span></span><br><span class="line"><span class="keyword">public</span>:						<span class="comment">// 意味着复制时间很长</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a, b, c;		</span><br><span class="line">    std::vector&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;	<span class="comment">//复制 Widget 时，令它复制其 WidgetImpl 对象</span></span><br><span class="line">        ...									<span class="comment">//涉及到深拷贝，意味着复制消耗很大</span></span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上，如果要置换两个 Widget 对象值，我们唯一需要的就是置换其 pImpl 指针，如果调用默认的 swap，则会导致调用到 operator= ，开销很大！！！</p>
<p><strong>我们需要做的是，当用户调用 std::swap 来置换两个 Widget 的对象时，真正该做的是置换其内部的指针。</strong>正确实现方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、令 Widget 声明一个名为 swap 的 public 成员函数做真正的置换工作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget &amp;other)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">using</span> std::swap;</span><br><span class="line">		<span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	WidgetImpl *pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、全特化 std::swap 函数模板</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt;( Widget&amp; a, Widget&amp; b ) &#123;</span><br><span class="line">    	a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 Widget 和 WidgetImpl 是 class template 咋办呢？关键在于自定义模板 swap 函数模板！！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line"><span class="comment">// 1、同样令 Widget 声明一个名为 swap 的 public 成员函数做真正的置换工作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt; &amp;other)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">using</span> std::swap;</span><br><span class="line">		<span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	WidgetImpl&lt;T&gt; *pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、定义 WidgetStuff::swap 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">	a.<span class="built_in">swap</span>(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么对于 class 一般采用全特化的 std::swap，而 class template 却采用自定义的 namespace_name::swap 呢？</strong></p>
<p>因为 class template 只能采用自定义的方式，毕竟偏特化 std::swap 是超出标准之外的而重载 std::swap 也是不推荐的方式嘛！对于 class 来说，全特化 std::swap 可以使其用于更多的语境（比如某位程序员在写调用 swap 的时候写了 std::swap(a, b) ，这会使得编译器自动去找 std 中的 swap，如果没有采用全特化的方式而是重载的方式，就不会解析到 class 作者定义的 swap 函数了）！！！</p>
<p><strong>对 std 命名空间的修改原则</strong>：</p>
<ul>
<li>可以为标准 template 制造特化版本，使其专属于我们自己的 classes。</li>
<li>只允许对 class template 偏特化，但不允许对 function template 偏特化（如有需要，增加一个重载版本，但是此方案并不建议）。</li>
</ul>
<blockquote>
<p><strong>定义并高效使用 swap 的规则：</strong></p>
<p>1、提供一个 public swap 成员函数，让它高效地置换你的类型的两个对象值，这个函数不应该抛出异常。</p>
<p>2、在你的 class 或 template 所在命名空间内提供一个 non-member swap，并令它调用上述 swap 成员函数。</p>
<p>3、如果你正在编写一个 class（而非 class template），为你的 class 特化 std::swap，并令它调用你的 swap 成员函数。</p>
<p>最后如果你调用 swap，请确定包含一个 using 声明式，以便让那 std::swap 在你的函数内曝光可见，然后不加任何 namespace 修饰符，赤裸裸地调用 swap。</p>
</blockquote>
<hr>
<h3 id="条款-26：尽可能延后变量定义式的出现时间"><a href="#条款-26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款 26：尽可能延后变量定义式的出现时间"></a>条款 26：尽可能延后变量定义式的出现时间</h3><p>这样做不仅仅可以增加程序的清晰度，更重要的是减少无效的构造和析构开销。</p>
<p>循环应该怎么做？</p>
<ul>
<li>方法 A：定义于循环外，<strong>1 次构造 +  1 次析构 + n 次赋值操作</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = 取决于 i 的某个值;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法 B：定义于循环内，<strong>n 次构造 + n 次析构。</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">( 取决于i 的某个值)</span></span>;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>除非你知道赋值成本比 “构造+析构” 低，同时正在处理代码中高效敏感的部分，否则应该使用方法 B。</p>
<hr>
<h3 id="条款-27：尽量少做转型动作"><a href="#条款-27：尽量少做转型动作" class="headerlink" title="条款 27：尽量少做转型动作"></a>条款 27：尽量少做转型动作</h3><p>dynamic_cast 会增大运行时的开销。</p>
<hr>
<h3 id="条款-28：避免返回-handle-指向对象内部成分"><a href="#条款-28：避免返回-handle-指向对象内部成分" class="headerlink" title="条款 28：避免返回 handle 指向对象内部成分"></a>条款 28：避免返回 handle 指向对象内部成分</h3><p>增加封装性。所谓 handle 就是指引用、指针或者迭代器。</p>
<hr>
<h3 id="条款-29：-为“异常安全”而努力是值得的"><a href="#条款-29：-为“异常安全”而努力是值得的" class="headerlink" title="条款 29： 为“异常安全”而努力是值得的"></a>条款 29： 为“异常安全”而努力是值得的</h3><p>一段异常不安全的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeBackground</span><span class="params">(std::istream &amp;imgSrc)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    Image *bgImage;</span><br><span class="line">    <span class="keyword">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream &amp;imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;mutex);					<span class="comment">// 可能不会被 unlock</span></span><br><span class="line">    <span class="keyword">delete</span> imageChanges;			<span class="comment">// 在 delete 后无法恢复</span></span><br><span class="line">    ++imageChanges;					<span class="comment">// 命名创建失败，却仍然加一了</span></span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);	<span class="comment">// 可能分配内存时候报异常</span></span><br><span class="line">    <span class="built_in">unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当异常被抛出的时候，带有异常安全性的函数会：</p>
<ul>
<li><strong>不泄露任何资源</strong>。上述代码可能造成 unlock 的调用不会执行，泄露了资源。</li>
<li><strong>不允许数据被损坏</strong>。delete 已经将原有的数据损坏且无法复原。</li>
</ul>
<p><strong>采用 RAII 的方式解决问题！！！</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeBackground</span><span class="params">(std::istream &amp;imgSrc)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    std::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="keyword">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream &amp;imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">lk1</span><span class="params">(&amp;mutex)</span></span>;					<span class="comment">// Lock 的析构函数自动被调用，释放锁资源</span></span><br><span class="line">    bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));	</span><br><span class="line">    ++imageChanges;						<span class="comment">// 创建成功才加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的方式已经实现了异常安全的强烈保证！但是有一种更通用的技术来实现强烈保证 —— <strong>copy-and-swap</strong>。其基本思想是：<em>为你打算修改的对象（原件）做出一份副本，然后在那个副本身上做一切必要修改。若有任何修改动作抛出异常，原对象仍保持在未改变状态。待所有的改变都成功后，再将修改后的那个副本和原对象在一个不抛出异常的操作中置换（swap）</em>。</p>
<hr>
<h3 id="条款-30：透彻了解-inlining-的里里外外"><a href="#条款-30：透彻了解-inlining-的里里外外" class="headerlink" title="条款 30：透彻了解 inlining 的里里外外"></a>条款 30：透彻了解 inlining 的里里外外</h3><blockquote>
<p>为什么 inline 是一把双刃剑？</p>
<p>在一天内存有限的机器上，过度热衷 inlining 会造成程序体积太大（对可用空间而言）。即使拥有虚内存，inline 造成的代码膨胀亦会导致额外的换页行为，降低指令高速缓存装置的命中率，以及伴随这些而来的效率损失；</p>
<p>换个角度说，如果 inline 函数的本体很小，编译器针对“函数本体”所产出的代码可能比针对“函数调用”所产出的代码更小。果真如此，将函数 inlining 确实可能会导致较小的目标代码和较高的高速缓存装置的命中率！</p>
</blockquote>
<p>Inline 函数通常一定被置于头文件内，因为大多数构建环境在编译的过程中进行 inlining，而为了将一个 “函数调用” 替换为 “被调用函数的本体”，必须知道那个函数长什么样子。</p>
<hr>
<h3 id="条款-31：将文件间的编译依存关系降至最低"><a href="#条款-31：将文件间的编译依存关系降至最低" class="headerlink" title="条款 31：将文件间的编译依存关系降至最低"></a>条款 31：将文件间的编译依存关系降至最低</h3><p>支持 “编译依存性最小化” 的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两种手段是 Handle classes（即 pImpl 技法）和 Interface classes（即虚基类）。</p>
<hr>
<h3 id="条款-32：确定你的-public-继承塑模出-is-a-关系"><a href="#条款-32：确定你的-public-继承塑模出-is-a-关系" class="headerlink" title="条款 32：确定你的 public 继承塑模出 is-a 关系"></a>条款 32：确定你的 public 继承塑模出 is-a 关系</h3><p>“public” 继承意味着 <strong>is-a</strong>，适用于 base class 身上的每一件事情一定也适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象。</p>
<hr>
<h3 id="条款-33：避免遮掩继承而来的名称"><a href="#条款-33：避免遮掩继承而来的名称" class="headerlink" title="条款 33：避免遮掩继承而来的名称"></a>条款 33：避免遮掩继承而来的名称</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d; <span class="keyword">int</span> x;</span><br><span class="line">d.<span class="built_in">mf1</span>();	<span class="comment">// 没问题，调用 Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);	<span class="comment">// 错误！因为 Derived::mf1 遮掩了 Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>();	<span class="comment">// 没问题，调用 Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();	<span class="comment">// 没问题，调用 Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);	<span class="comment">// 错误！因为 Derived::mf3 遮掩了 Base::mf3</span></span><br></pre></td></tr></table></figure>

<p>即使函数参数不同，子类内的名称也会遮掩父类内的名称。</p>
<hr>
<h3 id="条款-34：区分接口继承和实现继承"><a href="#条款-34：区分接口继承和实现继承" class="headerlink" title="条款 34：区分接口继承和实现继承"></a>条款 34：区分接口继承和实现继承</h3><p><strong>纯虚函数也可以拥有实现</strong>，这点可以用来将接口和实现分离。可以用父类中纯虚函数的实现来表达子类所公有部分的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirPlane</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> AirPort&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AirPlane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缺省行为</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 现在的 fly 被分割为两部分：其声明部分是接口，其定义部分是实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">        AirPlane::<span class="built_in">fly</span>(destination);		<span class="comment">// 公用部分</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">        AirPlane::<span class="built_in">fly</span>(destination);		<span class="comment">// 公有部分</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="条款-35：考虑-virtual-函数以外的其他选择"><a href="#条款-35：考虑-virtual-函数以外的其他选择" class="headerlink" title="条款 35：考虑 virtual 函数以外的其他选择"></a>条款 35：考虑 virtual 函数以外的其他选择</h3><ol>
<li>籍由 Non-Virtual Interface 手法实现 Template Method 模式</li>
</ol>
<p><strong>模板方法模式</strong>：定义一个操作的算法框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>NVI(Non-Virtual Interface) 技法：令客户可以通过 public non-virtual 成员函数简介调用 private virtual 函数，将这个 non-virtual 函数称为 virtual 函数的 wrapper。</p>
<p>【注意】在 NVI 手法下其实没有必要让 virtual 函数一定得是 private，某些 class 继承体系要求 derived class 在 virtual 函数的实现内必须调用其 base class 的对应兄弟，而为了让这样的调用合法，virtual 函数必须是 protected 的。</p>
<blockquote>
<p>例子：在 KLEE 的 Search 继承体系下，Search 作为基类实现了基本的 search 算法框架，即 NotifyListenersSearchStarted，然后在循环内 selectNextState，executeInst，updateNextState，isFinished，出循环后再 NotifyListenersSearchFinished。对于其继承类，必须实现具体的 selectNextState，updateNextState，isFinished 三个虚函数对不同的搜索策略实现具体的算法步骤。</p>
</blockquote>
<ol start="2">
<li>籍由 Function Pointer 实现 Strategy 模式</li>
</ol>
<p><strong>策略模式</strong>：定义一系列的算法，把每一个算法封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 传统的策略模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>；</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCalcFunc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter &amp;gc)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">       	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf = &amp;defaultHealthCalc)</span> </span></span><br><span class="line"><span class="function">        : pHealthCalc(phcf) &#123;</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHealthCalc-&gt;<span class="built_in">calc</span>(*<span class="keyword">this</span>);	<span class="comment">// 通过给 pHealthCalc 不同的健康计算算法对象得到不同的健康值计算方式</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HealthCalcFunc *pHealthCalc;	<span class="comment">// 对象指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用<strong>函数指针</strong>来代替算法类（会提高代码的效率，因为虚函数存在运行时开销）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Function Pointer Impletation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter &amp;gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span> <span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span> </span></span><br><span class="line"><span class="function">        : healthFunc(hcf) &#123;</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;	<span class="comment">// 函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="条款-36：绝不重新定义继承而来的-non-virtual-函数"><a href="#条款-36：绝不重新定义继承而来的-non-virtual-函数" class="headerlink" title="条款 36：绝不重新定义继承而来的 non-virtual 函数"></a>条款 36：绝不重新定义继承而来的 non-virtual 函数</h3><p>因为在 class 内声明一个 non-virtual 函数会为该 class 建立起一个不变性（invariant），凌驾其特异性（specialization）。</p>
<hr>
<h3 id="条款-37：绝不重新定义继承而来的缺省参数值"><a href="#条款-37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款 37：绝不重新定义继承而来的缺省参数值"></a>条款 37：绝不重新定义继承而来的缺省参数值</h3><ol>
<li>在条款 36 中说明了不要重新定义继承而来的 non-virtual 函数</li>
<li>对于 virtual 函数，为什么不要重新定义的继承而来的缺省参数值呢？因为缺省参数值都是<strong>静态绑定</strong>，而 virtual 函数却是<strong>动态绑定</strong>。</li>
</ol>
<hr>
<h3 id="条款-38：通过复合塑模出-has-a-或-“根据某物实现出”"><a href="#条款-38：通过复合塑模出-has-a-或-“根据某物实现出”" class="headerlink" title="条款 38：通过复合塑模出 has-a 或 “根据某物实现出”"></a>条款 38：通过复合塑模出 has-a 或 “根据某物实现出”</h3><ul>
<li>复合的意义和 public 继承完全不同。public 继承是一种 <strong>is-a</strong> 关系。</li>
<li>在应用域，复合意味着 <strong>has-a</strong>。在实现域，复合意味着 <strong>is-implemented-in-terms-of</strong>。</li>
</ul>
<hr>
<h3 id="条款-39：明智而审慎地使用-private-继承"><a href="#条款-39：明智而审慎地使用-private-继承" class="headerlink" title="条款 39：明智而审慎地使用 private 继承"></a>条款 39：明智而审慎地使用 private 继承</h3><ul>
<li>Private 继承意味着 is-implemented-in-terms-of。它通常比复合的优先级低，但是当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的 virtual 函数时，这么设计是合理的。</li>
<li>和复合不同，private 继承可以造成 empty base 最优化。这对致力于 “对象尺寸最小化” 的程序库开发者而言可能也很重要。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emplty</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldsAnInt1</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    Empty e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldsAnInt2</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(HoldsAnInt1) &gt; sizeof(int)</span></span><br><span class="line"><span class="comment">// sizeof(HoldsAnInt2) == sizeof(int)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="条款-40：明智而审慎地使用多重继承"><a href="#条款-40：明智而审慎地使用多重继承" class="headerlink" title="条款 40：明智而审慎地使用多重继承"></a>条款 40：明智而审慎地使用多重继承</h3><ul>
<li>virtual 继承会增加大小、速度、初始化复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及 <strong>“public 继承某个 Interface class”</strong> 和 <strong>“private 继承某个协助实现的 class”</strong> 的两相组合。如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPerson</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IPerson</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBaseID</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonInfo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PersonInfo</span><span class="params">(DatabaseID pid)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PersonInfo</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">theName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">theBirthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimClose</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CPerson 公有继承于接口类 IPerson，私有继承于协助实现类 PersonInfo</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span> :</span> <span class="keyword">public</span> IPerson, <span class="keyword">private</span> PersonInfo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Cperson</span><span class="params">(DatabaseID pid)</span> : PersonInfo(pid) &#123;</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> PersonInfo::<span class="built_in">theName</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> PersonInfo::<span class="built_in">theBirthDate</span>(); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimClose</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="条款-41：了解隐式接口和编译期多态"><a href="#条款-41：了解隐式接口和编译期多态" class="headerlink" title="条款 41：了解隐式接口和编译期多态"></a>条款 41：了解隐式接口和编译期多态</h3><p>classes 和 template 都支持接口和多态。对 classes 而言接口是显示的，以函数签名为中心，多态则是通过 virtual 函数发生在运行期。对 template 参数而言，接口是隐式的，奠基于有效表达式，多态则是通过 template 具现化和函数重载解析发生于编译期。</p>
<hr>
<h3 id="条款-42：了解-typename-的双重意义"><a href="#条款-42：了解-typename-的双重意义" class="headerlink" title="条款 42：了解 typename 的双重意义"></a>条款 42：了解 typename 的双重意义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 以下代码无法通过编译</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function">C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">        ++iter;</span><br><span class="line">        <span class="keyword">int</span> value = *iter;</span><br><span class="line">        std::cout &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>模板内出现的名称如果相依于某个模板参数，则称之为<strong>从属名称</strong>。</p>
</li>
<li><p>如果从属名称在 class 内呈嵌套状，则称之为<strong>嵌套从属名称</strong>。如上述代码中的 <code>C::const_iterator</code>。</p>
</li>
<li><p>如果嵌套从属名称还指涉某个类型，则称之为<strong>嵌套从属类型名称</strong>。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 嵌套从属名称有可能会导致解析困难。如下代码中，C::const_iterator可以是一个类型，用来声明x为一个local指针变量；其也可以是一个变量，表示和x相乘。此处会造成二义性。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;typaname C&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    C::const_iterator* x;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>C++ 在处理这种二义性时候的方式：<strong>如果解析器在模板中遭遇到一个嵌套从属名称，它边假设这个名称不是一个类型，除非你告诉它是。</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 例外：typename 不可以出现在base class list内的嵌套从属类型名称之前，也不可在member initialization list(成员初值列)中作为base class修饰符。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;T&gt;::Nested &#123;	<span class="comment">/// base class list中不允许typename</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="keyword">int</span> x)</span> : Base&lt;T&gt;：：Nested(x) &#123;</span>	<span class="comment">/// mem.init.list中不允许typename</span></span><br><span class="line">        <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;	<span class="comment">/// 必须加上typename</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>一般性规则：<strong>任何时候想要在模板中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置加上关键字 typename。</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="条款-43：学习处理模板化基类内的名称"><a href="#条款-43：学习处理模板化基类内的名称" class="headerlink" title="条款 43：学习处理模板化基类内的名称"></a>条款 43：学习处理模板化基类内的名称</h3><p><strong>C++ 拒绝在 derived class template 中识别 base class template 中的成员函数</strong>：因为编译器会觉得 base class template 有可能被特化，而那个特化版本可能不提供和一般性 template 相同的接口。因此它往往拒绝在 templatized base classes 内寻找继承而来的名称。三种解决方法（相当于用户对编译器做出的承诺）：</p>
<ul>
<li>在 base class 的函数调用动作之前加上 **”this-&gt;”**。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info) 	<span class="comment">// 假设sendClear是基类模板中定义的函数</span></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>使用 using 声明式。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	...</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">    		...</span><br><span class="line">    		<span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;</span><br><span class="line">    		<span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info) 	<span class="comment">// 假设sendClear是基类模板中定义的函数</span></span><br><span class="line">    		...</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li>
<li>明确的指出被调用的函数位于 base class 内。（无法使用多态！！）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	...</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">    		...</span><br><span class="line">    		<span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;</span><br><span class="line">    		MsgSender&lt;Company&gt;::<span class="built_in">sendClear</span>(info) 	<span class="comment">// 假设sendClear是基类模板中定义的函数</span></span><br><span class="line">    		...</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="条款-44：将与参数无关的代码抽离-template"><a href="#条款-44：将与参数无关的代码抽离-template" class="headerlink" title="条款 44：将与参数无关的代码抽离 template"></a>条款 44：将与参数无关的代码抽离 template</h3><ul>
<li><p>因非类型模板参数（non-type template parameter）而造成的代码膨胀，往往可以消除，做法是以<strong>函数参数</strong>或 <strong>class 成员变量</strong>替换 template 参数。</p>
</li>
<li><p>因类型模板参数（type template parameter）而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表述的实例化类型<strong>共享实现码</strong>。如：在大多数平台上，指针类型往往都有相同的二进制表述，因此凡 template 持有指针者（如 <code>vector&lt;int *&gt;</code>，<code>vector&lt;const int*&gt;</code>、<code>vector&lt;float *&gt;</code>）往往应该对每一个成员函数使用唯一一份底层实现，即令他们调用另一个操作无类型指针（即 void*）的函数。</p>
</li>
</ul>
<hr>
<h3 id="条款-45：运用成员函数模板接受所有兼容类型"><a href="#条款-45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款 45：运用成员函数模板接受所有兼容类型"></a>条款 45：运用成员函数模板接受所有兼容类型</h3><ul>
<li>请使用成员函数模板生成 “可接受所有兼容类型” 的函数。</li>
<li>如果你声明 member template 用于 “泛化 copy 构造” 或 “泛化 assignment 操作”，你还是需要声明正常的  copy 构造函数和 copy assignment 操作符，因为 “泛化” 的并不会阻止编译器生成默认的版本！</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="keyword">const</span> shared_ptr &amp; r);	<span class="comment">//copy构造函数</span></span><br><span class="line">	shared_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> shared_ptr&amp; r);	<span class="comment">// copy assignment	</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">shared_ptr</span><span class="params">(<span class="keyword">const</span> shared_ptr&lt;U&gt; &amp;r)</span></span>;	<span class="comment">//泛化copy构造函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> shared_ptr&lt;U&gt;&amp; r);	<span class="comment">// 泛化 copy assignment</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="条款-46：需要类型转换时请为模板定义非成员函数"><a href="#条款-46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款 46：需要类型转换时请为模板定义非成员函数"></a>条款 46：需要类型转换时请为模板定义非成员函数</h3><p>当我们编写一个 class template，如果它所提供的 “与此 template 相关的” 函数支持 “所有参数都可能发生隐式类型转换” 时，请将那些函数定义为 “class template” 内部的 friend 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                       lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这项技术一个有趣的点在于，我们虽然使用了 friend，却与 friend 的传统用途 “访问 class 的 non-public 成分” 毫不相干。为了让类型转换可能发生在所有的实参上，我们需要一个 non-member 函数；为了令这个函数自动具现化，我们需要将其声明在 class 内部；而在 class 内部声明 non-member 函数的唯一办法是：<strong>令它成为一个 friend</strong>。而将其定义在 class 内部的原因的是：<strong>如果以函数模板的方式定义在外部，则会导致链接失败，因为我们自己声明了一个函数，就有责任定义它</strong>。</p>
<hr>
<h3 id="条款-47：请使用-traits-classes-表现类型信息"><a href="#条款-47：请使用-traits-classes-表现类型信息" class="headerlink" title="条款 47：请使用 traits classes 表现类型信息"></a>条款 47：请使用 traits classes 表现类型信息</h3><p>STL 中 5 种迭代器的分类：</p>
<ul>
<li>input 迭代器：只能向前移动，一次一步，只可以读其所指向的东西，如 <strong>istream_iterator</strong>。</li>
<li>output 迭代器：只能向前移动，一次一步，只可以写其所指向的东西，如 <strong>ostream_iterator</strong>。</li>
<li>forward 迭代器：只能向前移动，可读可写多次，如 forward list 中的迭代器。</li>
<li>bidirectional 迭代器：除了可以向前移动，还可以向后移动。如 set、multiset、map 和 multimap 中的迭代器。</li>
<li>random access 迭代器：在常量时间内向前或向后跳跃任意距离。如 vector、deque 和 string 提供的迭代器。</li>
</ul>
<p>假设要为五种迭代器实现以下的 advance 模板函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT&amp; Iter, DistT d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.先为五种迭代器提供专属的tag struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 实现 iterator_traits，注意特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> IterT::iterator_category iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;	<span class="comment">// 用来支持普通指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>IterT*&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.实现一组重载函数模板，根据不同的iterator类型实现相应功能</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d ,random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    iter += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d ,bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d ,input_iterator_tag)</span> </span>&#123;	<span class="comment">//  forward_iterator_tag 也可用这个</span></span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (d--) ++iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d ,output_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (d--) ++iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.实现Advance函数，根据迭代器类型自动推倒出其所属类型信息，调用相应的doAdvance</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Advance</span><span class="params">(IterT &amp;iter, DistT d)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">doAdvance</span>(iter, d, <span class="keyword">typename</span> iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.使用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;	<span class="comment">// 注意要指定该迭代器所属于的类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> point_diff;</span><br><span class="line"></span><br><span class="line">    MyIterator&amp; <span class="keyword">operator</span>+=(point_diff dif)&#123;</span><br><span class="line">        ptr += dif;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>trait 哲学：在编译期间取得某些类型信息。</strong></p>
<p>设计并实现一个 trait class：</p>
<ol>
<li>确认若干你希望将来可以取得的类型相关信息（tag struct）。例如对于迭代器而言，希望取得其分类。</li>
<li>为该信息选择一个名称（例如 iterator_category）。</li>
<li>提供一个 template 和一组特化版本（如 iterator_traits），内含你希望支持的类型相关信息。</li>
</ol>
<p>如何使用一个 trait classes：</p>
<ol>
<li>建立一组重载函数（劳工函数）或函数模板，彼此间的差异只在于各自的 trait 参数。另每个函数实现与其接受的 trait 信息相应和。</li>
<li>建立一个控制函数（工头函数）或函数模板，它调用上述的劳工函数并传递 trait class 所提供的信息。</li>
</ol>
<hr>
<h3 id="条款-48：认识-template-元编程"><a href="#条款-48：认识-template-元编程" class="headerlink" title="条款 48：认识 template 元编程"></a>条款 48：认识 template 元编程</h3><p>模板元编程（TMP）：以 C++ 写成，执行于 C++ 编译器内的程序，已经被证明是一个 “图灵完全” 的机器。</p>
<p>以 Factorial 示范 TMP：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span>&lt;</span><span class="number">0</span>&gt; &#123;	<span class="comment">//特化模板表示边界</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> &#123;</span> value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有没有 TMP 的调试器？？？？？？？？？？？？？？</p>
<hr>
<h3 id="条款-49：了解-new-handler-的行为"><a href="#条款-49：了解-new-handler-的行为" class="headerlink" title="条款 49：了解 new-handler 的行为"></a>条款 49：了解 new-handler 的行为</h3><p>当 operator new 无法满足某一内存分配需求时，其会抛出异常，调用异常处理函数 new-handler。通过 <code>set_new_handler</code> 来指定该异常处理函数，那是声明于 <new> 的一个标准程序库函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;	<span class="comment">// 返回值是该函数调用前的那个new-handler函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设计良好的 new-handler 函数必须做以下事情：</p>
<ul>
<li>让更多内存可被使用。</li>
<li>安装另一个 new-handler。</li>
<li>卸除 new-handler。将 null 指针传给 set_new_handler，一旦没有安装任何 new-handler，operator new 在内存分配失败时抛出异常。</li>
<li>抛出 bad_alloc 的异常。这样的异常不会被 operator new 捕捉，因此会被传播到内存索求处。</li>
</ul>
<p>自己指定专属于某个 class 的 new-handler：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewHandlerHolder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(std::new_handler nh)</span> : oldHandler(nh) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">NewHandlerHolder</span>() &#123;</span><br><span class="line">        std::<span class="built_in">set_new_handler</span>(oldHandler);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::new_handler oldHandler;</span><br><span class="line">    <span class="built_in">NewHandlerHolder</span>(<span class="keyword">const</span> NewHandlerHolder&amp;);</span><br><span class="line">    NewHandlerHolder &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NewHandlerHolder&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 以下实现可以使的class Widget设定自己new-handler，默认为nullptr</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;    <span class="comment">// 用户应该调用该函数为Widget指定new-handler</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::new_handler Widget::currentHandler = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function">std::new_handler <span class="title">Widget::set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *Widget::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;   <span class="comment">// RAII 的方式将原有的global new-handler保存，并使其自动恢复</span></span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 以下将实现一个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewHandlerSupport</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;    <span class="comment">// 用户应该调用该函数为Widget指定new-handler</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler </span><br><span class="line">NewHandlerSupport&lt;T&gt;::<span class="built_in">set_new_handler</span>(std::new_handler p) <span class="keyword">throw</span>() &#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> *NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget2</span> :</span> <span class="keyword">public</span> NewHandlerSupport&lt;Widget2&gt; &#123;  <span class="comment">// CRTP</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="条款-50：了解-new-和-delete-的合理替换时机"><a href="#条款-50：了解-new-和-delete-的合理替换时机" class="headerlink" title="条款 50：了解 new 和 delete 的合理替换时机"></a>条款 50：了解 new 和 delete 的合理替换时机</h3><p>有许多的理由需要写一个自定义的 new 和 delete，包括改善性能、对 heap 运用错误进行调试、收集 heap 使用信息。</p>
<hr>
<h3 id="条款-51：编写-new-和-delete-时需固守陈规"><a href="#条款-51：编写-new-和-delete-时需固守陈规" class="headerlink" title="条款 51：编写 new 和 delete 时需固守陈规"></a>条款 51：编写 new 和 delete 时需固守陈规</h3><p>以下是 operator new 伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;	<span class="comment">// 处理 0 个字节的分配请求</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;		<span class="comment">// 直到分配失败或者排除异常</span></span><br><span class="line">        尝试分配 size bytes；</span><br><span class="line">        <span class="keyword">if</span> (分配成功)</span><br><span class="line">        <span class="keyword">return</span> (一个指针，指向分配得来的内存)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 分配失败，找出目前的new-handling函数（见下）</span></span><br><span class="line">        new_handler globalhandler = <span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">set_new_handler</span>(globalhandler);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (globalHandler) (*globalHandler)();	</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); 	<span class="comment">// 没有设置new-handler时，抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑继承的情况下，处理好 operator new 和 operator delete 函数。</p>
<p>原则：针对 class X 而设计的 operator new，其行为很典型地只为<strong>大小刚好为 sizeof(X)</strong> 的对象而设计。而</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory, std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* Base::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bac_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in"><span class="keyword">sizeof</span></span>(Base))</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size); <span class="comment">// 如果大小错误，令标准的operator new来处理</span></span><br><span class="line">    <span class="comment">// 以下实现专属于Base的new操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> Base::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory, std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rawMemory == <span class="number">0</span>)	<span class="keyword">return</span>;		<span class="comment">// 防止npd</span></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in"><span class="keyword">sizeof</span></span>(Base)) &#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(rawMemory)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下实现专属于Base的delete操作</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;&#125;;	<span class="comment">// 假设Derived未声明operator new</span></span><br><span class="line">Derived *p = <span class="keyword">new</span> Derived;		<span class="comment">// 调用Base::operator new</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="条款-52：写了-placement-new-也要写-placement-delete"><a href="#条款-52：写了-placement-new-也要写-placement-delete" class="headerlink" title="条款 52：写了 placement new 也要写 placement delete"></a>条款 52：写了 placement new 也要写 placement delete</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size, std::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">(std::bac_alloc)</span></span>;	<span class="comment">// 非正常形式的new</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory, std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// 正常形式的class专属delete</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Widget* pw = new(std::cerr) Widget;</code> // 调用 operator new 并传递 cerr 为其 ostream 实参；这个动作会在 Widget 构造函数抛出异常时泄漏内存</p>
<blockquote>
<p>以上操作，如果内存分配成功，而 Widget 构造函数抛出异常，运行期系统有责任取消 operator new 的内存分配并恢复原貌。然而运行期系统无法知道真正被调用的那个 operator new 如何运作，因为它无法取消分配并恢复旧观，所以上述做法行不通。取而代之的是运行期系统寻找 <strong>“参数个数和类型都与 operator new 相同”</strong> 的 operator delete。如果找到，则调用它；否则，没有任何 operator delete 会被调用。在上述的 class Widget 的定义中，没有对应的 placement delete 函数，所以可能会导致内存泄漏。</p>
</blockquote>
<p>如果上述的 placement new 操作没有抛出异常，而客户代码中有一个对应的 delete，会发生什么事：</p>
<p><code>delete pw;</code> // 调用正常的 operator delete</p>
<p>就如上一行注释所言，调用的是正常形式 operator delete，而非其 placement delete 版本。</p>
<p><strong>placement delete 只有在 “伴随 placement new 调用而触发的构造函数” 出现异常时才会被调用。</strong>所以我们必须同时提供一个正常的 operator delete 和一个 placement 版本。注意，class 中专属的 news 会掩盖 global news；derived class 中的 operator new 会掩盖 global 版本和继承版本的 operator new。</p>
<p>解决方案：采用 base class 包含所有正常形式的 new 和 delete，急用继承和 using 声明式在子类中使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardNewDeleteForms</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// normal new/delete</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">// placement new/delete</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size, <span class="keyword">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory, <span class="keyword">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">delete</span></span>(pMemory, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// nothrow new/delete</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size, <span class="keyword">const</span> std::<span class="keyword">nothrow_t</span>&amp; nt)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size, nt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pMemory, <span class="keyword">const</span> std::<span class="keyword">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">delete</span></span>(pMemory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> StandardNewDeleteForms &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">delete</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/blogCover/20.jpg" data-sites="twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/31/underlyingPrinciple-3/"><img class="prev-cover" src="/img/blogCover/21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">理解局部静态变量底层实现</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/02/interview-2/"><img class="next-cover" src="/img/blogCover/19.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++ 单例模式总结与剖析（转载）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/10/16/cpp-1/" title="C++ 中的字面值常量"><img class="cover" src="/img/blogCover/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-16</div><div class="title">C++ 中的字面值常量</div></div></a></div><div><a href="/2021/10/21/cpp-11/" title="C++ 类类型转换"><img class="cover" src="/img/blogCover/26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-21</div><div class="title">C++ 类类型转换</div></div></a></div><div><a href="/2021/10/21/cpp-13/" title="C++ 编译器自动生成的函数详解"><img class="cover" src="/img/blogCover/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-21</div><div class="title">C++ 编译器自动生成的函数详解</div></div></a></div><div><a href="/2021/10/21/cpp-14/" title="从 PL 的角度深入剖析 C++11 中的 lambda 表达式（我以为我懂了系列！）"><img class="cover" src="/img/blogCover/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-21</div><div class="title">从 PL 的角度深入剖析 C++11 中的 lambda 表达式（我以为我懂了系列！）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Nino</div><div class="author-info__description">Master, teaching makes you.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wenchuansun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wenchuansun" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://leetcode-cn.com/u/tempestate_" target="_blank" title="leetcode"><i class="fas fa-laptop"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5-const%EF%BC%8Cenum%EF%BC%8Cinline-%E6%9B%BF%E6%8D%A2-define"><span class="toc-number">1.</span> <span class="toc-text">条款 02：尽量以 const，enum，inline 替换 #define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8-const"><span class="toc-number">2.</span> <span class="toc-text">条款 03：尽可能使用 const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E5%9C%A8%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">条款 04：确定对象在使用前已经被初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-05%EF%BC%9A%E4%BA%86%E8%A7%A3-C-%E9%BB%98%E8%AE%A4%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">条款 05：了解 C++ 默认编写并调用了哪些函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="toc-number">5.</span> <span class="toc-text">条款 06：若不想使用编译器自动生成的函数，就该明确拒绝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8E-virtual-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">条款 07：为多态基类声明 virtual 析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">条款 08：别让异常逃离析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8-virtual-%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">条款 09：绝不在构造和析构的过程中调用 virtual 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-10%EF%BC%9A%E4%BB%A4-operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-reference-to-this"><span class="toc-number">9.</span> <span class="toc-text">条款 10：令 operator&#x3D; 返回一个 reference to *this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-11%EF%BC%9A%E5%9C%A8-operator-%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E8%B5%8B%E5%80%BC"><span class="toc-number">10.</span> <span class="toc-text">条款 11：在 operator&#x3D; 中处理自赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="toc-number">11.</span> <span class="toc-text">条款 12：复制对象时勿忘其每一个成分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-number">12.</span> <span class="toc-text">条款 13：以对象管理资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83-coping-%E8%A1%8C%E4%B8%BA"><span class="toc-number">13.</span> <span class="toc-text">条款 14：在资源管理类中小心 coping 行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">14.</span> <span class="toc-text">条款 15：在资源管理类中提供对原始资源的访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8-new-%E5%92%8C-delete-%E6%97%B6%E8%A6%81%E9%87%87%E7%94%A8%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">条款 16：成对使用 new 和 delete 时要采用相同形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-17%EF%BC%9A-%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86-newed-%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">16.</span> <span class="toc-text">条款 17： 以独立语句将 newed 对象置入智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="toc-number">17.</span> <span class="toc-text">条款 18：让接口容易被正确使用，不易被误用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-19%EF%BC%9A%E8%AE%BE%E8%AE%A1-class-%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1-type"><span class="toc-number">18.</span> <span class="toc-text">条款 19：设计 class 犹如设计 type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-20%EF%BC%9A%E5%AE%81%E4%BB%A5-pass-by-reference-to-const-%E6%9B%BF%E6%8D%A2-pass-by-value"><span class="toc-number">19.</span> <span class="toc-text">条款 20：宁以 pass-by-reference-to-const 替换 pass-by-value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6-reference"><span class="toc-number">20.</span> <span class="toc-text">条款 21：必须返回对象时，别妄想返回其 reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BA-private"><span class="toc-number">21.</span> <span class="toc-text">条款 22：将成员变量声明为 private</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-23%EF%BC%9A%E5%AE%81%E4%BB%A5-non-member%E3%80%81non-friend-%E6%9B%BF%E6%8D%A2-member-%E5%87%BD%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">条款 23：宁以 non-member、non-friend 替换 member 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8-non-member-%E5%87%BD%E6%95%B0"><span class="toc-number">23.</span> <span class="toc-text">条款 24：若所有参数皆需类型转换，请为此采用 non-member 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-25%EF%BC%9A%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84-swap-%E5%87%BD%E6%95%B0"><span class="toc-number">24.</span> <span class="toc-text">条款 25：考虑写出一个不抛异常的 swap 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-26%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4"><span class="toc-number">25.</span> <span class="toc-text">条款 26：尽可能延后变量定义式的出现时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="toc-number">26.</span> <span class="toc-text">条款 27：尽量少做转型动作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-28%EF%BC%9A%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9E-handle-%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="toc-number">27.</span> <span class="toc-text">条款 28：避免返回 handle 指向对象内部成分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-29%EF%BC%9A-%E4%B8%BA%E2%80%9C%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="toc-number">28.</span> <span class="toc-text">条款 29： 为“异常安全”而努力是值得的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-30%EF%BC%9A%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3-inlining-%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="toc-number">29.</span> <span class="toc-text">条款 30：透彻了解 inlining 的里里外外</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-31%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E"><span class="toc-number">30.</span> <span class="toc-text">条款 31：将文件间的编译依存关系降至最低</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-32%EF%BC%9A%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84-public-%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BA-is-a-%E5%85%B3%E7%B3%BB"><span class="toc-number">31.</span> <span class="toc-text">条款 32：确定你的 public 继承塑模出 is-a 关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-33%EF%BC%9A%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">32.</span> <span class="toc-text">条款 33：避免遮掩继承而来的名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-34%EF%BC%9A%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">33.</span> <span class="toc-text">条款 34：区分接口继承和实现继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-35%EF%BC%9A%E8%80%83%E8%99%91-virtual-%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="toc-number">34.</span> <span class="toc-text">条款 35：考虑 virtual 函数以外的其他选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-36%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84-non-virtual-%E5%87%BD%E6%95%B0"><span class="toc-number">35.</span> <span class="toc-text">条款 36：绝不重新定义继承而来的 non-virtual 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-37%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">36.</span> <span class="toc-text">条款 37：绝不重新定义继承而来的缺省参数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-38%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BA-has-a-%E6%88%96-%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D"><span class="toc-number">37.</span> <span class="toc-text">条款 38：通过复合塑模出 has-a 或 “根据某物实现出”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-39%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8-private-%E7%BB%A7%E6%89%BF"><span class="toc-number">38.</span> <span class="toc-text">条款 39：明智而审慎地使用 private 继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-40%EF%BC%9A%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">39.</span> <span class="toc-text">条款 40：明智而审慎地使用多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-41%EF%BC%9A%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81"><span class="toc-number">40.</span> <span class="toc-text">条款 41：了解隐式接口和编译期多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-42%EF%BC%9A%E4%BA%86%E8%A7%A3-typename-%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="toc-number">41.</span> <span class="toc-text">条款 42：了解 typename 的双重意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-43%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">42.</span> <span class="toc-text">条款 43：学习处理模板化基类内的名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-44%EF%BC%9A%E5%B0%86%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BB-template"><span class="toc-number">43.</span> <span class="toc-text">条款 44：将与参数无关的代码抽离 template</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-45%EF%BC%9A%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">44.</span> <span class="toc-text">条款 45：运用成员函数模板接受所有兼容类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-46%EF%BC%9A%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">45.</span> <span class="toc-text">条款 46：需要类型转换时请为模板定义非成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-47%EF%BC%9A%E8%AF%B7%E4%BD%BF%E7%94%A8-traits-classes-%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">46.</span> <span class="toc-text">条款 47：请使用 traits classes 表现类型信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-48%EF%BC%9A%E8%AE%A4%E8%AF%86-template-%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">47.</span> <span class="toc-text">条款 48：认识 template 元编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-49%EF%BC%9A%E4%BA%86%E8%A7%A3-new-handler-%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">48.</span> <span class="toc-text">条款 49：了解 new-handler 的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-50%EF%BC%9A%E4%BA%86%E8%A7%A3-new-%E5%92%8C-delete-%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="toc-number">49.</span> <span class="toc-text">条款 50：了解 new 和 delete 的合理替换时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-51%EF%BC%9A%E7%BC%96%E5%86%99-new-%E5%92%8C-delete-%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E9%99%88%E8%A7%84"><span class="toc-number">50.</span> <span class="toc-text">条款 51：编写 new 和 delete 时需固守陈规</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-52%EF%BC%9A%E5%86%99%E4%BA%86-placement-new-%E4%B9%9F%E8%A6%81%E5%86%99-placement-delete"><span class="toc-number">51.</span> <span class="toc-text">条款 52：写了 placement new 也要写 placement delete</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/llvm-5/" title="学会调试 LLVM opt 中的 PassManager 和 AnalysisManager"><img src="/img/blogCover/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学会调试 LLVM opt 中的 PassManager 和 AnalysisManager"/></a><div class="content"><a class="title" href="/2022/04/16/llvm-5/" title="学会调试 LLVM opt 中的 PassManager 和 AnalysisManager">学会调试 LLVM opt 中的 PassManager 和 AnalysisManager</a><time datetime="2022-04-16T06:19:45.000Z" title="发表于 2022-04-16 14:19:45">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/llvm-4/" title="怎么基于 Pass New Manager 利用 PassPlugin 写 LLVM Pass（out-of-tree Pass Development）"><img src="/img/blogCover/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="怎么基于 Pass New Manager 利用 PassPlugin 写 LLVM Pass（out-of-tree Pass Development）"/></a><div class="content"><a class="title" href="/2022/04/16/llvm-4/" title="怎么基于 Pass New Manager 利用 PassPlugin 写 LLVM Pass（out-of-tree Pass Development）">怎么基于 Pass New Manager 利用 PassPlugin 写 LLVM Pass（out-of-tree Pass Development）</a><time datetime="2022-04-16T06:18:11.000Z" title="发表于 2022-04-16 14:18:11">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/llvm-3/" title="怎样在 opt 中利用 new PassManager 中写 Pass"><img src="/img/blogCover/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="怎样在 opt 中利用 new PassManager 中写 Pass"/></a><div class="content"><a class="title" href="/2022/04/16/llvm-3/" title="怎样在 opt 中利用 new PassManager 中写 Pass">怎样在 opt 中利用 new PassManager 中写 Pass</a><time datetime="2022-04-16T06:16:18.000Z" title="发表于 2022-04-16 14:16:18">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/underlyingPrinciple-9/" title="深入理解对象内存模型（二）"><img src="/img/blogCover/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解对象内存模型（二）"/></a><div class="content"><a class="title" href="/2022/03/31/underlyingPrinciple-9/" title="深入理解对象内存模型（二）">深入理解对象内存模型（二）</a><time datetime="2022-03-31T12:05:47.000Z" title="发表于 2022-03-31 20:05:47">2022-03-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Nino</div><div class="footer_custom_text">Hi, welcome to my pretty blog!</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><!--<img src="https://static.dy208.cn/o_1dfilp8ruo521thr1hvf18ji17soa.png">--><a href="http://www.beian.miit.gov.cn/" target="_blank"> | 湘ICP备2022001549号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script>(function(d, w, c) {
    w.ChatraID = 'yEBQMsndkiJxuHuQb';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>